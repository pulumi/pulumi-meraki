// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.meraki.networks.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.meraki.networks.inputs.ApplianceVpnBgpNeighborAuthenticationArgs;
import com.pulumi.meraki.networks.inputs.ApplianceVpnBgpNeighborIpv6Args;
import com.pulumi.meraki.networks.inputs.ApplianceVpnBgpNeighborTtlSecurityArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ApplianceVpnBgpNeighborArgs extends com.pulumi.resources.ResourceArgs {

    public static final ApplianceVpnBgpNeighborArgs Empty = new ApplianceVpnBgpNeighborArgs();

    /**
     * When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
     * 
     */
    @Import(name="allowTransit")
    private @Nullable Output<Boolean> allowTransit;

    /**
     * @return When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
     * 
     */
    public Optional<Output<Boolean>> allowTransit() {
        return Optional.ofNullable(this.allowTransit);
    }

    /**
     * Authentication settings between BGP peers.
     * 
     */
    @Import(name="authentication")
    private @Nullable Output<ApplianceVpnBgpNeighborAuthenticationArgs> authentication;

    /**
     * @return Authentication settings between BGP peers.
     * 
     */
    public Optional<Output<ApplianceVpnBgpNeighborAuthenticationArgs>> authentication() {
        return Optional.ofNullable(this.authentication);
    }

    /**
     * The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
     * 
     */
    @Import(name="ebgpHoldTimer")
    private @Nullable Output<Integer> ebgpHoldTimer;

    /**
     * @return The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
     * 
     */
    public Optional<Output<Integer>> ebgpHoldTimer() {
        return Optional.ofNullable(this.ebgpHoldTimer);
    }

    /**
     * Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
     * 
     */
    @Import(name="ebgpMultihop")
    private @Nullable Output<Integer> ebgpMultihop;

    /**
     * @return Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
     * 
     */
    public Optional<Output<Integer>> ebgpMultihop() {
        return Optional.ofNullable(this.ebgpMultihop);
    }

    /**
     * The IPv4 address of the neighbor
     * 
     */
    @Import(name="ip")
    private @Nullable Output<String> ip;

    /**
     * @return The IPv4 address of the neighbor
     * 
     */
    public Optional<Output<String>> ip() {
        return Optional.ofNullable(this.ip);
    }

    /**
     * Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
     * 
     */
    @Import(name="ipv6")
    private @Nullable Output<ApplianceVpnBgpNeighborIpv6Args> ipv6;

    /**
     * @return Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
     * 
     */
    public Optional<Output<ApplianceVpnBgpNeighborIpv6Args>> ipv6() {
        return Optional.ofNullable(this.ipv6);
    }

    /**
     * The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
     * 
     */
    @Import(name="nextHopIp")
    private @Nullable Output<String> nextHopIp;

    /**
     * @return The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
     * 
     */
    public Optional<Output<String>> nextHopIp() {
        return Optional.ofNullable(this.nextHopIp);
    }

    /**
     * The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
     * 
     */
    @Import(name="receiveLimit")
    private @Nullable Output<Integer> receiveLimit;

    /**
     * @return The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
     * 
     */
    public Optional<Output<Integer>> receiveLimit() {
        return Optional.ofNullable(this.receiveLimit);
    }

    /**
     * Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
     * 
     */
    @Import(name="remoteAsNumber")
    private @Nullable Output<Integer> remoteAsNumber;

    /**
     * @return Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
     * 
     */
    public Optional<Output<Integer>> remoteAsNumber() {
        return Optional.ofNullable(this.remoteAsNumber);
    }

    /**
     * The output interface for peering with the remote BGP peer. Valid values are: &#39;wan1&#39;, &#39;wan2&#39; or &#39;vlan{VLAN ID}&#39;(e.g. &#39;vlan123&#39;).
     * 
     */
    @Import(name="sourceInterface")
    private @Nullable Output<String> sourceInterface;

    /**
     * @return The output interface for peering with the remote BGP peer. Valid values are: &#39;wan1&#39;, &#39;wan2&#39; or &#39;vlan{VLAN ID}&#39;(e.g. &#39;vlan123&#39;).
     * 
     */
    public Optional<Output<String>> sourceInterface() {
        return Optional.ofNullable(this.sourceInterface);
    }

    /**
     * Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
     * 
     */
    @Import(name="ttlSecurity")
    private @Nullable Output<ApplianceVpnBgpNeighborTtlSecurityArgs> ttlSecurity;

    /**
     * @return Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
     * 
     */
    public Optional<Output<ApplianceVpnBgpNeighborTtlSecurityArgs>> ttlSecurity() {
        return Optional.ofNullable(this.ttlSecurity);
    }

    private ApplianceVpnBgpNeighborArgs() {}

    private ApplianceVpnBgpNeighborArgs(ApplianceVpnBgpNeighborArgs $) {
        this.allowTransit = $.allowTransit;
        this.authentication = $.authentication;
        this.ebgpHoldTimer = $.ebgpHoldTimer;
        this.ebgpMultihop = $.ebgpMultihop;
        this.ip = $.ip;
        this.ipv6 = $.ipv6;
        this.nextHopIp = $.nextHopIp;
        this.receiveLimit = $.receiveLimit;
        this.remoteAsNumber = $.remoteAsNumber;
        this.sourceInterface = $.sourceInterface;
        this.ttlSecurity = $.ttlSecurity;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ApplianceVpnBgpNeighborArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ApplianceVpnBgpNeighborArgs $;

        public Builder() {
            $ = new ApplianceVpnBgpNeighborArgs();
        }

        public Builder(ApplianceVpnBgpNeighborArgs defaults) {
            $ = new ApplianceVpnBgpNeighborArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowTransit When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder allowTransit(@Nullable Output<Boolean> allowTransit) {
            $.allowTransit = allowTransit;
            return this;
        }

        /**
         * @param allowTransit When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder allowTransit(Boolean allowTransit) {
            return allowTransit(Output.of(allowTransit));
        }

        /**
         * @param authentication Authentication settings between BGP peers.
         * 
         * @return builder
         * 
         */
        public Builder authentication(@Nullable Output<ApplianceVpnBgpNeighborAuthenticationArgs> authentication) {
            $.authentication = authentication;
            return this;
        }

        /**
         * @param authentication Authentication settings between BGP peers.
         * 
         * @return builder
         * 
         */
        public Builder authentication(ApplianceVpnBgpNeighborAuthenticationArgs authentication) {
            return authentication(Output.of(authentication));
        }

        /**
         * @param ebgpHoldTimer The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
         * 
         * @return builder
         * 
         */
        public Builder ebgpHoldTimer(@Nullable Output<Integer> ebgpHoldTimer) {
            $.ebgpHoldTimer = ebgpHoldTimer;
            return this;
        }

        /**
         * @param ebgpHoldTimer The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
         * 
         * @return builder
         * 
         */
        public Builder ebgpHoldTimer(Integer ebgpHoldTimer) {
            return ebgpHoldTimer(Output.of(ebgpHoldTimer));
        }

        /**
         * @param ebgpMultihop Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
         * 
         * @return builder
         * 
         */
        public Builder ebgpMultihop(@Nullable Output<Integer> ebgpMultihop) {
            $.ebgpMultihop = ebgpMultihop;
            return this;
        }

        /**
         * @param ebgpMultihop Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
         * 
         * @return builder
         * 
         */
        public Builder ebgpMultihop(Integer ebgpMultihop) {
            return ebgpMultihop(Output.of(ebgpMultihop));
        }

        /**
         * @param ip The IPv4 address of the neighbor
         * 
         * @return builder
         * 
         */
        public Builder ip(@Nullable Output<String> ip) {
            $.ip = ip;
            return this;
        }

        /**
         * @param ip The IPv4 address of the neighbor
         * 
         * @return builder
         * 
         */
        public Builder ip(String ip) {
            return ip(Output.of(ip));
        }

        /**
         * @param ipv6 Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
         * 
         * @return builder
         * 
         */
        public Builder ipv6(@Nullable Output<ApplianceVpnBgpNeighborIpv6Args> ipv6) {
            $.ipv6 = ipv6;
            return this;
        }

        /**
         * @param ipv6 Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
         * 
         * @return builder
         * 
         */
        public Builder ipv6(ApplianceVpnBgpNeighborIpv6Args ipv6) {
            return ipv6(Output.of(ipv6));
        }

        /**
         * @param nextHopIp The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
         * 
         * @return builder
         * 
         */
        public Builder nextHopIp(@Nullable Output<String> nextHopIp) {
            $.nextHopIp = nextHopIp;
            return this;
        }

        /**
         * @param nextHopIp The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
         * 
         * @return builder
         * 
         */
        public Builder nextHopIp(String nextHopIp) {
            return nextHopIp(Output.of(nextHopIp));
        }

        /**
         * @param receiveLimit The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
         * 
         * @return builder
         * 
         */
        public Builder receiveLimit(@Nullable Output<Integer> receiveLimit) {
            $.receiveLimit = receiveLimit;
            return this;
        }

        /**
         * @param receiveLimit The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
         * 
         * @return builder
         * 
         */
        public Builder receiveLimit(Integer receiveLimit) {
            return receiveLimit(Output.of(receiveLimit));
        }

        /**
         * @param remoteAsNumber Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
         * 
         * @return builder
         * 
         */
        public Builder remoteAsNumber(@Nullable Output<Integer> remoteAsNumber) {
            $.remoteAsNumber = remoteAsNumber;
            return this;
        }

        /**
         * @param remoteAsNumber Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
         * 
         * @return builder
         * 
         */
        public Builder remoteAsNumber(Integer remoteAsNumber) {
            return remoteAsNumber(Output.of(remoteAsNumber));
        }

        /**
         * @param sourceInterface The output interface for peering with the remote BGP peer. Valid values are: &#39;wan1&#39;, &#39;wan2&#39; or &#39;vlan{VLAN ID}&#39;(e.g. &#39;vlan123&#39;).
         * 
         * @return builder
         * 
         */
        public Builder sourceInterface(@Nullable Output<String> sourceInterface) {
            $.sourceInterface = sourceInterface;
            return this;
        }

        /**
         * @param sourceInterface The output interface for peering with the remote BGP peer. Valid values are: &#39;wan1&#39;, &#39;wan2&#39; or &#39;vlan{VLAN ID}&#39;(e.g. &#39;vlan123&#39;).
         * 
         * @return builder
         * 
         */
        public Builder sourceInterface(String sourceInterface) {
            return sourceInterface(Output.of(sourceInterface));
        }

        /**
         * @param ttlSecurity Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
         * 
         * @return builder
         * 
         */
        public Builder ttlSecurity(@Nullable Output<ApplianceVpnBgpNeighborTtlSecurityArgs> ttlSecurity) {
            $.ttlSecurity = ttlSecurity;
            return this;
        }

        /**
         * @param ttlSecurity Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
         * 
         * @return builder
         * 
         */
        public Builder ttlSecurity(ApplianceVpnBgpNeighborTtlSecurityArgs ttlSecurity) {
            return ttlSecurity(Output.of(ttlSecurity));
        }

        public ApplianceVpnBgpNeighborArgs build() {
            return $;
        }
    }

}
