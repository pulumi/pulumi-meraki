// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.meraki.networks;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.meraki.Utilities;
import com.pulumi.meraki.networks.WirelessSsidsArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsState;
import com.pulumi.meraki.networks.outputs.WirelessSsidsActiveDirectory;
import com.pulumi.meraki.networks.outputs.WirelessSsidsApTagsAndVlanId;
import com.pulumi.meraki.networks.outputs.WirelessSsidsDnsRewrite;
import com.pulumi.meraki.networks.outputs.WirelessSsidsDot11r;
import com.pulumi.meraki.networks.outputs.WirelessSsidsDot11w;
import com.pulumi.meraki.networks.outputs.WirelessSsidsGre;
import com.pulumi.meraki.networks.outputs.WirelessSsidsLdap;
import com.pulumi.meraki.networks.outputs.WirelessSsidsLocalRadius;
import com.pulumi.meraki.networks.outputs.WirelessSsidsNamedVlans;
import com.pulumi.meraki.networks.outputs.WirelessSsidsOauth;
import com.pulumi.meraki.networks.outputs.WirelessSsidsRadiusAccountingServer;
import com.pulumi.meraki.networks.outputs.WirelessSsidsRadiusServer;
import com.pulumi.meraki.networks.outputs.WirelessSsidsRadiusServersResponse;
import com.pulumi.meraki.networks.outputs.WirelessSsidsSpeedBurst;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.meraki.networks.WirelessSsids;
 * import com.pulumi.meraki.networks.WirelessSsidsArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsActiveDirectoryArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsActiveDirectoryCredentialsArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsApTagsAndVlanIdArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsDnsRewriteArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsDot11rArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsDot11wArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsGreArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsGreConcentratorArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsLdapArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsLdapCredentialsArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsLocalRadiusArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsNamedVlansArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsNamedVlansRadiusArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsNamedVlansRadiusGuestVlanArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsNamedVlansTaggingArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsOauthArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsRadiusAccountingServerArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsRadiusServerArgs;
 * import com.pulumi.meraki.networks.inputs.WirelessSsidsSpeedBurstArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var example = new WirelessSsids("example", WirelessSsidsArgs.builder()
 *             .activeDirectory(WirelessSsidsActiveDirectoryArgs.builder()
 *                 .credentials(WirelessSsidsActiveDirectoryCredentialsArgs.builder()
 *                     .logonName("user")
 *                     .password("password")
 *                     .build())
 *                 .servers(WirelessSsidsActiveDirectoryServerArgs.builder()
 *                     .host("127.0.0.1")
 *                     .port(3268)
 *                     .build())
 *                 .build())
 *             .adultContentFilteringEnabled(false)
 *             .apTagsAndVlanIds(WirelessSsidsApTagsAndVlanIdArgs.builder()
 *                 .tags(                
 *                     "tag1",
 *                     "tag2")
 *                 .vlan_id(100)
 *                 .build())
 *             .authMode("8021x-radius")
 *             .availabilityTags(            
 *                 "tag1",
 *                 "tag2")
 *             .availableOnAllAps(false)
 *             .bandSelection("5 GHz band only")
 *             .concentratorNetworkId("N_24329156")
 *             .defaultVlanId(1)
 *             .disassociateClientsOnVpnFailover(false)
 *             .dnsRewrite(WirelessSsidsDnsRewriteArgs.builder()
 *                 .dns_custom_nameservers(                
 *                     "8.8.8.8",
 *                     "8.8.4.4")
 *                 .enabled(true)
 *                 .build())
 *             .dot11r(WirelessSsidsDot11rArgs.builder()
 *                 .adaptive(true)
 *                 .enabled(true)
 *                 .build())
 *             .dot11w(WirelessSsidsDot11wArgs.builder()
 *                 .enabled(true)
 *                 .required(false)
 *                 .build())
 *             .enabled(true)
 *             .encryptionMode("wpa")
 *             .enterpriseAdminAccess("access enabled")
 *             .gre(WirelessSsidsGreArgs.builder()
 *                 .concentrator(WirelessSsidsGreConcentratorArgs.builder()
 *                     .host("192.168.1.1")
 *                     .build())
 *                 .key(5)
 *                 .build())
 *             .ipAssignmentMode("NAT mode")
 *             .lanIsolationEnabled(true)
 *             .ldap(WirelessSsidsLdapArgs.builder()
 *                 .base_distinguished_name("dc=example,dc=com")
 *                 .credentials(WirelessSsidsLdapCredentialsArgs.builder()
 *                     .distinguishedName("cn=user,dc=example,dc=com")
 *                     .password("password")
 *                     .build())
 *                 .server_ca_certificate(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                 .servers(WirelessSsidsLdapServerArgs.builder()
 *                     .host("127.0.0.1")
 *                     .port(389)
 *                     .build())
 *                 .build())
 *             .localRadius(WirelessSsidsLocalRadiusArgs.builder()
 *                 .cache_timeout(60)
 *                 .certificate_authentication(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                 .password_authentication(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))
 *                 .build())
 *             .mandatoryDhcpEnabled(false)
 *             .minBitrate(5.5)
 *             .name("My SSID")
 *             .namedVlans(WirelessSsidsNamedVlansArgs.builder()
 *                 .radius(WirelessSsidsNamedVlansRadiusArgs.builder()
 *                     .guestVlan(WirelessSsidsNamedVlansRadiusGuestVlanArgs.builder()
 *                         .enabled(true)
 *                         .name("Guest VLAN")
 *                         .build())
 *                     .build())
 *                 .tagging(WirelessSsidsNamedVlansTaggingArgs.builder()
 *                     .byApTags(WirelessSsidsNamedVlansTaggingByApTagArgs.builder()
 *                         .tags(                        
 *                             "tag1",
 *                             "tag2")
 *                         .vlanName("My VLAN")
 *                         .build())
 *                     .defaultVlanName("My VLAN")
 *                     .enabled(true)
 *                     .build())
 *                 .build())
 *             .networkId("string")
 *             .number("string")
 *             .oauth(WirelessSsidsOauthArgs.builder()
 *                 .allowed_domains("example.com")
 *                 .build())
 *             .perClientBandwidthLimitDown(1)
 *             .perClientBandwidthLimitUp(1)
 *             .perSsidBandwidthLimitDown(1)
 *             .perSsidBandwidthLimitUp(1)
 *             .psk("deadbeef")
 *             .radiusAccountingEnabled(true)
 *             .radiusAccountingInterimInterval(5)
 *             .radiusAccountingServers(WirelessSsidsRadiusAccountingServerArgs.builder()
 *                 .ca_certificate("""
 *           "-----BEGIN CERTIFICATE-----
 *         MIIDyTCCArGgAwIBAgIKBBNXOVCGU1YztjANBgkqhkiG9w0BAQsFADAnMQ4wDAYD
 *         VQQKEwVDaXNjbzEVMBMGA1UEAxMMQUNUMiBTVURJIENBMB4XDTIxMDUzMTEzNTUx
 *         NVoXDTI5MDUxNDIwMjU0MVowbTEpMCcGA1UEBRMgUElEOkM5MjAwTC0yNFAtNEcg
 *         U046SkFFMjUyMjBSMksxDjAMBgNVBAoTBUNpc2NvMRgwFgYDVQQLEw9BQ1QtMiBM
 *         aXRlIFNVREkxFjAUBgNVBAMTDUM5MjAwTC0yNFAtNEcwggEiMA0GCSqGSIb3DQEB
 *         AQUAA4IBDwAwggEKAoIBAQDaUPxW76gT5MdoEAt+UrDFiYA9RYh2iHicDViBEyow
 *         TR1TuP36bHh13X3vtGiDsCD88Ci2TZIqd/EDkkc7v9ipUUYVVH+YDrPt2Aukb1PH
 *         D6K0R+KhgEzRo5x54TlU6oWvjUpwNZUwwdhMWIQaUVkMyZBYNy0jGPLO8jwZhyBg
 *         1Fneybr9pwedGbLrAaz+gdEikB8B4a/fvPjVfL5Ngb4QRjFqWuE+X3nLc0kHedep
 *         6nfgpUNXMlStVm5nIXKP6OjmzfCHPYh9L2Ehs1TrSk1ser9Ofx0ZMVL/jBZR2EIj
 *         OZ8tH6KlX2/B2pbSPIO6kD5c4UA8Cf1SbDJCwJ/kI9ihAgMBAAGjgbAwga0wDgYD
 *         VR0PAQH/BAQDAgXgMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAUSNjx8cJw1Vu7
 *         fHMJk6+4uDAD+H8wTQYDVR0RBEYwRKBCBgkrBgEEAQkVAgOgNRMzQ2hpcElEPVVV
 *         VUNNaElGcUVFMklFUUVBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE9MB0GA1Ud
 *         DgQWBBRdhMkFD/z5hokaQeLbaRsp4hkvbzANBgkqhkiG9w0BAQsFAAOCAQEAMtuh
 *         YpBz4xEZ7YdJsLpw67Q0TTJGnTBRpzAeY1urYDoDz8TSx556XG7z3IRzuED5KVSp
 *         OwmH/iZ+tDfYQ3W3ElWTW93871DkuW4WQIfbnoHg/F7bF0DKYVkD3rpZjyz3NhzH
 *         d7cjTdJXQ85bTAOXDuxKH3qewrXxxOGXgh3I6NUq0UwMTWh84lND7Jl+ZAQkYNS2
 *         iHanTZFQBk3ML0NUb7fKDYGRTZRqwQ/upIO4S6LV1cxH/6V0qbMy3sCSHZoMLrW3
 *         0m3M6yKpe5+VZzHZwmWdUf3Ot+zKjhveK5/YNsMIASdvtvymxUizq2Hr1hvR/kPc
 *         p1vuyWxipU8JfzOh/A==
 *         -----END CERTIFICATE-----
 *         "
 *                 """)
 *                 .host("0.0.0.0")
 *                 .port(3000)
 *                 .radsec_enabled(true)
 *                 .secret("secret-string")
 *                 .build())
 *             .radiusAttributeForGroupPolicies("Filter-Id")
 *             .radiusAuthenticationNasId("00-11-22-33-44-55:AP1")
 *             .radiusCalledStationId("00-11-22-33-44-55:AP1")
 *             .radiusCoaEnabled(true)
 *             .radiusFailoverPolicy("Deny access")
 *             .radiusFallbackEnabled(true)
 *             .radiusGuestVlanEnabled(true)
 *             .radiusGuestVlanId(1)
 *             .radiusLoadBalancingPolicy("Round robin")
 *             .radiusOverride(false)
 *             .radiusProxyEnabled(false)
 *             .radiusServerAttemptsLimit(5)
 *             .radiusServerTimeout(5)
 *             .radiusServers(WirelessSsidsRadiusServerArgs.builder()
 *                 .ca_certificate("""
 *           "-----BEGIN CERTIFICATE-----
 *         MIIDyTCCArGgAwIBAgIKBBNXOVCGU1YztjANBgkqhkiG9w0BAQsFADAnMQ4wDAYD
 *         VQQKEwVDaXNjbzEVMBMGA1UEAxMMQUNUMiBTVURJIENBMB4XDTIxMDUzMTEzNTUx
 *         NVoXDTI5MDUxNDIwMjU0MVowbTEpMCcGA1UEBRMgUElEOkM5MjAwTC0yNFAtNEcg
 *         U046SkFFMjUyMjBSMksxDjAMBgNVBAoTBUNpc2NvMRgwFgYDVQQLEw9BQ1QtMiBM
 *         aXRlIFNVREkxFjAUBgNVBAMTDUM5MjAwTC0yNFAtNEcwggEiMA0GCSqGSIb3DQEB
 *         AQUAA4IBDwAwggEKAoIBAQDaUPxW76gT5MdoEAt+UrDFiYA9RYh2iHicDViBEyow
 *         TR1TuP36bHh13X3vtGiDsCD88Ci2TZIqd/EDkkc7v9ipUUYVVH+YDrPt2Aukb1PH
 *         D6K0R+KhgEzRo5x54TlU6oWvjUpwNZUwwdhMWIQaUVkMyZBYNy0jGPLO8jwZhyBg
 *         1Fneybr9pwedGbLrAaz+gdEikB8B4a/fvPjVfL5Ngb4QRjFqWuE+X3nLc0kHedep
 *         6nfgpUNXMlStVm5nIXKP6OjmzfCHPYh9L2Ehs1TrSk1ser9Ofx0ZMVL/jBZR2EIj
 *         OZ8tH6KlX2/B2pbSPIO6kD5c4UA8Cf1SbDJCwJ/kI9ihAgMBAAGjgbAwga0wDgYD
 *         VR0PAQH/BAQDAgXgMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAUSNjx8cJw1Vu7
 *         fHMJk6+4uDAD+H8wTQYDVR0RBEYwRKBCBgkrBgEEAQkVAgOgNRMzQ2hpcElEPVVV
 *         VUNNaElGcUVFMklFUUVBQWNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUE9MB0GA1Ud
 *         DgQWBBRdhMkFD/z5hokaQeLbaRsp4hkvbzANBgkqhkiG9w0BAQsFAAOCAQEAMtuh
 *         YpBz4xEZ7YdJsLpw67Q0TTJGnTBRpzAeY1urYDoDz8TSx556XG7z3IRzuED5KVSp
 *         OwmH/iZ+tDfYQ3W3ElWTW93871DkuW4WQIfbnoHg/F7bF0DKYVkD3rpZjyz3NhzH
 *         d7cjTdJXQ85bTAOXDuxKH3qewrXxxOGXgh3I6NUq0UwMTWh84lND7Jl+ZAQkYNS2
 *         iHanTZFQBk3ML0NUb7fKDYGRTZRqwQ/upIO4S6LV1cxH/6V0qbMy3sCSHZoMLrW3
 *         0m3M6yKpe5+VZzHZwmWdUf3Ot+zKjhveK5/YNsMIASdvtvymxUizq2Hr1hvR/kPc
 *         p1vuyWxipU8JfzOh/A==
 *         -----END CERTIFICATE-----
 *         "
 *                 """)
 *                 .host("0.0.0.0")
 *                 .open_roaming_certificate_id(2)
 *                 .port(3000)
 *                 .radsec_enabled(true)
 *                 .secret("secret-string")
 *                 .build())
 *             .radiusTestingEnabled(true)
 *             .secondaryConcentratorNetworkId("disabled")
 *             .speedBurst(WirelessSsidsSpeedBurstArgs.builder()
 *                 .enabled(true)
 *                 .build())
 *             .splashGuestSponsorDomains("example.com")
 *             .splashPage("Click-through splash page")
 *             .useVlanTagging(false)
 *             .visible(true)
 *             .vlanId(10)
 *             .walledGardenEnabled(true)
 *             .walledGardenRanges(            
 *                 "example.com",
 *                 "1.1.1.1/32")
 *             .wpaEncryptionMode("WPA2 only")
 *             .build());
 * 
 *         ctx.export("merakiNetworksWirelessSsidsExample", example);
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * ```sh
 * $ pulumi import meraki:networks/wirelessSsids:WirelessSsids example &#34;network_id,number&#34;
 * ```
 * 
 */
@ResourceType(type="meraki:networks/wirelessSsids:WirelessSsids")
public class WirelessSsids extends com.pulumi.resources.CustomResource {
    /**
     * The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
     * 
     */
    @Export(name="activeDirectory", refs={WirelessSsidsActiveDirectory.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsActiveDirectory> activeDirectory;

    /**
     * @return The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
     * 
     */
    public Output<Optional<WirelessSsidsActiveDirectory>> activeDirectory() {
        return Codegen.optional(this.activeDirectory);
    }
    @Export(name="adminSplashUrl", refs={String.class}, tree="[0]")
    private Output<String> adminSplashUrl;

    public Output<String> adminSplashUrl() {
        return this.adminSplashUrl;
    }
    /**
     * Boolean indicating whether or not adult content will be blocked
     * 
     */
    @Export(name="adultContentFilteringEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> adultContentFilteringEnabled;

    /**
     * @return Boolean indicating whether or not adult content will be blocked
     * 
     */
    public Output<Optional<Boolean>> adultContentFilteringEnabled() {
        return Codegen.optional(this.adultContentFilteringEnabled);
    }
    /**
     * The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Export(name="apTagsAndVlanIds", refs={List.class,WirelessSsidsApTagsAndVlanId.class}, tree="[0,1]")
    private Output</* @Nullable */ List<WirelessSsidsApTagsAndVlanId>> apTagsAndVlanIds;

    /**
     * @return The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Output<Optional<List<WirelessSsidsApTagsAndVlanId>>> apTagsAndVlanIds() {
        return Codegen.optional(this.apTagsAndVlanIds);
    }
    /**
     * The association control method for the SSID
     * 
     */
    @Export(name="authMode", refs={String.class}, tree="[0]")
    private Output<String> authMode;

    /**
     * @return The association control method for the SSID
     * 
     */
    public Output<String> authMode() {
        return this.authMode;
    }
    /**
     * List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
     * 
     */
    @Export(name="availabilityTags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> availabilityTags;

    /**
     * @return List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
     * 
     */
    public Output<Optional<List<String>>> availabilityTags() {
        return Codegen.optional(this.availabilityTags);
    }
    /**
     * Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
     * 
     */
    @Export(name="availableOnAllAps", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> availableOnAllAps;

    /**
     * @return Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
     * 
     */
    public Output<Boolean> availableOnAllAps() {
        return this.availableOnAllAps;
    }
    /**
     * The client-serving radio frequencies of this SSID in the default indoor RF profile
     * 
     */
    @Export(name="bandSelection", refs={String.class}, tree="[0]")
    private Output<String> bandSelection;

    /**
     * @return The client-serving radio frequencies of this SSID in the default indoor RF profile
     * 
     */
    public Output<String> bandSelection() {
        return this.bandSelection;
    }
    /**
     * The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
     * 
     */
    @Export(name="concentratorNetworkId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> concentratorNetworkId;

    /**
     * @return The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
     * 
     */
    public Output<Optional<String>> concentratorNetworkId() {
        return Codegen.optional(this.concentratorNetworkId);
    }
    /**
     * The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Export(name="defaultVlanId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> defaultVlanId;

    /**
     * @return The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Output<Optional<Integer>> defaultVlanId() {
        return Codegen.optional(this.defaultVlanId);
    }
    /**
     * Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
     * 
     */
    @Export(name="disassociateClientsOnVpnFailover", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disassociateClientsOnVpnFailover;

    /**
     * @return Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
     * 
     */
    public Output<Optional<Boolean>> disassociateClientsOnVpnFailover() {
        return Codegen.optional(this.disassociateClientsOnVpnFailover);
    }
    /**
     * DNS servers rewrite settings
     * 
     */
    @Export(name="dnsRewrite", refs={WirelessSsidsDnsRewrite.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsDnsRewrite> dnsRewrite;

    /**
     * @return DNS servers rewrite settings
     * 
     */
    public Output<Optional<WirelessSsidsDnsRewrite>> dnsRewrite() {
        return Codegen.optional(this.dnsRewrite);
    }
    /**
     * The current setting for 802.11r
     * 
     */
    @Export(name="dot11r", refs={WirelessSsidsDot11r.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsDot11r> dot11r;

    /**
     * @return The current setting for 802.11r
     * 
     */
    public Output<Optional<WirelessSsidsDot11r>> dot11r() {
        return Codegen.optional(this.dot11r);
    }
    /**
     * The current setting for Protected Management Frames (802.11w).
     * 
     */
    @Export(name="dot11w", refs={WirelessSsidsDot11w.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsDot11w> dot11w;

    /**
     * @return The current setting for Protected Management Frames (802.11w).
     * 
     */
    public Output<Optional<WirelessSsidsDot11w>> dot11w() {
        return Codegen.optional(this.dot11w);
    }
    /**
     * Whether or not the SSID is enabled
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enabled;

    /**
     * @return Whether or not the SSID is enabled
     * 
     */
    public Output<Boolean> enabled() {
        return this.enabled;
    }
    /**
     * The psk encryption mode for the SSID
     * 
     */
    @Export(name="encryptionMode", refs={String.class}, tree="[0]")
    private Output<String> encryptionMode;

    /**
     * @return The psk encryption mode for the SSID
     * 
     */
    public Output<String> encryptionMode() {
        return this.encryptionMode;
    }
    /**
     * Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
     * 
     */
    @Export(name="enterpriseAdminAccess", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> enterpriseAdminAccess;

    /**
     * @return Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
     * 
     */
    public Output<Optional<String>> enterpriseAdminAccess() {
        return Codegen.optional(this.enterpriseAdminAccess);
    }
    /**
     * Ethernet over GRE settings
     * 
     */
    @Export(name="gre", refs={WirelessSsidsGre.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsGre> gre;

    /**
     * @return Ethernet over GRE settings
     * 
     */
    public Output<Optional<WirelessSsidsGre>> gre() {
        return Codegen.optional(this.gre);
    }
    /**
     * The client IP assignment mode
     * 
     */
    @Export(name="ipAssignmentMode", refs={String.class}, tree="[0]")
    private Output<String> ipAssignmentMode;

    /**
     * @return The client IP assignment mode
     * 
     */
    public Output<String> ipAssignmentMode() {
        return this.ipAssignmentMode;
    }
    /**
     * Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
     * 
     */
    @Export(name="lanIsolationEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> lanIsolationEnabled;

    /**
     * @return Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
     * 
     */
    public Output<Optional<Boolean>> lanIsolationEnabled() {
        return Codegen.optional(this.lanIsolationEnabled);
    }
    /**
     * The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
     * 
     */
    @Export(name="ldap", refs={WirelessSsidsLdap.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsLdap> ldap;

    /**
     * @return The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
     * 
     */
    public Output<Optional<WirelessSsidsLdap>> ldap() {
        return Codegen.optional(this.ldap);
    }
    /**
     * Extended local auth flag for Enterprise NAC
     * 
     */
    @Export(name="localAuth", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> localAuth;

    /**
     * @return Extended local auth flag for Enterprise NAC
     * 
     */
    public Output<Boolean> localAuth() {
        return this.localAuth;
    }
    /**
     * The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
     * 
     */
    @Export(name="localRadius", refs={WirelessSsidsLocalRadius.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsLocalRadius> localRadius;

    /**
     * @return The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
     * 
     */
    public Output<Optional<WirelessSsidsLocalRadius>> localRadius() {
        return Codegen.optional(this.localRadius);
    }
    /**
     * Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
     * 
     */
    @Export(name="mandatoryDhcpEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> mandatoryDhcpEnabled;

    /**
     * @return Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
     * 
     */
    public Output<Boolean> mandatoryDhcpEnabled() {
        return this.mandatoryDhcpEnabled;
    }
    /**
     * The minimum bitrate in Mbps of this SSID in the default indoor RF profile
     * 
     */
    @Export(name="minBitrate", refs={Integer.class}, tree="[0]")
    private Output<Integer> minBitrate;

    /**
     * @return The minimum bitrate in Mbps of this SSID in the default indoor RF profile
     * 
     */
    public Output<Integer> minBitrate() {
        return this.minBitrate;
    }
    /**
     * The name of the SSID
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the SSID
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Named VLAN settings.
     * 
     */
    @Export(name="namedVlans", refs={WirelessSsidsNamedVlans.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsNamedVlans> namedVlans;

    /**
     * @return Named VLAN settings.
     * 
     */
    public Output<Optional<WirelessSsidsNamedVlans>> namedVlans() {
        return Codegen.optional(this.namedVlans);
    }
    /**
     * networkId path parameter. Network ID
     * 
     */
    @Export(name="networkId", refs={String.class}, tree="[0]")
    private Output<String> networkId;

    /**
     * @return networkId path parameter. Network ID
     * 
     */
    public Output<String> networkId() {
        return this.networkId;
    }
    /**
     * Unique identifier of the SSID
     * 
     */
    @Export(name="number", refs={Integer.class}, tree="[0]")
    private Output<Integer> number;

    /**
     * @return Unique identifier of the SSID
     * 
     */
    public Output<Integer> number() {
        return this.number;
    }
    /**
     * The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
     * 
     */
    @Export(name="oauth", refs={WirelessSsidsOauth.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsOauth> oauth;

    /**
     * @return The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
     * 
     */
    public Output<Optional<WirelessSsidsOauth>> oauth() {
        return Codegen.optional(this.oauth);
    }
    /**
     * The download bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    @Export(name="perClientBandwidthLimitDown", refs={Integer.class}, tree="[0]")
    private Output<Integer> perClientBandwidthLimitDown;

    /**
     * @return The download bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    public Output<Integer> perClientBandwidthLimitDown() {
        return this.perClientBandwidthLimitDown;
    }
    /**
     * The upload bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    @Export(name="perClientBandwidthLimitUp", refs={Integer.class}, tree="[0]")
    private Output<Integer> perClientBandwidthLimitUp;

    /**
     * @return The upload bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    public Output<Integer> perClientBandwidthLimitUp() {
        return this.perClientBandwidthLimitUp;
    }
    /**
     * The total download bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    @Export(name="perSsidBandwidthLimitDown", refs={Integer.class}, tree="[0]")
    private Output<Integer> perSsidBandwidthLimitDown;

    /**
     * @return The total download bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    public Output<Integer> perSsidBandwidthLimitDown() {
        return this.perSsidBandwidthLimitDown;
    }
    /**
     * The total upload bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    @Export(name="perSsidBandwidthLimitUp", refs={Integer.class}, tree="[0]")
    private Output<Integer> perSsidBandwidthLimitUp;

    /**
     * @return The total upload bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    public Output<Integer> perSsidBandwidthLimitUp() {
        return this.perSsidBandwidthLimitUp;
    }
    /**
     * The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
     * 
     */
    @Export(name="psk", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> psk;

    /**
     * @return The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
     * 
     */
    public Output<Optional<String>> psk() {
        return Codegen.optional(this.psk);
    }
    /**
     * Whether or not RADIUS accounting is enabled
     * 
     */
    @Export(name="radiusAccountingEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusAccountingEnabled;

    /**
     * @return Whether or not RADIUS accounting is enabled
     * 
     */
    public Output<Optional<Boolean>> radiusAccountingEnabled() {
        return Codegen.optional(this.radiusAccountingEnabled);
    }
    /**
     * The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     * 
     */
    @Export(name="radiusAccountingInterimInterval", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusAccountingInterimInterval;

    /**
     * @return The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     * 
     */
    public Output<Optional<Integer>> radiusAccountingInterimInterval() {
        return Codegen.optional(this.radiusAccountingInterimInterval);
    }
    /**
     * List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    @Export(name="radiusAccountingServers", refs={List.class,WirelessSsidsRadiusAccountingServer.class}, tree="[0,1]")
    private Output<List<WirelessSsidsRadiusAccountingServer>> radiusAccountingServers;

    /**
     * @return List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    public Output<List<WirelessSsidsRadiusAccountingServer>> radiusAccountingServers() {
        return this.radiusAccountingServers;
    }
    /**
     * RADIUS attribute used to look up group policies
     * 
     */
    @Export(name="radiusAttributeForGroupPolicies", refs={String.class}, tree="[0]")
    private Output<String> radiusAttributeForGroupPolicies;

    /**
     * @return RADIUS attribute used to look up group policies
     * 
     */
    public Output<String> radiusAttributeForGroupPolicies() {
        return this.radiusAttributeForGroupPolicies;
    }
    /**
     * The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    @Export(name="radiusAuthenticationNasId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> radiusAuthenticationNasId;

    /**
     * @return The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    public Output<Optional<String>> radiusAuthenticationNasId() {
        return Codegen.optional(this.radiusAuthenticationNasId);
    }
    /**
     * The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    @Export(name="radiusCalledStationId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> radiusCalledStationId;

    /**
     * @return The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    public Output<Optional<String>> radiusCalledStationId() {
        return Codegen.optional(this.radiusCalledStationId);
    }
    /**
     * If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     * 
     */
    @Export(name="radiusCoaEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusCoaEnabled;

    /**
     * @return If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     * 
     */
    public Output<Optional<Boolean>> radiusCoaEnabled() {
        return Codegen.optional(this.radiusCoaEnabled);
    }
    /**
     * Whether RADIUS authentication is enabled
     * 
     */
    @Export(name="radiusEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> radiusEnabled;

    /**
     * @return Whether RADIUS authentication is enabled
     * 
     */
    public Output<Boolean> radiusEnabled() {
        return this.radiusEnabled;
    }
    /**
     * Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
     * 
     */
    @Export(name="radiusFailoverPolicy", refs={String.class}, tree="[0]")
    private Output<String> radiusFailoverPolicy;

    /**
     * @return Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
     * 
     */
    public Output<String> radiusFailoverPolicy() {
        return this.radiusFailoverPolicy;
    }
    /**
     * Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     * 
     */
    @Export(name="radiusFallbackEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusFallbackEnabled;

    /**
     * @return Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     * 
     */
    public Output<Optional<Boolean>> radiusFallbackEnabled() {
        return Codegen.optional(this.radiusFallbackEnabled);
    }
    /**
     * Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    @Export(name="radiusGuestVlanEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusGuestVlanEnabled;

    /**
     * @return Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    public Output<Optional<Boolean>> radiusGuestVlanEnabled() {
        return Codegen.optional(this.radiusGuestVlanEnabled);
    }
    /**
     * VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    @Export(name="radiusGuestVlanId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusGuestVlanId;

    /**
     * @return VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    public Output<Optional<Integer>> radiusGuestVlanId() {
        return Codegen.optional(this.radiusGuestVlanId);
    }
    /**
     * Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
     * 
     */
    @Export(name="radiusLoadBalancingPolicy", refs={String.class}, tree="[0]")
    private Output<String> radiusLoadBalancingPolicy;

    /**
     * @return Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
     * 
     */
    public Output<String> radiusLoadBalancingPolicy() {
        return this.radiusLoadBalancingPolicy;
    }
    /**
     * If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
     * 
     */
    @Export(name="radiusOverride", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusOverride;

    /**
     * @return If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
     * 
     */
    public Output<Optional<Boolean>> radiusOverride() {
        return Codegen.optional(this.radiusOverride);
    }
    /**
     * If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     * 
     */
    @Export(name="radiusProxyEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusProxyEnabled;

    /**
     * @return If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     * 
     */
    public Output<Optional<Boolean>> radiusProxyEnabled() {
        return Codegen.optional(this.radiusProxyEnabled);
    }
    /**
     * The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     * 
     */
    @Export(name="radiusServerAttemptsLimit", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusServerAttemptsLimit;

    /**
     * @return The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     * 
     */
    public Output<Optional<Integer>> radiusServerAttemptsLimit() {
        return Codegen.optional(this.radiusServerAttemptsLimit);
    }
    /**
     * The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     * 
     */
    @Export(name="radiusServerTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusServerTimeout;

    /**
     * @return The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     * 
     */
    public Output<Optional<Integer>> radiusServerTimeout() {
        return Codegen.optional(this.radiusServerTimeout);
    }
    /**
     * The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    @Export(name="radiusServers", refs={List.class,WirelessSsidsRadiusServer.class}, tree="[0,1]")
    private Output</* @Nullable */ List<WirelessSsidsRadiusServer>> radiusServers;

    /**
     * @return The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    public Output<Optional<List<WirelessSsidsRadiusServer>>> radiusServers() {
        return Codegen.optional(this.radiusServers);
    }
    /**
     * The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    @Export(name="radiusServersResponses", refs={List.class,WirelessSsidsRadiusServersResponse.class}, tree="[0,1]")
    private Output<List<WirelessSsidsRadiusServersResponse>> radiusServersResponses;

    /**
     * @return The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    public Output<List<WirelessSsidsRadiusServersResponse>> radiusServersResponses() {
        return this.radiusServersResponses;
    }
    /**
     * If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
     * 
     */
    @Export(name="radiusTestingEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusTestingEnabled;

    /**
     * @return If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
     * 
     */
    public Output<Optional<Boolean>> radiusTestingEnabled() {
        return Codegen.optional(this.radiusTestingEnabled);
    }
    /**
     * The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
     * 
     */
    @Export(name="secondaryConcentratorNetworkId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> secondaryConcentratorNetworkId;

    /**
     * @return The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
     * 
     */
    public Output<Optional<String>> secondaryConcentratorNetworkId() {
        return Codegen.optional(this.secondaryConcentratorNetworkId);
    }
    /**
     * The SpeedBurst setting for this SSID&#39;
     * 
     */
    @Export(name="speedBurst", refs={WirelessSsidsSpeedBurst.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsSpeedBurst> speedBurst;

    /**
     * @return The SpeedBurst setting for this SSID&#39;
     * 
     */
    public Output<Optional<WirelessSsidsSpeedBurst>> speedBurst() {
        return Codegen.optional(this.speedBurst);
    }
    /**
     * Array of valid sponsor email domains for sponsored guest splash type.
     * 
     */
    @Export(name="splashGuestSponsorDomains", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> splashGuestSponsorDomains;

    /**
     * @return Array of valid sponsor email domains for sponsored guest splash type.
     * 
     */
    public Output<Optional<List<String>>> splashGuestSponsorDomains() {
        return Codegen.optional(this.splashGuestSponsorDomains);
    }
    /**
     * The type of splash page for the SSID
     * 
     */
    @Export(name="splashPage", refs={String.class}, tree="[0]")
    private Output<String> splashPage;

    /**
     * @return The type of splash page for the SSID
     * 
     */
    public Output<String> splashPage() {
        return this.splashPage;
    }
    /**
     * Splash page timeout
     * 
     */
    @Export(name="splashTimeout", refs={String.class}, tree="[0]")
    private Output<String> splashTimeout;

    /**
     * @return Splash page timeout
     * 
     */
    public Output<String> splashTimeout() {
        return this.splashTimeout;
    }
    /**
     * SSID Administrator access status
     * 
     */
    @Export(name="ssidAdminAccessible", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> ssidAdminAccessible;

    /**
     * @return SSID Administrator access status
     * 
     */
    public Output<Boolean> ssidAdminAccessible() {
        return this.ssidAdminAccessible;
    }
    /**
     * Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Export(name="useVlanTagging", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> useVlanTagging;

    /**
     * @return Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Output<Optional<Boolean>> useVlanTagging() {
        return Codegen.optional(this.useVlanTagging);
    }
    /**
     * Whether the SSID is advertised or hidden by the AP
     * 
     */
    @Export(name="visible", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> visible;

    /**
     * @return Whether the SSID is advertised or hidden by the AP
     * 
     */
    public Output<Boolean> visible() {
        return this.visible;
    }
    /**
     * The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
     * 
     */
    @Export(name="vlanId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> vlanId;

    /**
     * @return The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
     * 
     */
    public Output<Optional<Integer>> vlanId() {
        return Codegen.optional(this.vlanId);
    }
    /**
     * Allow users to access a configurable list of IP ranges prior to sign-on
     * 
     */
    @Export(name="walledGardenEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> walledGardenEnabled;

    /**
     * @return Allow users to access a configurable list of IP ranges prior to sign-on
     * 
     */
    public Output<Optional<Boolean>> walledGardenEnabled() {
        return Codegen.optional(this.walledGardenEnabled);
    }
    /**
     * Domain names and IP address ranges available in Walled Garden mode
     * 
     */
    @Export(name="walledGardenRanges", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> walledGardenRanges;

    /**
     * @return Domain names and IP address ranges available in Walled Garden mode
     * 
     */
    public Output<Optional<List<String>>> walledGardenRanges() {
        return Codegen.optional(this.walledGardenRanges);
    }
    /**
     * The types of WPA encryption
     * 
     */
    @Export(name="wpaEncryptionMode", refs={String.class}, tree="[0]")
    private Output<String> wpaEncryptionMode;

    /**
     * @return The types of WPA encryption
     * 
     */
    public Output<String> wpaEncryptionMode() {
        return this.wpaEncryptionMode;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public WirelessSsids(String name) {
        this(name, WirelessSsidsArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public WirelessSsids(String name, WirelessSsidsArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public WirelessSsids(String name, WirelessSsidsArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("meraki:networks/wirelessSsids:WirelessSsids", name, args == null ? WirelessSsidsArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private WirelessSsids(String name, Output<String> id, @Nullable WirelessSsidsState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("meraki:networks/wirelessSsids:WirelessSsids", name, state, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static WirelessSsids get(String name, Output<String> id, @Nullable WirelessSsidsState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new WirelessSsids(name, id, state, options);
    }
}
