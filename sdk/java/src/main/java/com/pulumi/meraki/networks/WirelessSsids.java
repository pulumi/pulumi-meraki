// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.meraki.networks;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.meraki.Utilities;
import com.pulumi.meraki.networks.WirelessSsidsArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsState;
import com.pulumi.meraki.networks.outputs.WirelessSsidsActiveDirectory;
import com.pulumi.meraki.networks.outputs.WirelessSsidsApTagsAndVlanId;
import com.pulumi.meraki.networks.outputs.WirelessSsidsDnsRewrite;
import com.pulumi.meraki.networks.outputs.WirelessSsidsDot11r;
import com.pulumi.meraki.networks.outputs.WirelessSsidsDot11w;
import com.pulumi.meraki.networks.outputs.WirelessSsidsGre;
import com.pulumi.meraki.networks.outputs.WirelessSsidsLdap;
import com.pulumi.meraki.networks.outputs.WirelessSsidsLocalRadius;
import com.pulumi.meraki.networks.outputs.WirelessSsidsNamedVlans;
import com.pulumi.meraki.networks.outputs.WirelessSsidsOauth;
import com.pulumi.meraki.networks.outputs.WirelessSsidsRadiusAccountingServer;
import com.pulumi.meraki.networks.outputs.WirelessSsidsRadiusAccountingServersResponse;
import com.pulumi.meraki.networks.outputs.WirelessSsidsRadiusServer;
import com.pulumi.meraki.networks.outputs.WirelessSsidsRadiusServersResponse;
import com.pulumi.meraki.networks.outputs.WirelessSsidsSpeedBurst;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * ## Example Usage
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * ```sh
 * $ pulumi import meraki:networks/wirelessSsids:WirelessSsids example &#34;network_id,number&#34;
 * ```
 * 
 */
@ResourceType(type="meraki:networks/wirelessSsids:WirelessSsids")
public class WirelessSsids extends com.pulumi.resources.CustomResource {
    /**
     * The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
     * 
     */
    @Export(name="activeDirectory", refs={WirelessSsidsActiveDirectory.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsActiveDirectory> activeDirectory;

    /**
     * @return The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
     * 
     */
    public Output<Optional<WirelessSsidsActiveDirectory>> activeDirectory() {
        return Codegen.optional(this.activeDirectory);
    }
    @Export(name="adminSplashUrl", refs={String.class}, tree="[0]")
    private Output<String> adminSplashUrl;

    public Output<String> adminSplashUrl() {
        return this.adminSplashUrl;
    }
    /**
     * Boolean indicating whether or not adult content will be blocked
     * 
     */
    @Export(name="adultContentFilteringEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> adultContentFilteringEnabled;

    /**
     * @return Boolean indicating whether or not adult content will be blocked
     * 
     */
    public Output<Optional<Boolean>> adultContentFilteringEnabled() {
        return Codegen.optional(this.adultContentFilteringEnabled);
    }
    /**
     * The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Export(name="apTagsAndVlanIds", refs={List.class,WirelessSsidsApTagsAndVlanId.class}, tree="[0,1]")
    private Output</* @Nullable */ List<WirelessSsidsApTagsAndVlanId>> apTagsAndVlanIds;

    /**
     * @return The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Output<Optional<List<WirelessSsidsApTagsAndVlanId>>> apTagsAndVlanIds() {
        return Codegen.optional(this.apTagsAndVlanIds);
    }
    /**
     * The association control method for the SSID
     * 
     */
    @Export(name="authMode", refs={String.class}, tree="[0]")
    private Output<String> authMode;

    /**
     * @return The association control method for the SSID
     * 
     */
    public Output<String> authMode() {
        return this.authMode;
    }
    /**
     * List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
     * 
     */
    @Export(name="availabilityTags", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> availabilityTags;

    /**
     * @return List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
     * 
     */
    public Output<Optional<List<String>>> availabilityTags() {
        return Codegen.optional(this.availabilityTags);
    }
    /**
     * Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
     * 
     */
    @Export(name="availableOnAllAps", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> availableOnAllAps;

    /**
     * @return Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
     * 
     */
    public Output<Boolean> availableOnAllAps() {
        return this.availableOnAllAps;
    }
    /**
     * The client-serving radio frequencies of this SSID in the default indoor RF profile
     * 
     */
    @Export(name="bandSelection", refs={String.class}, tree="[0]")
    private Output<String> bandSelection;

    /**
     * @return The client-serving radio frequencies of this SSID in the default indoor RF profile
     * 
     */
    public Output<String> bandSelection() {
        return this.bandSelection;
    }
    /**
     * The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
     * 
     */
    @Export(name="concentratorNetworkId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> concentratorNetworkId;

    /**
     * @return The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
     * 
     */
    public Output<Optional<String>> concentratorNetworkId() {
        return Codegen.optional(this.concentratorNetworkId);
    }
    /**
     * The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Export(name="defaultVlanId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> defaultVlanId;

    /**
     * @return The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Output<Optional<Integer>> defaultVlanId() {
        return Codegen.optional(this.defaultVlanId);
    }
    /**
     * Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
     * 
     */
    @Export(name="disassociateClientsOnVpnFailover", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> disassociateClientsOnVpnFailover;

    /**
     * @return Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
     * 
     */
    public Output<Optional<Boolean>> disassociateClientsOnVpnFailover() {
        return Codegen.optional(this.disassociateClientsOnVpnFailover);
    }
    /**
     * DNS servers rewrite settings
     * 
     */
    @Export(name="dnsRewrite", refs={WirelessSsidsDnsRewrite.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsDnsRewrite> dnsRewrite;

    /**
     * @return DNS servers rewrite settings
     * 
     */
    public Output<Optional<WirelessSsidsDnsRewrite>> dnsRewrite() {
        return Codegen.optional(this.dnsRewrite);
    }
    /**
     * The current setting for 802.11r
     * 
     */
    @Export(name="dot11r", refs={WirelessSsidsDot11r.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsDot11r> dot11r;

    /**
     * @return The current setting for 802.11r
     * 
     */
    public Output<Optional<WirelessSsidsDot11r>> dot11r() {
        return Codegen.optional(this.dot11r);
    }
    /**
     * The current setting for Protected Management Frames (802.11w).
     * 
     */
    @Export(name="dot11w", refs={WirelessSsidsDot11w.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsDot11w> dot11w;

    /**
     * @return The current setting for Protected Management Frames (802.11w).
     * 
     */
    public Output<Optional<WirelessSsidsDot11w>> dot11w() {
        return Codegen.optional(this.dot11w);
    }
    /**
     * Whether or not the SSID is enabled
     * 
     */
    @Export(name="enabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> enabled;

    /**
     * @return Whether or not the SSID is enabled
     * 
     */
    public Output<Boolean> enabled() {
        return this.enabled;
    }
    /**
     * The psk encryption mode for the SSID
     * 
     */
    @Export(name="encryptionMode", refs={String.class}, tree="[0]")
    private Output<String> encryptionMode;

    /**
     * @return The psk encryption mode for the SSID
     * 
     */
    public Output<String> encryptionMode() {
        return this.encryptionMode;
    }
    /**
     * Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
     * 
     */
    @Export(name="enterpriseAdminAccess", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> enterpriseAdminAccess;

    /**
     * @return Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
     * 
     */
    public Output<Optional<String>> enterpriseAdminAccess() {
        return Codegen.optional(this.enterpriseAdminAccess);
    }
    /**
     * Ethernet over GRE settings
     * 
     */
    @Export(name="gre", refs={WirelessSsidsGre.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsGre> gre;

    /**
     * @return Ethernet over GRE settings
     * 
     */
    public Output<Optional<WirelessSsidsGre>> gre() {
        return Codegen.optional(this.gre);
    }
    /**
     * The client IP assignment mode
     * 
     */
    @Export(name="ipAssignmentMode", refs={String.class}, tree="[0]")
    private Output<String> ipAssignmentMode;

    /**
     * @return The client IP assignment mode
     * 
     */
    public Output<String> ipAssignmentMode() {
        return this.ipAssignmentMode;
    }
    /**
     * Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
     * 
     */
    @Export(name="lanIsolationEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> lanIsolationEnabled;

    /**
     * @return Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
     * 
     */
    public Output<Optional<Boolean>> lanIsolationEnabled() {
        return Codegen.optional(this.lanIsolationEnabled);
    }
    /**
     * The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
     * 
     */
    @Export(name="ldap", refs={WirelessSsidsLdap.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsLdap> ldap;

    /**
     * @return The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
     * 
     */
    public Output<Optional<WirelessSsidsLdap>> ldap() {
        return Codegen.optional(this.ldap);
    }
    /**
     * The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
     * 
     */
    @Export(name="localRadius", refs={WirelessSsidsLocalRadius.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsLocalRadius> localRadius;

    /**
     * @return The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
     * 
     */
    public Output<Optional<WirelessSsidsLocalRadius>> localRadius() {
        return Codegen.optional(this.localRadius);
    }
    /**
     * Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
     * 
     */
    @Export(name="mandatoryDhcpEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> mandatoryDhcpEnabled;

    /**
     * @return Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
     * 
     */
    public Output<Boolean> mandatoryDhcpEnabled() {
        return this.mandatoryDhcpEnabled;
    }
    /**
     * The minimum bitrate in Mbps of this SSID in the default indoor RF profile
     * 
     */
    @Export(name="minBitrate", refs={Integer.class}, tree="[0]")
    private Output<Integer> minBitrate;

    /**
     * @return The minimum bitrate in Mbps of this SSID in the default indoor RF profile
     * 
     */
    public Output<Integer> minBitrate() {
        return this.minBitrate;
    }
    /**
     * The name of the SSID
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the SSID
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * Named VLAN settings.
     * 
     */
    @Export(name="namedVlans", refs={WirelessSsidsNamedVlans.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsNamedVlans> namedVlans;

    /**
     * @return Named VLAN settings.
     * 
     */
    public Output<Optional<WirelessSsidsNamedVlans>> namedVlans() {
        return Codegen.optional(this.namedVlans);
    }
    /**
     * networkId path parameter. Network ID
     * 
     */
    @Export(name="networkId", refs={String.class}, tree="[0]")
    private Output<String> networkId;

    /**
     * @return networkId path parameter. Network ID
     * 
     */
    public Output<String> networkId() {
        return this.networkId;
    }
    /**
     * Unique identifier of the SSID
     * 
     */
    @Export(name="number", refs={Integer.class}, tree="[0]")
    private Output<Integer> number;

    /**
     * @return Unique identifier of the SSID
     * 
     */
    public Output<Integer> number() {
        return this.number;
    }
    /**
     * The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
     * 
     */
    @Export(name="oauth", refs={WirelessSsidsOauth.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsOauth> oauth;

    /**
     * @return The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
     * 
     */
    public Output<Optional<WirelessSsidsOauth>> oauth() {
        return Codegen.optional(this.oauth);
    }
    /**
     * The download bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    @Export(name="perClientBandwidthLimitDown", refs={Integer.class}, tree="[0]")
    private Output<Integer> perClientBandwidthLimitDown;

    /**
     * @return The download bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    public Output<Integer> perClientBandwidthLimitDown() {
        return this.perClientBandwidthLimitDown;
    }
    /**
     * The upload bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    @Export(name="perClientBandwidthLimitUp", refs={Integer.class}, tree="[0]")
    private Output<Integer> perClientBandwidthLimitUp;

    /**
     * @return The upload bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    public Output<Integer> perClientBandwidthLimitUp() {
        return this.perClientBandwidthLimitUp;
    }
    /**
     * The total download bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    @Export(name="perSsidBandwidthLimitDown", refs={Integer.class}, tree="[0]")
    private Output<Integer> perSsidBandwidthLimitDown;

    /**
     * @return The total download bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    public Output<Integer> perSsidBandwidthLimitDown() {
        return this.perSsidBandwidthLimitDown;
    }
    /**
     * The total upload bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    @Export(name="perSsidBandwidthLimitUp", refs={Integer.class}, tree="[0]")
    private Output<Integer> perSsidBandwidthLimitUp;

    /**
     * @return The total upload bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    public Output<Integer> perSsidBandwidthLimitUp() {
        return this.perSsidBandwidthLimitUp;
    }
    /**
     * The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
     * 
     */
    @Export(name="psk", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> psk;

    /**
     * @return The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
     * 
     */
    public Output<Optional<String>> psk() {
        return Codegen.optional(this.psk);
    }
    /**
     * Whether or not RADIUS accounting is enabled
     * 
     */
    @Export(name="radiusAccountingEnabled", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> radiusAccountingEnabled;

    /**
     * @return Whether or not RADIUS accounting is enabled
     * 
     */
    public Output<Boolean> radiusAccountingEnabled() {
        return this.radiusAccountingEnabled;
    }
    /**
     * The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     * 
     */
    @Export(name="radiusAccountingInterimInterval", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusAccountingInterimInterval;

    /**
     * @return The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     * 
     */
    public Output<Optional<Integer>> radiusAccountingInterimInterval() {
        return Codegen.optional(this.radiusAccountingInterimInterval);
    }
    /**
     * List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    @Export(name="radiusAccountingServers", refs={List.class,WirelessSsidsRadiusAccountingServer.class}, tree="[0,1]")
    private Output</* @Nullable */ List<WirelessSsidsRadiusAccountingServer>> radiusAccountingServers;

    /**
     * @return List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    public Output<Optional<List<WirelessSsidsRadiusAccountingServer>>> radiusAccountingServers() {
        return Codegen.optional(this.radiusAccountingServers);
    }
    /**
     * List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    @Export(name="radiusAccountingServersResponses", refs={List.class,WirelessSsidsRadiusAccountingServersResponse.class}, tree="[0,1]")
    private Output<List<WirelessSsidsRadiusAccountingServersResponse>> radiusAccountingServersResponses;

    /**
     * @return List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    public Output<List<WirelessSsidsRadiusAccountingServersResponse>> radiusAccountingServersResponses() {
        return this.radiusAccountingServersResponses;
    }
    /**
     * RADIUS attribute used to look up group policies
     * 
     */
    @Export(name="radiusAttributeForGroupPolicies", refs={String.class}, tree="[0]")
    private Output<String> radiusAttributeForGroupPolicies;

    /**
     * @return RADIUS attribute used to look up group policies
     * 
     */
    public Output<String> radiusAttributeForGroupPolicies() {
        return this.radiusAttributeForGroupPolicies;
    }
    /**
     * The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    @Export(name="radiusAuthenticationNasId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> radiusAuthenticationNasId;

    /**
     * @return The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    public Output<Optional<String>> radiusAuthenticationNasId() {
        return Codegen.optional(this.radiusAuthenticationNasId);
    }
    /**
     * The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    @Export(name="radiusCalledStationId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> radiusCalledStationId;

    /**
     * @return The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    public Output<Optional<String>> radiusCalledStationId() {
        return Codegen.optional(this.radiusCalledStationId);
    }
    /**
     * If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     * 
     */
    @Export(name="radiusCoaEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusCoaEnabled;

    /**
     * @return If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     * 
     */
    public Output<Optional<Boolean>> radiusCoaEnabled() {
        return Codegen.optional(this.radiusCoaEnabled);
    }
    /**
     * Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
     * 
     */
    @Export(name="radiusFailoverPolicy", refs={String.class}, tree="[0]")
    private Output<String> radiusFailoverPolicy;

    /**
     * @return Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
     * 
     */
    public Output<String> radiusFailoverPolicy() {
        return this.radiusFailoverPolicy;
    }
    /**
     * Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     * 
     */
    @Export(name="radiusFallbackEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusFallbackEnabled;

    /**
     * @return Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     * 
     */
    public Output<Optional<Boolean>> radiusFallbackEnabled() {
        return Codegen.optional(this.radiusFallbackEnabled);
    }
    /**
     * Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    @Export(name="radiusGuestVlanEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusGuestVlanEnabled;

    /**
     * @return Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    public Output<Optional<Boolean>> radiusGuestVlanEnabled() {
        return Codegen.optional(this.radiusGuestVlanEnabled);
    }
    /**
     * VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    @Export(name="radiusGuestVlanId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusGuestVlanId;

    /**
     * @return VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    public Output<Optional<Integer>> radiusGuestVlanId() {
        return Codegen.optional(this.radiusGuestVlanId);
    }
    /**
     * Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
     * 
     */
    @Export(name="radiusLoadBalancingPolicy", refs={String.class}, tree="[0]")
    private Output<String> radiusLoadBalancingPolicy;

    /**
     * @return Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
     * 
     */
    public Output<String> radiusLoadBalancingPolicy() {
        return this.radiusLoadBalancingPolicy;
    }
    /**
     * If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
     * 
     */
    @Export(name="radiusOverride", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusOverride;

    /**
     * @return If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
     * 
     */
    public Output<Optional<Boolean>> radiusOverride() {
        return Codegen.optional(this.radiusOverride);
    }
    /**
     * If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     * 
     */
    @Export(name="radiusProxyEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusProxyEnabled;

    /**
     * @return If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     * 
     */
    public Output<Optional<Boolean>> radiusProxyEnabled() {
        return Codegen.optional(this.radiusProxyEnabled);
    }
    /**
     * The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     * 
     */
    @Export(name="radiusServerAttemptsLimit", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusServerAttemptsLimit;

    /**
     * @return The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     * 
     */
    public Output<Optional<Integer>> radiusServerAttemptsLimit() {
        return Codegen.optional(this.radiusServerAttemptsLimit);
    }
    /**
     * The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     * 
     */
    @Export(name="radiusServerTimeout", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> radiusServerTimeout;

    /**
     * @return The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     * 
     */
    public Output<Optional<Integer>> radiusServerTimeout() {
        return Codegen.optional(this.radiusServerTimeout);
    }
    /**
     * The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    @Export(name="radiusServers", refs={List.class,WirelessSsidsRadiusServer.class}, tree="[0,1]")
    private Output</* @Nullable */ List<WirelessSsidsRadiusServer>> radiusServers;

    /**
     * @return The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    public Output<Optional<List<WirelessSsidsRadiusServer>>> radiusServers() {
        return Codegen.optional(this.radiusServers);
    }
    /**
     * The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    @Export(name="radiusServersResponses", refs={List.class,WirelessSsidsRadiusServersResponse.class}, tree="[0,1]")
    private Output<List<WirelessSsidsRadiusServersResponse>> radiusServersResponses;

    /**
     * @return The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    public Output<List<WirelessSsidsRadiusServersResponse>> radiusServersResponses() {
        return this.radiusServersResponses;
    }
    /**
     * If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
     * 
     */
    @Export(name="radiusTestingEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> radiusTestingEnabled;

    /**
     * @return If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
     * 
     */
    public Output<Optional<Boolean>> radiusTestingEnabled() {
        return Codegen.optional(this.radiusTestingEnabled);
    }
    /**
     * The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
     * 
     */
    @Export(name="secondaryConcentratorNetworkId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> secondaryConcentratorNetworkId;

    /**
     * @return The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
     * 
     */
    public Output<Optional<String>> secondaryConcentratorNetworkId() {
        return Codegen.optional(this.secondaryConcentratorNetworkId);
    }
    /**
     * The SpeedBurst setting for this SSID&#39;
     * 
     */
    @Export(name="speedBurst", refs={WirelessSsidsSpeedBurst.class}, tree="[0]")
    private Output</* @Nullable */ WirelessSsidsSpeedBurst> speedBurst;

    /**
     * @return The SpeedBurst setting for this SSID&#39;
     * 
     */
    public Output<Optional<WirelessSsidsSpeedBurst>> speedBurst() {
        return Codegen.optional(this.speedBurst);
    }
    /**
     * Array of valid sponsor email domains for sponsored guest splash type.
     * 
     */
    @Export(name="splashGuestSponsorDomains", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> splashGuestSponsorDomains;

    /**
     * @return Array of valid sponsor email domains for sponsored guest splash type.
     * 
     */
    public Output<Optional<List<String>>> splashGuestSponsorDomains() {
        return Codegen.optional(this.splashGuestSponsorDomains);
    }
    /**
     * The type of splash page for the SSID
     * 
     */
    @Export(name="splashPage", refs={String.class}, tree="[0]")
    private Output<String> splashPage;

    /**
     * @return The type of splash page for the SSID
     * 
     */
    public Output<String> splashPage() {
        return this.splashPage;
    }
    /**
     * Splash page timeout
     * 
     */
    @Export(name="splashTimeout", refs={String.class}, tree="[0]")
    private Output<String> splashTimeout;

    /**
     * @return Splash page timeout
     * 
     */
    public Output<String> splashTimeout() {
        return this.splashTimeout;
    }
    /**
     * SSID Administrator access status
     * 
     */
    @Export(name="ssidAdminAccessible", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> ssidAdminAccessible;

    /**
     * @return SSID Administrator access status
     * 
     */
    public Output<Boolean> ssidAdminAccessible() {
        return this.ssidAdminAccessible;
    }
    /**
     * Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Export(name="useVlanTagging", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> useVlanTagging;

    /**
     * @return Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Output<Optional<Boolean>> useVlanTagging() {
        return Codegen.optional(this.useVlanTagging);
    }
    /**
     * Whether the SSID is advertised or hidden by the AP
     * 
     */
    @Export(name="visible", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> visible;

    /**
     * @return Whether the SSID is advertised or hidden by the AP
     * 
     */
    public Output<Boolean> visible() {
        return this.visible;
    }
    /**
     * The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
     * 
     */
    @Export(name="vlanId", refs={Integer.class}, tree="[0]")
    private Output</* @Nullable */ Integer> vlanId;

    /**
     * @return The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
     * 
     */
    public Output<Optional<Integer>> vlanId() {
        return Codegen.optional(this.vlanId);
    }
    /**
     * Allow users to access a configurable list of IP ranges prior to sign-on
     * 
     */
    @Export(name="walledGardenEnabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> walledGardenEnabled;

    /**
     * @return Allow users to access a configurable list of IP ranges prior to sign-on
     * 
     */
    public Output<Optional<Boolean>> walledGardenEnabled() {
        return Codegen.optional(this.walledGardenEnabled);
    }
    /**
     * Domain names and IP address ranges available in Walled Garden mode
     * 
     */
    @Export(name="walledGardenRanges", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> walledGardenRanges;

    /**
     * @return Domain names and IP address ranges available in Walled Garden mode
     * 
     */
    public Output<Optional<List<String>>> walledGardenRanges() {
        return Codegen.optional(this.walledGardenRanges);
    }
    /**
     * The types of WPA encryption
     * 
     */
    @Export(name="wpaEncryptionMode", refs={String.class}, tree="[0]")
    private Output<String> wpaEncryptionMode;

    /**
     * @return The types of WPA encryption
     * 
     */
    public Output<String> wpaEncryptionMode() {
        return this.wpaEncryptionMode;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public WirelessSsids(java.lang.String name) {
        this(name, WirelessSsidsArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public WirelessSsids(java.lang.String name, WirelessSsidsArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public WirelessSsids(java.lang.String name, WirelessSsidsArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("meraki:networks/wirelessSsids:WirelessSsids", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private WirelessSsids(java.lang.String name, Output<java.lang.String> id, @Nullable WirelessSsidsState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("meraki:networks/wirelessSsids:WirelessSsids", name, state, makeResourceOptions(options, id), false);
    }

    private static WirelessSsidsArgs makeArgs(WirelessSsidsArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? WirelessSsidsArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .pluginDownloadURL("github://api.github.com/pulumi/pulumi-meraki")
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static WirelessSsids get(java.lang.String name, Output<java.lang.String> id, @Nullable WirelessSsidsState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new WirelessSsids(name, id, state, options);
    }
}
