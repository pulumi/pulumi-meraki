// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.meraki.networks;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.meraki.networks.inputs.WirelessSsidsActiveDirectoryArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsApTagsAndVlanIdArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsDnsRewriteArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsDot11rArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsDot11wArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsGreArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsLdapArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsLocalRadiusArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsNamedVlansArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsOauthArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsRadiusAccountingServerArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsRadiusServerArgs;
import com.pulumi.meraki.networks.inputs.WirelessSsidsSpeedBurstArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class WirelessSsidsArgs extends com.pulumi.resources.ResourceArgs {

    public static final WirelessSsidsArgs Empty = new WirelessSsidsArgs();

    /**
     * The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
     * 
     */
    @Import(name="activeDirectory")
    private @Nullable Output<WirelessSsidsActiveDirectoryArgs> activeDirectory;

    /**
     * @return The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
     * 
     */
    public Optional<Output<WirelessSsidsActiveDirectoryArgs>> activeDirectory() {
        return Optional.ofNullable(this.activeDirectory);
    }

    /**
     * Boolean indicating whether or not adult content will be blocked
     * 
     */
    @Import(name="adultContentFilteringEnabled")
    private @Nullable Output<Boolean> adultContentFilteringEnabled;

    /**
     * @return Boolean indicating whether or not adult content will be blocked
     * 
     */
    public Optional<Output<Boolean>> adultContentFilteringEnabled() {
        return Optional.ofNullable(this.adultContentFilteringEnabled);
    }

    /**
     * The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Import(name="apTagsAndVlanIds")
    private @Nullable Output<List<WirelessSsidsApTagsAndVlanIdArgs>> apTagsAndVlanIds;

    /**
     * @return The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Optional<Output<List<WirelessSsidsApTagsAndVlanIdArgs>>> apTagsAndVlanIds() {
        return Optional.ofNullable(this.apTagsAndVlanIds);
    }

    /**
     * The association control method for the SSID
     * 
     */
    @Import(name="authMode")
    private @Nullable Output<String> authMode;

    /**
     * @return The association control method for the SSID
     * 
     */
    public Optional<Output<String>> authMode() {
        return Optional.ofNullable(this.authMode);
    }

    /**
     * List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
     * 
     */
    @Import(name="availabilityTags")
    private @Nullable Output<List<String>> availabilityTags;

    /**
     * @return List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
     * 
     */
    public Optional<Output<List<String>>> availabilityTags() {
        return Optional.ofNullable(this.availabilityTags);
    }

    /**
     * Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
     * 
     */
    @Import(name="availableOnAllAps")
    private @Nullable Output<Boolean> availableOnAllAps;

    /**
     * @return Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
     * 
     */
    public Optional<Output<Boolean>> availableOnAllAps() {
        return Optional.ofNullable(this.availableOnAllAps);
    }

    /**
     * The client-serving radio frequencies of this SSID in the default indoor RF profile
     * 
     */
    @Import(name="bandSelection")
    private @Nullable Output<String> bandSelection;

    /**
     * @return The client-serving radio frequencies of this SSID in the default indoor RF profile
     * 
     */
    public Optional<Output<String>> bandSelection() {
        return Optional.ofNullable(this.bandSelection);
    }

    /**
     * The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
     * 
     */
    @Import(name="concentratorNetworkId")
    private @Nullable Output<String> concentratorNetworkId;

    /**
     * @return The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
     * 
     */
    public Optional<Output<String>> concentratorNetworkId() {
        return Optional.ofNullable(this.concentratorNetworkId);
    }

    /**
     * The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Import(name="defaultVlanId")
    private @Nullable Output<Integer> defaultVlanId;

    /**
     * @return The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Optional<Output<Integer>> defaultVlanId() {
        return Optional.ofNullable(this.defaultVlanId);
    }

    /**
     * Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
     * 
     */
    @Import(name="disassociateClientsOnVpnFailover")
    private @Nullable Output<Boolean> disassociateClientsOnVpnFailover;

    /**
     * @return Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
     * 
     */
    public Optional<Output<Boolean>> disassociateClientsOnVpnFailover() {
        return Optional.ofNullable(this.disassociateClientsOnVpnFailover);
    }

    /**
     * DNS servers rewrite settings
     * 
     */
    @Import(name="dnsRewrite")
    private @Nullable Output<WirelessSsidsDnsRewriteArgs> dnsRewrite;

    /**
     * @return DNS servers rewrite settings
     * 
     */
    public Optional<Output<WirelessSsidsDnsRewriteArgs>> dnsRewrite() {
        return Optional.ofNullable(this.dnsRewrite);
    }

    /**
     * The current setting for 802.11r
     * 
     */
    @Import(name="dot11r")
    private @Nullable Output<WirelessSsidsDot11rArgs> dot11r;

    /**
     * @return The current setting for 802.11r
     * 
     */
    public Optional<Output<WirelessSsidsDot11rArgs>> dot11r() {
        return Optional.ofNullable(this.dot11r);
    }

    /**
     * The current setting for Protected Management Frames (802.11w).
     * 
     */
    @Import(name="dot11w")
    private @Nullable Output<WirelessSsidsDot11wArgs> dot11w;

    /**
     * @return The current setting for Protected Management Frames (802.11w).
     * 
     */
    public Optional<Output<WirelessSsidsDot11wArgs>> dot11w() {
        return Optional.ofNullable(this.dot11w);
    }

    /**
     * Whether or not the SSID is enabled
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Whether or not the SSID is enabled
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * The psk encryption mode for the SSID
     * 
     */
    @Import(name="encryptionMode")
    private @Nullable Output<String> encryptionMode;

    /**
     * @return The psk encryption mode for the SSID
     * 
     */
    public Optional<Output<String>> encryptionMode() {
        return Optional.ofNullable(this.encryptionMode);
    }

    /**
     * Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
     * 
     */
    @Import(name="enterpriseAdminAccess")
    private @Nullable Output<String> enterpriseAdminAccess;

    /**
     * @return Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
     * 
     */
    public Optional<Output<String>> enterpriseAdminAccess() {
        return Optional.ofNullable(this.enterpriseAdminAccess);
    }

    /**
     * Ethernet over GRE settings
     * 
     */
    @Import(name="gre")
    private @Nullable Output<WirelessSsidsGreArgs> gre;

    /**
     * @return Ethernet over GRE settings
     * 
     */
    public Optional<Output<WirelessSsidsGreArgs>> gre() {
        return Optional.ofNullable(this.gre);
    }

    /**
     * The client IP assignment mode
     * 
     */
    @Import(name="ipAssignmentMode")
    private @Nullable Output<String> ipAssignmentMode;

    /**
     * @return The client IP assignment mode
     * 
     */
    public Optional<Output<String>> ipAssignmentMode() {
        return Optional.ofNullable(this.ipAssignmentMode);
    }

    /**
     * Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
     * 
     */
    @Import(name="lanIsolationEnabled")
    private @Nullable Output<Boolean> lanIsolationEnabled;

    /**
     * @return Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
     * 
     */
    public Optional<Output<Boolean>> lanIsolationEnabled() {
        return Optional.ofNullable(this.lanIsolationEnabled);
    }

    /**
     * The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
     * 
     */
    @Import(name="ldap")
    private @Nullable Output<WirelessSsidsLdapArgs> ldap;

    /**
     * @return The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
     * 
     */
    public Optional<Output<WirelessSsidsLdapArgs>> ldap() {
        return Optional.ofNullable(this.ldap);
    }

    /**
     * The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
     * 
     */
    @Import(name="localRadius")
    private @Nullable Output<WirelessSsidsLocalRadiusArgs> localRadius;

    /**
     * @return The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
     * 
     */
    public Optional<Output<WirelessSsidsLocalRadiusArgs>> localRadius() {
        return Optional.ofNullable(this.localRadius);
    }

    /**
     * Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
     * 
     */
    @Import(name="mandatoryDhcpEnabled")
    private @Nullable Output<Boolean> mandatoryDhcpEnabled;

    /**
     * @return Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
     * 
     */
    public Optional<Output<Boolean>> mandatoryDhcpEnabled() {
        return Optional.ofNullable(this.mandatoryDhcpEnabled);
    }

    /**
     * The minimum bitrate in Mbps of this SSID in the default indoor RF profile
     * 
     */
    @Import(name="minBitrate")
    private @Nullable Output<Integer> minBitrate;

    /**
     * @return The minimum bitrate in Mbps of this SSID in the default indoor RF profile
     * 
     */
    public Optional<Output<Integer>> minBitrate() {
        return Optional.ofNullable(this.minBitrate);
    }

    /**
     * The name of the SSID
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the SSID
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Named VLAN settings.
     * 
     */
    @Import(name="namedVlans")
    private @Nullable Output<WirelessSsidsNamedVlansArgs> namedVlans;

    /**
     * @return Named VLAN settings.
     * 
     */
    public Optional<Output<WirelessSsidsNamedVlansArgs>> namedVlans() {
        return Optional.ofNullable(this.namedVlans);
    }

    /**
     * networkId path parameter. Network ID
     * 
     */
    @Import(name="networkId", required=true)
    private Output<String> networkId;

    /**
     * @return networkId path parameter. Network ID
     * 
     */
    public Output<String> networkId() {
        return this.networkId;
    }

    /**
     * Unique identifier of the SSID
     * 
     */
    @Import(name="number", required=true)
    private Output<Integer> number;

    /**
     * @return Unique identifier of the SSID
     * 
     */
    public Output<Integer> number() {
        return this.number;
    }

    /**
     * The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
     * 
     */
    @Import(name="oauth")
    private @Nullable Output<WirelessSsidsOauthArgs> oauth;

    /**
     * @return The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
     * 
     */
    public Optional<Output<WirelessSsidsOauthArgs>> oauth() {
        return Optional.ofNullable(this.oauth);
    }

    /**
     * The download bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    @Import(name="perClientBandwidthLimitDown")
    private @Nullable Output<Integer> perClientBandwidthLimitDown;

    /**
     * @return The download bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    public Optional<Output<Integer>> perClientBandwidthLimitDown() {
        return Optional.ofNullable(this.perClientBandwidthLimitDown);
    }

    /**
     * The upload bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    @Import(name="perClientBandwidthLimitUp")
    private @Nullable Output<Integer> perClientBandwidthLimitUp;

    /**
     * @return The upload bandwidth limit in Kbps. (0 represents no limit.)
     * 
     */
    public Optional<Output<Integer>> perClientBandwidthLimitUp() {
        return Optional.ofNullable(this.perClientBandwidthLimitUp);
    }

    /**
     * The total download bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    @Import(name="perSsidBandwidthLimitDown")
    private @Nullable Output<Integer> perSsidBandwidthLimitDown;

    /**
     * @return The total download bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    public Optional<Output<Integer>> perSsidBandwidthLimitDown() {
        return Optional.ofNullable(this.perSsidBandwidthLimitDown);
    }

    /**
     * The total upload bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    @Import(name="perSsidBandwidthLimitUp")
    private @Nullable Output<Integer> perSsidBandwidthLimitUp;

    /**
     * @return The total upload bandwidth limit in Kbps (0 represents no limit)
     * 
     */
    public Optional<Output<Integer>> perSsidBandwidthLimitUp() {
        return Optional.ofNullable(this.perSsidBandwidthLimitUp);
    }

    /**
     * The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
     * 
     */
    @Import(name="psk")
    private @Nullable Output<String> psk;

    /**
     * @return The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
     * 
     */
    public Optional<Output<String>> psk() {
        return Optional.ofNullable(this.psk);
    }

    /**
     * Whether or not RADIUS accounting is enabled
     * 
     */
    @Import(name="radiusAccountingEnabled")
    private @Nullable Output<Boolean> radiusAccountingEnabled;

    /**
     * @return Whether or not RADIUS accounting is enabled
     * 
     */
    public Optional<Output<Boolean>> radiusAccountingEnabled() {
        return Optional.ofNullable(this.radiusAccountingEnabled);
    }

    /**
     * The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     * 
     */
    @Import(name="radiusAccountingInterimInterval")
    private @Nullable Output<Integer> radiusAccountingInterimInterval;

    /**
     * @return The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     * 
     */
    public Optional<Output<Integer>> radiusAccountingInterimInterval() {
        return Optional.ofNullable(this.radiusAccountingInterimInterval);
    }

    /**
     * List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    @Import(name="radiusAccountingServers")
    private @Nullable Output<List<WirelessSsidsRadiusAccountingServerArgs>> radiusAccountingServers;

    /**
     * @return List of RADIUS accounting 802.1X servers to be used for authentication
     * 
     */
    public Optional<Output<List<WirelessSsidsRadiusAccountingServerArgs>>> radiusAccountingServers() {
        return Optional.ofNullable(this.radiusAccountingServers);
    }

    /**
     * RADIUS attribute used to look up group policies
     * 
     */
    @Import(name="radiusAttributeForGroupPolicies")
    private @Nullable Output<String> radiusAttributeForGroupPolicies;

    /**
     * @return RADIUS attribute used to look up group policies
     * 
     */
    public Optional<Output<String>> radiusAttributeForGroupPolicies() {
        return Optional.ofNullable(this.radiusAttributeForGroupPolicies);
    }

    /**
     * The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    @Import(name="radiusAuthenticationNasId")
    private @Nullable Output<String> radiusAuthenticationNasId;

    /**
     * @return The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    public Optional<Output<String>> radiusAuthenticationNasId() {
        return Optional.ofNullable(this.radiusAuthenticationNasId);
    }

    /**
     * The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    @Import(name="radiusCalledStationId")
    private @Nullable Output<String> radiusCalledStationId;

    /**
     * @return The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
     * 
     */
    public Optional<Output<String>> radiusCalledStationId() {
        return Optional.ofNullable(this.radiusCalledStationId);
    }

    /**
     * If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     * 
     */
    @Import(name="radiusCoaEnabled")
    private @Nullable Output<Boolean> radiusCoaEnabled;

    /**
     * @return If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     * 
     */
    public Optional<Output<Boolean>> radiusCoaEnabled() {
        return Optional.ofNullable(this.radiusCoaEnabled);
    }

    /**
     * Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
     * 
     */
    @Import(name="radiusFailoverPolicy")
    private @Nullable Output<String> radiusFailoverPolicy;

    /**
     * @return Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
     * 
     */
    public Optional<Output<String>> radiusFailoverPolicy() {
        return Optional.ofNullable(this.radiusFailoverPolicy);
    }

    /**
     * Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     * 
     */
    @Import(name="radiusFallbackEnabled")
    private @Nullable Output<Boolean> radiusFallbackEnabled;

    /**
     * @return Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     * 
     */
    public Optional<Output<Boolean>> radiusFallbackEnabled() {
        return Optional.ofNullable(this.radiusFallbackEnabled);
    }

    /**
     * Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    @Import(name="radiusGuestVlanEnabled")
    private @Nullable Output<Boolean> radiusGuestVlanEnabled;

    /**
     * @return Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    public Optional<Output<Boolean>> radiusGuestVlanEnabled() {
        return Optional.ofNullable(this.radiusGuestVlanEnabled);
    }

    /**
     * VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    @Import(name="radiusGuestVlanId")
    private @Nullable Output<Integer> radiusGuestVlanId;

    /**
     * @return VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
     * 
     */
    public Optional<Output<Integer>> radiusGuestVlanId() {
        return Optional.ofNullable(this.radiusGuestVlanId);
    }

    /**
     * Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
     * 
     */
    @Import(name="radiusLoadBalancingPolicy")
    private @Nullable Output<String> radiusLoadBalancingPolicy;

    /**
     * @return Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
     * 
     */
    public Optional<Output<String>> radiusLoadBalancingPolicy() {
        return Optional.ofNullable(this.radiusLoadBalancingPolicy);
    }

    /**
     * If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
     * 
     */
    @Import(name="radiusOverride")
    private @Nullable Output<Boolean> radiusOverride;

    /**
     * @return If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
     * 
     */
    public Optional<Output<Boolean>> radiusOverride() {
        return Optional.ofNullable(this.radiusOverride);
    }

    /**
     * If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     * 
     */
    @Import(name="radiusProxyEnabled")
    private @Nullable Output<Boolean> radiusProxyEnabled;

    /**
     * @return If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     * 
     */
    public Optional<Output<Boolean>> radiusProxyEnabled() {
        return Optional.ofNullable(this.radiusProxyEnabled);
    }

    /**
     * The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     * 
     */
    @Import(name="radiusServerAttemptsLimit")
    private @Nullable Output<Integer> radiusServerAttemptsLimit;

    /**
     * @return The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     * 
     */
    public Optional<Output<Integer>> radiusServerAttemptsLimit() {
        return Optional.ofNullable(this.radiusServerAttemptsLimit);
    }

    /**
     * The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     * 
     */
    @Import(name="radiusServerTimeout")
    private @Nullable Output<Integer> radiusServerTimeout;

    /**
     * @return The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     * 
     */
    public Optional<Output<Integer>> radiusServerTimeout() {
        return Optional.ofNullable(this.radiusServerTimeout);
    }

    /**
     * The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    @Import(name="radiusServers")
    private @Nullable Output<List<WirelessSsidsRadiusServerArgs>> radiusServers;

    /**
     * @return The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
     * 
     */
    public Optional<Output<List<WirelessSsidsRadiusServerArgs>>> radiusServers() {
        return Optional.ofNullable(this.radiusServers);
    }

    /**
     * If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
     * 
     */
    @Import(name="radiusTestingEnabled")
    private @Nullable Output<Boolean> radiusTestingEnabled;

    /**
     * @return If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
     * 
     */
    public Optional<Output<Boolean>> radiusTestingEnabled() {
        return Optional.ofNullable(this.radiusTestingEnabled);
    }

    /**
     * The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
     * 
     */
    @Import(name="secondaryConcentratorNetworkId")
    private @Nullable Output<String> secondaryConcentratorNetworkId;

    /**
     * @return The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
     * 
     */
    public Optional<Output<String>> secondaryConcentratorNetworkId() {
        return Optional.ofNullable(this.secondaryConcentratorNetworkId);
    }

    /**
     * The SpeedBurst setting for this SSID&#39;
     * 
     */
    @Import(name="speedBurst")
    private @Nullable Output<WirelessSsidsSpeedBurstArgs> speedBurst;

    /**
     * @return The SpeedBurst setting for this SSID&#39;
     * 
     */
    public Optional<Output<WirelessSsidsSpeedBurstArgs>> speedBurst() {
        return Optional.ofNullable(this.speedBurst);
    }

    /**
     * Array of valid sponsor email domains for sponsored guest splash type.
     * 
     */
    @Import(name="splashGuestSponsorDomains")
    private @Nullable Output<List<String>> splashGuestSponsorDomains;

    /**
     * @return Array of valid sponsor email domains for sponsored guest splash type.
     * 
     */
    public Optional<Output<List<String>>> splashGuestSponsorDomains() {
        return Optional.ofNullable(this.splashGuestSponsorDomains);
    }

    /**
     * The type of splash page for the SSID
     * 
     */
    @Import(name="splashPage")
    private @Nullable Output<String> splashPage;

    /**
     * @return The type of splash page for the SSID
     * 
     */
    public Optional<Output<String>> splashPage() {
        return Optional.ofNullable(this.splashPage);
    }

    /**
     * Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    @Import(name="useVlanTagging")
    private @Nullable Output<Boolean> useVlanTagging;

    /**
     * @return Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
     * 
     */
    public Optional<Output<Boolean>> useVlanTagging() {
        return Optional.ofNullable(this.useVlanTagging);
    }

    /**
     * Whether the SSID is advertised or hidden by the AP
     * 
     */
    @Import(name="visible")
    private @Nullable Output<Boolean> visible;

    /**
     * @return Whether the SSID is advertised or hidden by the AP
     * 
     */
    public Optional<Output<Boolean>> visible() {
        return Optional.ofNullable(this.visible);
    }

    /**
     * The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
     * 
     */
    @Import(name="vlanId")
    private @Nullable Output<Integer> vlanId;

    /**
     * @return The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
     * 
     */
    public Optional<Output<Integer>> vlanId() {
        return Optional.ofNullable(this.vlanId);
    }

    /**
     * Allow users to access a configurable list of IP ranges prior to sign-on
     * 
     */
    @Import(name="walledGardenEnabled")
    private @Nullable Output<Boolean> walledGardenEnabled;

    /**
     * @return Allow users to access a configurable list of IP ranges prior to sign-on
     * 
     */
    public Optional<Output<Boolean>> walledGardenEnabled() {
        return Optional.ofNullable(this.walledGardenEnabled);
    }

    /**
     * Domain names and IP address ranges available in Walled Garden mode
     * 
     */
    @Import(name="walledGardenRanges")
    private @Nullable Output<List<String>> walledGardenRanges;

    /**
     * @return Domain names and IP address ranges available in Walled Garden mode
     * 
     */
    public Optional<Output<List<String>>> walledGardenRanges() {
        return Optional.ofNullable(this.walledGardenRanges);
    }

    /**
     * The types of WPA encryption
     * 
     */
    @Import(name="wpaEncryptionMode")
    private @Nullable Output<String> wpaEncryptionMode;

    /**
     * @return The types of WPA encryption
     * 
     */
    public Optional<Output<String>> wpaEncryptionMode() {
        return Optional.ofNullable(this.wpaEncryptionMode);
    }

    private WirelessSsidsArgs() {}

    private WirelessSsidsArgs(WirelessSsidsArgs $) {
        this.activeDirectory = $.activeDirectory;
        this.adultContentFilteringEnabled = $.adultContentFilteringEnabled;
        this.apTagsAndVlanIds = $.apTagsAndVlanIds;
        this.authMode = $.authMode;
        this.availabilityTags = $.availabilityTags;
        this.availableOnAllAps = $.availableOnAllAps;
        this.bandSelection = $.bandSelection;
        this.concentratorNetworkId = $.concentratorNetworkId;
        this.defaultVlanId = $.defaultVlanId;
        this.disassociateClientsOnVpnFailover = $.disassociateClientsOnVpnFailover;
        this.dnsRewrite = $.dnsRewrite;
        this.dot11r = $.dot11r;
        this.dot11w = $.dot11w;
        this.enabled = $.enabled;
        this.encryptionMode = $.encryptionMode;
        this.enterpriseAdminAccess = $.enterpriseAdminAccess;
        this.gre = $.gre;
        this.ipAssignmentMode = $.ipAssignmentMode;
        this.lanIsolationEnabled = $.lanIsolationEnabled;
        this.ldap = $.ldap;
        this.localRadius = $.localRadius;
        this.mandatoryDhcpEnabled = $.mandatoryDhcpEnabled;
        this.minBitrate = $.minBitrate;
        this.name = $.name;
        this.namedVlans = $.namedVlans;
        this.networkId = $.networkId;
        this.number = $.number;
        this.oauth = $.oauth;
        this.perClientBandwidthLimitDown = $.perClientBandwidthLimitDown;
        this.perClientBandwidthLimitUp = $.perClientBandwidthLimitUp;
        this.perSsidBandwidthLimitDown = $.perSsidBandwidthLimitDown;
        this.perSsidBandwidthLimitUp = $.perSsidBandwidthLimitUp;
        this.psk = $.psk;
        this.radiusAccountingEnabled = $.radiusAccountingEnabled;
        this.radiusAccountingInterimInterval = $.radiusAccountingInterimInterval;
        this.radiusAccountingServers = $.radiusAccountingServers;
        this.radiusAttributeForGroupPolicies = $.radiusAttributeForGroupPolicies;
        this.radiusAuthenticationNasId = $.radiusAuthenticationNasId;
        this.radiusCalledStationId = $.radiusCalledStationId;
        this.radiusCoaEnabled = $.radiusCoaEnabled;
        this.radiusFailoverPolicy = $.radiusFailoverPolicy;
        this.radiusFallbackEnabled = $.radiusFallbackEnabled;
        this.radiusGuestVlanEnabled = $.radiusGuestVlanEnabled;
        this.radiusGuestVlanId = $.radiusGuestVlanId;
        this.radiusLoadBalancingPolicy = $.radiusLoadBalancingPolicy;
        this.radiusOverride = $.radiusOverride;
        this.radiusProxyEnabled = $.radiusProxyEnabled;
        this.radiusServerAttemptsLimit = $.radiusServerAttemptsLimit;
        this.radiusServerTimeout = $.radiusServerTimeout;
        this.radiusServers = $.radiusServers;
        this.radiusTestingEnabled = $.radiusTestingEnabled;
        this.secondaryConcentratorNetworkId = $.secondaryConcentratorNetworkId;
        this.speedBurst = $.speedBurst;
        this.splashGuestSponsorDomains = $.splashGuestSponsorDomains;
        this.splashPage = $.splashPage;
        this.useVlanTagging = $.useVlanTagging;
        this.visible = $.visible;
        this.vlanId = $.vlanId;
        this.walledGardenEnabled = $.walledGardenEnabled;
        this.walledGardenRanges = $.walledGardenRanges;
        this.wpaEncryptionMode = $.wpaEncryptionMode;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(WirelessSsidsArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private WirelessSsidsArgs $;

        public Builder() {
            $ = new WirelessSsidsArgs();
        }

        public Builder(WirelessSsidsArgs defaults) {
            $ = new WirelessSsidsArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param activeDirectory The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
         * 
         * @return builder
         * 
         */
        public Builder activeDirectory(@Nullable Output<WirelessSsidsActiveDirectoryArgs> activeDirectory) {
            $.activeDirectory = activeDirectory;
            return this;
        }

        /**
         * @param activeDirectory The current setting for Active Directory. Only valid if splashPage is &#39;Password-protected with Active Directory&#39;
         * 
         * @return builder
         * 
         */
        public Builder activeDirectory(WirelessSsidsActiveDirectoryArgs activeDirectory) {
            return activeDirectory(Output.of(activeDirectory));
        }

        /**
         * @param adultContentFilteringEnabled Boolean indicating whether or not adult content will be blocked
         * 
         * @return builder
         * 
         */
        public Builder adultContentFilteringEnabled(@Nullable Output<Boolean> adultContentFilteringEnabled) {
            $.adultContentFilteringEnabled = adultContentFilteringEnabled;
            return this;
        }

        /**
         * @param adultContentFilteringEnabled Boolean indicating whether or not adult content will be blocked
         * 
         * @return builder
         * 
         */
        public Builder adultContentFilteringEnabled(Boolean adultContentFilteringEnabled) {
            return adultContentFilteringEnabled(Output.of(adultContentFilteringEnabled));
        }

        /**
         * @param apTagsAndVlanIds The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
         * 
         * @return builder
         * 
         */
        public Builder apTagsAndVlanIds(@Nullable Output<List<WirelessSsidsApTagsAndVlanIdArgs>> apTagsAndVlanIds) {
            $.apTagsAndVlanIds = apTagsAndVlanIds;
            return this;
        }

        /**
         * @param apTagsAndVlanIds The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
         * 
         * @return builder
         * 
         */
        public Builder apTagsAndVlanIds(List<WirelessSsidsApTagsAndVlanIdArgs> apTagsAndVlanIds) {
            return apTagsAndVlanIds(Output.of(apTagsAndVlanIds));
        }

        /**
         * @param apTagsAndVlanIds The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
         * 
         * @return builder
         * 
         */
        public Builder apTagsAndVlanIds(WirelessSsidsApTagsAndVlanIdArgs... apTagsAndVlanIds) {
            return apTagsAndVlanIds(List.of(apTagsAndVlanIds));
        }

        /**
         * @param authMode The association control method for the SSID
         * 
         * @return builder
         * 
         */
        public Builder authMode(@Nullable Output<String> authMode) {
            $.authMode = authMode;
            return this;
        }

        /**
         * @param authMode The association control method for the SSID
         * 
         * @return builder
         * 
         */
        public Builder authMode(String authMode) {
            return authMode(Output.of(authMode));
        }

        /**
         * @param availabilityTags List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
         * 
         * @return builder
         * 
         */
        public Builder availabilityTags(@Nullable Output<List<String>> availabilityTags) {
            $.availabilityTags = availabilityTags;
            return this;
        }

        /**
         * @param availabilityTags List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
         * 
         * @return builder
         * 
         */
        public Builder availabilityTags(List<String> availabilityTags) {
            return availabilityTags(Output.of(availabilityTags));
        }

        /**
         * @param availabilityTags List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
         * 
         * @return builder
         * 
         */
        public Builder availabilityTags(String... availabilityTags) {
            return availabilityTags(List.of(availabilityTags));
        }

        /**
         * @param availableOnAllAps Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
         * 
         * @return builder
         * 
         */
        public Builder availableOnAllAps(@Nullable Output<Boolean> availableOnAllAps) {
            $.availableOnAllAps = availableOnAllAps;
            return this;
        }

        /**
         * @param availableOnAllAps Whether all APs broadcast the SSID or if it&#39;s restricted to APs matching any availability tags
         * 
         * @return builder
         * 
         */
        public Builder availableOnAllAps(Boolean availableOnAllAps) {
            return availableOnAllAps(Output.of(availableOnAllAps));
        }

        /**
         * @param bandSelection The client-serving radio frequencies of this SSID in the default indoor RF profile
         * 
         * @return builder
         * 
         */
        public Builder bandSelection(@Nullable Output<String> bandSelection) {
            $.bandSelection = bandSelection;
            return this;
        }

        /**
         * @param bandSelection The client-serving radio frequencies of this SSID in the default indoor RF profile
         * 
         * @return builder
         * 
         */
        public Builder bandSelection(String bandSelection) {
            return bandSelection(Output.of(bandSelection));
        }

        /**
         * @param concentratorNetworkId The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
         * 
         * @return builder
         * 
         */
        public Builder concentratorNetworkId(@Nullable Output<String> concentratorNetworkId) {
            $.concentratorNetworkId = concentratorNetworkId;
            return this;
        }

        /**
         * @param concentratorNetworkId The concentrator to use when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;.
         * 
         * @return builder
         * 
         */
        public Builder concentratorNetworkId(String concentratorNetworkId) {
            return concentratorNetworkId(Output.of(concentratorNetworkId));
        }

        /**
         * @param defaultVlanId The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
         * 
         * @return builder
         * 
         */
        public Builder defaultVlanId(@Nullable Output<Integer> defaultVlanId) {
            $.defaultVlanId = defaultVlanId;
            return this;
        }

        /**
         * @param defaultVlanId The default VLAN ID used for &#39;all other APs&#39;. This param is only valid when the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
         * 
         * @return builder
         * 
         */
        public Builder defaultVlanId(Integer defaultVlanId) {
            return defaultVlanId(Output.of(defaultVlanId));
        }

        /**
         * @param disassociateClientsOnVpnFailover Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
         * 
         * @return builder
         * 
         */
        public Builder disassociateClientsOnVpnFailover(@Nullable Output<Boolean> disassociateClientsOnVpnFailover) {
            $.disassociateClientsOnVpnFailover = disassociateClientsOnVpnFailover;
            return this;
        }

        /**
         * @param disassociateClientsOnVpnFailover Disassociate clients when &#39;VPN&#39; concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is &#39;VPN&#39;.
         * 
         * @return builder
         * 
         */
        public Builder disassociateClientsOnVpnFailover(Boolean disassociateClientsOnVpnFailover) {
            return disassociateClientsOnVpnFailover(Output.of(disassociateClientsOnVpnFailover));
        }

        /**
         * @param dnsRewrite DNS servers rewrite settings
         * 
         * @return builder
         * 
         */
        public Builder dnsRewrite(@Nullable Output<WirelessSsidsDnsRewriteArgs> dnsRewrite) {
            $.dnsRewrite = dnsRewrite;
            return this;
        }

        /**
         * @param dnsRewrite DNS servers rewrite settings
         * 
         * @return builder
         * 
         */
        public Builder dnsRewrite(WirelessSsidsDnsRewriteArgs dnsRewrite) {
            return dnsRewrite(Output.of(dnsRewrite));
        }

        /**
         * @param dot11r The current setting for 802.11r
         * 
         * @return builder
         * 
         */
        public Builder dot11r(@Nullable Output<WirelessSsidsDot11rArgs> dot11r) {
            $.dot11r = dot11r;
            return this;
        }

        /**
         * @param dot11r The current setting for 802.11r
         * 
         * @return builder
         * 
         */
        public Builder dot11r(WirelessSsidsDot11rArgs dot11r) {
            return dot11r(Output.of(dot11r));
        }

        /**
         * @param dot11w The current setting for Protected Management Frames (802.11w).
         * 
         * @return builder
         * 
         */
        public Builder dot11w(@Nullable Output<WirelessSsidsDot11wArgs> dot11w) {
            $.dot11w = dot11w;
            return this;
        }

        /**
         * @param dot11w The current setting for Protected Management Frames (802.11w).
         * 
         * @return builder
         * 
         */
        public Builder dot11w(WirelessSsidsDot11wArgs dot11w) {
            return dot11w(Output.of(dot11w));
        }

        /**
         * @param enabled Whether or not the SSID is enabled
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Whether or not the SSID is enabled
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param encryptionMode The psk encryption mode for the SSID
         * 
         * @return builder
         * 
         */
        public Builder encryptionMode(@Nullable Output<String> encryptionMode) {
            $.encryptionMode = encryptionMode;
            return this;
        }

        /**
         * @param encryptionMode The psk encryption mode for the SSID
         * 
         * @return builder
         * 
         */
        public Builder encryptionMode(String encryptionMode) {
            return encryptionMode(Output.of(encryptionMode));
        }

        /**
         * @param enterpriseAdminAccess Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
         * 
         * @return builder
         * 
         */
        public Builder enterpriseAdminAccess(@Nullable Output<String> enterpriseAdminAccess) {
            $.enterpriseAdminAccess = enterpriseAdminAccess;
            return this;
        }

        /**
         * @param enterpriseAdminAccess Whether or not an SSID is accessible by &#39;enterprise&#39; administrators (&#39;access disabled&#39; or &#39;access enabled&#39;)
         * 
         * @return builder
         * 
         */
        public Builder enterpriseAdminAccess(String enterpriseAdminAccess) {
            return enterpriseAdminAccess(Output.of(enterpriseAdminAccess));
        }

        /**
         * @param gre Ethernet over GRE settings
         * 
         * @return builder
         * 
         */
        public Builder gre(@Nullable Output<WirelessSsidsGreArgs> gre) {
            $.gre = gre;
            return this;
        }

        /**
         * @param gre Ethernet over GRE settings
         * 
         * @return builder
         * 
         */
        public Builder gre(WirelessSsidsGreArgs gre) {
            return gre(Output.of(gre));
        }

        /**
         * @param ipAssignmentMode The client IP assignment mode
         * 
         * @return builder
         * 
         */
        public Builder ipAssignmentMode(@Nullable Output<String> ipAssignmentMode) {
            $.ipAssignmentMode = ipAssignmentMode;
            return this;
        }

        /**
         * @param ipAssignmentMode The client IP assignment mode
         * 
         * @return builder
         * 
         */
        public Builder ipAssignmentMode(String ipAssignmentMode) {
            return ipAssignmentMode(Output.of(ipAssignmentMode));
        }

        /**
         * @param lanIsolationEnabled Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
         * 
         * @return builder
         * 
         */
        public Builder lanIsolationEnabled(@Nullable Output<Boolean> lanIsolationEnabled) {
            $.lanIsolationEnabled = lanIsolationEnabled;
            return this;
        }

        /**
         * @param lanIsolationEnabled Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is &#39;Bridge mode&#39;.
         * 
         * @return builder
         * 
         */
        public Builder lanIsolationEnabled(Boolean lanIsolationEnabled) {
            return lanIsolationEnabled(Output.of(lanIsolationEnabled));
        }

        /**
         * @param ldap The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
         * 
         * @return builder
         * 
         */
        public Builder ldap(@Nullable Output<WirelessSsidsLdapArgs> ldap) {
            $.ldap = ldap;
            return this;
        }

        /**
         * @param ldap The current setting for LDAP. Only valid if splashPage is &#39;Password-protected with LDAP&#39;.
         * 
         * @return builder
         * 
         */
        public Builder ldap(WirelessSsidsLdapArgs ldap) {
            return ldap(Output.of(ldap));
        }

        /**
         * @param localRadius The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
         * 
         * @return builder
         * 
         */
        public Builder localRadius(@Nullable Output<WirelessSsidsLocalRadiusArgs> localRadius) {
            $.localRadius = localRadius;
            return this;
        }

        /**
         * @param localRadius The current setting for Local Authentication, a built-in RADIUS server on the access point. Only valid if authMode is &#39;8021x-localradius&#39;.
         * 
         * @return builder
         * 
         */
        public Builder localRadius(WirelessSsidsLocalRadiusArgs localRadius) {
            return localRadius(Output.of(localRadius));
        }

        /**
         * @param mandatoryDhcpEnabled Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
         * 
         * @return builder
         * 
         */
        public Builder mandatoryDhcpEnabled(@Nullable Output<Boolean> mandatoryDhcpEnabled) {
            $.mandatoryDhcpEnabled = mandatoryDhcpEnabled;
            return this;
        }

        /**
         * @param mandatoryDhcpEnabled Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
         * 
         * @return builder
         * 
         */
        public Builder mandatoryDhcpEnabled(Boolean mandatoryDhcpEnabled) {
            return mandatoryDhcpEnabled(Output.of(mandatoryDhcpEnabled));
        }

        /**
         * @param minBitrate The minimum bitrate in Mbps of this SSID in the default indoor RF profile
         * 
         * @return builder
         * 
         */
        public Builder minBitrate(@Nullable Output<Integer> minBitrate) {
            $.minBitrate = minBitrate;
            return this;
        }

        /**
         * @param minBitrate The minimum bitrate in Mbps of this SSID in the default indoor RF profile
         * 
         * @return builder
         * 
         */
        public Builder minBitrate(Integer minBitrate) {
            return minBitrate(Output.of(minBitrate));
        }

        /**
         * @param name The name of the SSID
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the SSID
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param namedVlans Named VLAN settings.
         * 
         * @return builder
         * 
         */
        public Builder namedVlans(@Nullable Output<WirelessSsidsNamedVlansArgs> namedVlans) {
            $.namedVlans = namedVlans;
            return this;
        }

        /**
         * @param namedVlans Named VLAN settings.
         * 
         * @return builder
         * 
         */
        public Builder namedVlans(WirelessSsidsNamedVlansArgs namedVlans) {
            return namedVlans(Output.of(namedVlans));
        }

        /**
         * @param networkId networkId path parameter. Network ID
         * 
         * @return builder
         * 
         */
        public Builder networkId(Output<String> networkId) {
            $.networkId = networkId;
            return this;
        }

        /**
         * @param networkId networkId path parameter. Network ID
         * 
         * @return builder
         * 
         */
        public Builder networkId(String networkId) {
            return networkId(Output.of(networkId));
        }

        /**
         * @param number Unique identifier of the SSID
         * 
         * @return builder
         * 
         */
        public Builder number(Output<Integer> number) {
            $.number = number;
            return this;
        }

        /**
         * @param number Unique identifier of the SSID
         * 
         * @return builder
         * 
         */
        public Builder number(Integer number) {
            return number(Output.of(number));
        }

        /**
         * @param oauth The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
         * 
         * @return builder
         * 
         */
        public Builder oauth(@Nullable Output<WirelessSsidsOauthArgs> oauth) {
            $.oauth = oauth;
            return this;
        }

        /**
         * @param oauth The OAuth settings of this SSID. Only valid if splashPage is &#39;Google OAuth&#39;.
         * 
         * @return builder
         * 
         */
        public Builder oauth(WirelessSsidsOauthArgs oauth) {
            return oauth(Output.of(oauth));
        }

        /**
         * @param perClientBandwidthLimitDown The download bandwidth limit in Kbps. (0 represents no limit.)
         * 
         * @return builder
         * 
         */
        public Builder perClientBandwidthLimitDown(@Nullable Output<Integer> perClientBandwidthLimitDown) {
            $.perClientBandwidthLimitDown = perClientBandwidthLimitDown;
            return this;
        }

        /**
         * @param perClientBandwidthLimitDown The download bandwidth limit in Kbps. (0 represents no limit.)
         * 
         * @return builder
         * 
         */
        public Builder perClientBandwidthLimitDown(Integer perClientBandwidthLimitDown) {
            return perClientBandwidthLimitDown(Output.of(perClientBandwidthLimitDown));
        }

        /**
         * @param perClientBandwidthLimitUp The upload bandwidth limit in Kbps. (0 represents no limit.)
         * 
         * @return builder
         * 
         */
        public Builder perClientBandwidthLimitUp(@Nullable Output<Integer> perClientBandwidthLimitUp) {
            $.perClientBandwidthLimitUp = perClientBandwidthLimitUp;
            return this;
        }

        /**
         * @param perClientBandwidthLimitUp The upload bandwidth limit in Kbps. (0 represents no limit.)
         * 
         * @return builder
         * 
         */
        public Builder perClientBandwidthLimitUp(Integer perClientBandwidthLimitUp) {
            return perClientBandwidthLimitUp(Output.of(perClientBandwidthLimitUp));
        }

        /**
         * @param perSsidBandwidthLimitDown The total download bandwidth limit in Kbps (0 represents no limit)
         * 
         * @return builder
         * 
         */
        public Builder perSsidBandwidthLimitDown(@Nullable Output<Integer> perSsidBandwidthLimitDown) {
            $.perSsidBandwidthLimitDown = perSsidBandwidthLimitDown;
            return this;
        }

        /**
         * @param perSsidBandwidthLimitDown The total download bandwidth limit in Kbps (0 represents no limit)
         * 
         * @return builder
         * 
         */
        public Builder perSsidBandwidthLimitDown(Integer perSsidBandwidthLimitDown) {
            return perSsidBandwidthLimitDown(Output.of(perSsidBandwidthLimitDown));
        }

        /**
         * @param perSsidBandwidthLimitUp The total upload bandwidth limit in Kbps (0 represents no limit)
         * 
         * @return builder
         * 
         */
        public Builder perSsidBandwidthLimitUp(@Nullable Output<Integer> perSsidBandwidthLimitUp) {
            $.perSsidBandwidthLimitUp = perSsidBandwidthLimitUp;
            return this;
        }

        /**
         * @param perSsidBandwidthLimitUp The total upload bandwidth limit in Kbps (0 represents no limit)
         * 
         * @return builder
         * 
         */
        public Builder perSsidBandwidthLimitUp(Integer perSsidBandwidthLimitUp) {
            return perSsidBandwidthLimitUp(Output.of(perSsidBandwidthLimitUp));
        }

        /**
         * @param psk The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
         * 
         * @return builder
         * 
         */
        public Builder psk(@Nullable Output<String> psk) {
            $.psk = psk;
            return this;
        }

        /**
         * @param psk The passkey for the SSID. This param is only valid if the authMode is &#39;psk&#39;
         * 
         * @return builder
         * 
         */
        public Builder psk(String psk) {
            return psk(Output.of(psk));
        }

        /**
         * @param radiusAccountingEnabled Whether or not RADIUS accounting is enabled
         * 
         * @return builder
         * 
         */
        public Builder radiusAccountingEnabled(@Nullable Output<Boolean> radiusAccountingEnabled) {
            $.radiusAccountingEnabled = radiusAccountingEnabled;
            return this;
        }

        /**
         * @param radiusAccountingEnabled Whether or not RADIUS accounting is enabled
         * 
         * @return builder
         * 
         */
        public Builder radiusAccountingEnabled(Boolean radiusAccountingEnabled) {
            return radiusAccountingEnabled(Output.of(radiusAccountingEnabled));
        }

        /**
         * @param radiusAccountingInterimInterval The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
         * 
         * @return builder
         * 
         */
        public Builder radiusAccountingInterimInterval(@Nullable Output<Integer> radiusAccountingInterimInterval) {
            $.radiusAccountingInterimInterval = radiusAccountingInterimInterval;
            return this;
        }

        /**
         * @param radiusAccountingInterimInterval The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
         * 
         * @return builder
         * 
         */
        public Builder radiusAccountingInterimInterval(Integer radiusAccountingInterimInterval) {
            return radiusAccountingInterimInterval(Output.of(radiusAccountingInterimInterval));
        }

        /**
         * @param radiusAccountingServers List of RADIUS accounting 802.1X servers to be used for authentication
         * 
         * @return builder
         * 
         */
        public Builder radiusAccountingServers(@Nullable Output<List<WirelessSsidsRadiusAccountingServerArgs>> radiusAccountingServers) {
            $.radiusAccountingServers = radiusAccountingServers;
            return this;
        }

        /**
         * @param radiusAccountingServers List of RADIUS accounting 802.1X servers to be used for authentication
         * 
         * @return builder
         * 
         */
        public Builder radiusAccountingServers(List<WirelessSsidsRadiusAccountingServerArgs> radiusAccountingServers) {
            return radiusAccountingServers(Output.of(radiusAccountingServers));
        }

        /**
         * @param radiusAccountingServers List of RADIUS accounting 802.1X servers to be used for authentication
         * 
         * @return builder
         * 
         */
        public Builder radiusAccountingServers(WirelessSsidsRadiusAccountingServerArgs... radiusAccountingServers) {
            return radiusAccountingServers(List.of(radiusAccountingServers));
        }

        /**
         * @param radiusAttributeForGroupPolicies RADIUS attribute used to look up group policies
         * 
         * @return builder
         * 
         */
        public Builder radiusAttributeForGroupPolicies(@Nullable Output<String> radiusAttributeForGroupPolicies) {
            $.radiusAttributeForGroupPolicies = radiusAttributeForGroupPolicies;
            return this;
        }

        /**
         * @param radiusAttributeForGroupPolicies RADIUS attribute used to look up group policies
         * 
         * @return builder
         * 
         */
        public Builder radiusAttributeForGroupPolicies(String radiusAttributeForGroupPolicies) {
            return radiusAttributeForGroupPolicies(Output.of(radiusAttributeForGroupPolicies));
        }

        /**
         * @param radiusAuthenticationNasId The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
         * 
         * @return builder
         * 
         */
        public Builder radiusAuthenticationNasId(@Nullable Output<String> radiusAuthenticationNasId) {
            $.radiusAuthenticationNasId = radiusAuthenticationNasId;
            return this;
        }

        /**
         * @param radiusAuthenticationNasId The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE*MAC$:$VAP*NUM$).
         * 
         * @return builder
         * 
         */
        public Builder radiusAuthenticationNasId(String radiusAuthenticationNasId) {
            return radiusAuthenticationNasId(Output.of(radiusAuthenticationNasId));
        }

        /**
         * @param radiusCalledStationId The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
         * 
         * @return builder
         * 
         */
        public Builder radiusCalledStationId(@Nullable Output<String> radiusCalledStationId) {
            $.radiusCalledStationId = radiusCalledStationId;
            return this;
        }

        /**
         * @param radiusCalledStationId The template of the called station identifier to be used for RADIUS (ex. $NODE*MAC$:$VAP*NUM$).
         * 
         * @return builder
         * 
         */
        public Builder radiusCalledStationId(String radiusCalledStationId) {
            return radiusCalledStationId(Output.of(radiusCalledStationId));
        }

        /**
         * @param radiusCoaEnabled If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
         * 
         * @return builder
         * 
         */
        public Builder radiusCoaEnabled(@Nullable Output<Boolean> radiusCoaEnabled) {
            $.radiusCoaEnabled = radiusCoaEnabled;
            return this;
        }

        /**
         * @param radiusCoaEnabled If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
         * 
         * @return builder
         * 
         */
        public Builder radiusCoaEnabled(Boolean radiusCoaEnabled) {
            return radiusCoaEnabled(Output.of(radiusCoaEnabled));
        }

        /**
         * @param radiusFailoverPolicy Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
         * 
         * @return builder
         * 
         */
        public Builder radiusFailoverPolicy(@Nullable Output<String> radiusFailoverPolicy) {
            $.radiusFailoverPolicy = radiusFailoverPolicy;
            return this;
        }

        /**
         * @param radiusFailoverPolicy Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
         * 
         * @return builder
         * 
         */
        public Builder radiusFailoverPolicy(String radiusFailoverPolicy) {
            return radiusFailoverPolicy(Output.of(radiusFailoverPolicy));
        }

        /**
         * @param radiusFallbackEnabled Whether or not higher priority RADIUS servers should be retried after 60 seconds.
         * 
         * @return builder
         * 
         */
        public Builder radiusFallbackEnabled(@Nullable Output<Boolean> radiusFallbackEnabled) {
            $.radiusFallbackEnabled = radiusFallbackEnabled;
            return this;
        }

        /**
         * @param radiusFallbackEnabled Whether or not higher priority RADIUS servers should be retried after 60 seconds.
         * 
         * @return builder
         * 
         */
        public Builder radiusFallbackEnabled(Boolean radiusFallbackEnabled) {
            return radiusFallbackEnabled(Output.of(radiusFallbackEnabled));
        }

        /**
         * @param radiusGuestVlanEnabled Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
         * 
         * @return builder
         * 
         */
        public Builder radiusGuestVlanEnabled(@Nullable Output<Boolean> radiusGuestVlanEnabled) {
            $.radiusGuestVlanEnabled = radiusGuestVlanEnabled;
            return this;
        }

        /**
         * @param radiusGuestVlanEnabled Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
         * 
         * @return builder
         * 
         */
        public Builder radiusGuestVlanEnabled(Boolean radiusGuestVlanEnabled) {
            return radiusGuestVlanEnabled(Output.of(radiusGuestVlanEnabled));
        }

        /**
         * @param radiusGuestVlanId VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
         * 
         * @return builder
         * 
         */
        public Builder radiusGuestVlanId(@Nullable Output<Integer> radiusGuestVlanId) {
            $.radiusGuestVlanId = radiusGuestVlanId;
            return this;
        }

        /**
         * @param radiusGuestVlanId VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is &#39;open-with-radius&#39; and addressing mode is not set to &#39;isolated&#39; or &#39;nat&#39; mode
         * 
         * @return builder
         * 
         */
        public Builder radiusGuestVlanId(Integer radiusGuestVlanId) {
            return radiusGuestVlanId(Output.of(radiusGuestVlanId));
        }

        /**
         * @param radiusLoadBalancingPolicy Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
         * 
         * @return builder
         * 
         */
        public Builder radiusLoadBalancingPolicy(@Nullable Output<String> radiusLoadBalancingPolicy) {
            $.radiusLoadBalancingPolicy = radiusLoadBalancingPolicy;
            return this;
        }

        /**
         * @param radiusLoadBalancingPolicy Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
         * 
         * @return builder
         * 
         */
        public Builder radiusLoadBalancingPolicy(String radiusLoadBalancingPolicy) {
            return radiusLoadBalancingPolicy(Output.of(radiusLoadBalancingPolicy));
        }

        /**
         * @param radiusOverride If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
         * 
         * @return builder
         * 
         */
        public Builder radiusOverride(@Nullable Output<Boolean> radiusOverride) {
            $.radiusOverride = radiusOverride;
            return this;
        }

        /**
         * @param radiusOverride If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is &#39;NAT mode&#39;.
         * 
         * @return builder
         * 
         */
        public Builder radiusOverride(Boolean radiusOverride) {
            return radiusOverride(Output.of(radiusOverride));
        }

        /**
         * @param radiusProxyEnabled If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
         * 
         * @return builder
         * 
         */
        public Builder radiusProxyEnabled(@Nullable Output<Boolean> radiusProxyEnabled) {
            $.radiusProxyEnabled = radiusProxyEnabled;
            return this;
        }

        /**
         * @param radiusProxyEnabled If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
         * 
         * @return builder
         * 
         */
        public Builder radiusProxyEnabled(Boolean radiusProxyEnabled) {
            return radiusProxyEnabled(Output.of(radiusProxyEnabled));
        }

        /**
         * @param radiusServerAttemptsLimit The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
         * 
         * @return builder
         * 
         */
        public Builder radiusServerAttemptsLimit(@Nullable Output<Integer> radiusServerAttemptsLimit) {
            $.radiusServerAttemptsLimit = radiusServerAttemptsLimit;
            return this;
        }

        /**
         * @param radiusServerAttemptsLimit The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
         * 
         * @return builder
         * 
         */
        public Builder radiusServerAttemptsLimit(Integer radiusServerAttemptsLimit) {
            return radiusServerAttemptsLimit(Output.of(radiusServerAttemptsLimit));
        }

        /**
         * @param radiusServerTimeout The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
         * 
         * @return builder
         * 
         */
        public Builder radiusServerTimeout(@Nullable Output<Integer> radiusServerTimeout) {
            $.radiusServerTimeout = radiusServerTimeout;
            return this;
        }

        /**
         * @param radiusServerTimeout The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
         * 
         * @return builder
         * 
         */
        public Builder radiusServerTimeout(Integer radiusServerTimeout) {
            return radiusServerTimeout(Output.of(radiusServerTimeout));
        }

        /**
         * @param radiusServers The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
         * 
         * @return builder
         * 
         */
        public Builder radiusServers(@Nullable Output<List<WirelessSsidsRadiusServerArgs>> radiusServers) {
            $.radiusServers = radiusServers;
            return this;
        }

        /**
         * @param radiusServers The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
         * 
         * @return builder
         * 
         */
        public Builder radiusServers(List<WirelessSsidsRadiusServerArgs> radiusServers) {
            return radiusServers(Output.of(radiusServers));
        }

        /**
         * @param radiusServers The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is &#39;open-with-radius&#39;, &#39;8021x-radius&#39; or &#39;ipsk-with-radius&#39;
         * 
         * @return builder
         * 
         */
        public Builder radiusServers(WirelessSsidsRadiusServerArgs... radiusServers) {
            return radiusServers(List.of(radiusServers));
        }

        /**
         * @param radiusTestingEnabled If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
         * 
         * @return builder
         * 
         */
        public Builder radiusTestingEnabled(@Nullable Output<Boolean> radiusTestingEnabled) {
            $.radiusTestingEnabled = radiusTestingEnabled;
            return this;
        }

        /**
         * @param radiusTestingEnabled If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity &#39;meraki*8021x*test&#39; to ensure that the RADIUS servers are reachable.
         * 
         * @return builder
         * 
         */
        public Builder radiusTestingEnabled(Boolean radiusTestingEnabled) {
            return radiusTestingEnabled(Output.of(radiusTestingEnabled));
        }

        /**
         * @param secondaryConcentratorNetworkId The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
         * 
         * @return builder
         * 
         */
        public Builder secondaryConcentratorNetworkId(@Nullable Output<String> secondaryConcentratorNetworkId) {
            $.secondaryConcentratorNetworkId = secondaryConcentratorNetworkId;
            return this;
        }

        /**
         * @param secondaryConcentratorNetworkId The secondary concentrator to use when the ipAssignmentMode is &#39;VPN&#39;. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. (&#39;disabled&#39; represents no secondary concentrator.)
         * 
         * @return builder
         * 
         */
        public Builder secondaryConcentratorNetworkId(String secondaryConcentratorNetworkId) {
            return secondaryConcentratorNetworkId(Output.of(secondaryConcentratorNetworkId));
        }

        /**
         * @param speedBurst The SpeedBurst setting for this SSID&#39;
         * 
         * @return builder
         * 
         */
        public Builder speedBurst(@Nullable Output<WirelessSsidsSpeedBurstArgs> speedBurst) {
            $.speedBurst = speedBurst;
            return this;
        }

        /**
         * @param speedBurst The SpeedBurst setting for this SSID&#39;
         * 
         * @return builder
         * 
         */
        public Builder speedBurst(WirelessSsidsSpeedBurstArgs speedBurst) {
            return speedBurst(Output.of(speedBurst));
        }

        /**
         * @param splashGuestSponsorDomains Array of valid sponsor email domains for sponsored guest splash type.
         * 
         * @return builder
         * 
         */
        public Builder splashGuestSponsorDomains(@Nullable Output<List<String>> splashGuestSponsorDomains) {
            $.splashGuestSponsorDomains = splashGuestSponsorDomains;
            return this;
        }

        /**
         * @param splashGuestSponsorDomains Array of valid sponsor email domains for sponsored guest splash type.
         * 
         * @return builder
         * 
         */
        public Builder splashGuestSponsorDomains(List<String> splashGuestSponsorDomains) {
            return splashGuestSponsorDomains(Output.of(splashGuestSponsorDomains));
        }

        /**
         * @param splashGuestSponsorDomains Array of valid sponsor email domains for sponsored guest splash type.
         * 
         * @return builder
         * 
         */
        public Builder splashGuestSponsorDomains(String... splashGuestSponsorDomains) {
            return splashGuestSponsorDomains(List.of(splashGuestSponsorDomains));
        }

        /**
         * @param splashPage The type of splash page for the SSID
         * 
         * @return builder
         * 
         */
        public Builder splashPage(@Nullable Output<String> splashPage) {
            $.splashPage = splashPage;
            return this;
        }

        /**
         * @param splashPage The type of splash page for the SSID
         * 
         * @return builder
         * 
         */
        public Builder splashPage(String splashPage) {
            return splashPage(Output.of(splashPage));
        }

        /**
         * @param useVlanTagging Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
         * 
         * @return builder
         * 
         */
        public Builder useVlanTagging(@Nullable Output<Boolean> useVlanTagging) {
            $.useVlanTagging = useVlanTagging;
            return this;
        }

        /**
         * @param useVlanTagging Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is &#39;Bridge mode&#39; or &#39;Layer 3 roaming&#39;
         * 
         * @return builder
         * 
         */
        public Builder useVlanTagging(Boolean useVlanTagging) {
            return useVlanTagging(Output.of(useVlanTagging));
        }

        /**
         * @param visible Whether the SSID is advertised or hidden by the AP
         * 
         * @return builder
         * 
         */
        public Builder visible(@Nullable Output<Boolean> visible) {
            $.visible = visible;
            return this;
        }

        /**
         * @param visible Whether the SSID is advertised or hidden by the AP
         * 
         * @return builder
         * 
         */
        public Builder visible(Boolean visible) {
            return visible(Output.of(visible));
        }

        /**
         * @param vlanId The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
         * 
         * @return builder
         * 
         */
        public Builder vlanId(@Nullable Output<Integer> vlanId) {
            $.vlanId = vlanId;
            return this;
        }

        /**
         * @param vlanId The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is &#39;Layer 3 roaming with a concentrator&#39; or &#39;VPN&#39;
         * 
         * @return builder
         * 
         */
        public Builder vlanId(Integer vlanId) {
            return vlanId(Output.of(vlanId));
        }

        /**
         * @param walledGardenEnabled Allow users to access a configurable list of IP ranges prior to sign-on
         * 
         * @return builder
         * 
         */
        public Builder walledGardenEnabled(@Nullable Output<Boolean> walledGardenEnabled) {
            $.walledGardenEnabled = walledGardenEnabled;
            return this;
        }

        /**
         * @param walledGardenEnabled Allow users to access a configurable list of IP ranges prior to sign-on
         * 
         * @return builder
         * 
         */
        public Builder walledGardenEnabled(Boolean walledGardenEnabled) {
            return walledGardenEnabled(Output.of(walledGardenEnabled));
        }

        /**
         * @param walledGardenRanges Domain names and IP address ranges available in Walled Garden mode
         * 
         * @return builder
         * 
         */
        public Builder walledGardenRanges(@Nullable Output<List<String>> walledGardenRanges) {
            $.walledGardenRanges = walledGardenRanges;
            return this;
        }

        /**
         * @param walledGardenRanges Domain names and IP address ranges available in Walled Garden mode
         * 
         * @return builder
         * 
         */
        public Builder walledGardenRanges(List<String> walledGardenRanges) {
            return walledGardenRanges(Output.of(walledGardenRanges));
        }

        /**
         * @param walledGardenRanges Domain names and IP address ranges available in Walled Garden mode
         * 
         * @return builder
         * 
         */
        public Builder walledGardenRanges(String... walledGardenRanges) {
            return walledGardenRanges(List.of(walledGardenRanges));
        }

        /**
         * @param wpaEncryptionMode The types of WPA encryption
         * 
         * @return builder
         * 
         */
        public Builder wpaEncryptionMode(@Nullable Output<String> wpaEncryptionMode) {
            $.wpaEncryptionMode = wpaEncryptionMode;
            return this;
        }

        /**
         * @param wpaEncryptionMode The types of WPA encryption
         * 
         * @return builder
         * 
         */
        public Builder wpaEncryptionMode(String wpaEncryptionMode) {
            return wpaEncryptionMode(Output.of(wpaEncryptionMode));
        }

        public WirelessSsidsArgs build() {
            if ($.networkId == null) {
                throw new MissingRequiredPropertyException("WirelessSsidsArgs", "networkId");
            }
            if ($.number == null) {
                throw new MissingRequiredPropertyException("WirelessSsidsArgs", "number");
            }
            return $;
        }
    }

}
