// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.meraki.networks.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.meraki.networks.inputs.ApplianceVlansDhcpOptionArgs;
import com.pulumi.meraki.networks.inputs.ApplianceVlansIpv6Args;
import com.pulumi.meraki.networks.inputs.ApplianceVlansMandatoryDhcpArgs;
import com.pulumi.meraki.networks.inputs.ApplianceVlansReservedIpRangeArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ApplianceVlansState extends com.pulumi.resources.ResourceArgs {

    public static final ApplianceVlansState Empty = new ApplianceVlansState();

    /**
     * The local IP of the appliance on the VLAN
     * 
     */
    @Import(name="applianceIp")
    private @Nullable Output<String> applianceIp;

    /**
     * @return The local IP of the appliance on the VLAN
     * 
     */
    public Optional<Output<String>> applianceIp() {
        return Optional.ofNullable(this.applianceIp);
    }

    /**
     * CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
     * 
     */
    @Import(name="cidr")
    private @Nullable Output<String> cidr;

    /**
     * @return CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
     * 
     */
    public Optional<Output<String>> cidr() {
        return Optional.ofNullable(this.cidr);
    }

    /**
     * DHCP boot option for boot filename
     * 
     */
    @Import(name="dhcpBootFilename")
    private @Nullable Output<String> dhcpBootFilename;

    /**
     * @return DHCP boot option for boot filename
     * 
     */
    public Optional<Output<String>> dhcpBootFilename() {
        return Optional.ofNullable(this.dhcpBootFilename);
    }

    /**
     * DHCP boot option to direct boot clients to the server to load the boot file from
     * 
     */
    @Import(name="dhcpBootNextServer")
    private @Nullable Output<String> dhcpBootNextServer;

    /**
     * @return DHCP boot option to direct boot clients to the server to load the boot file from
     * 
     */
    public Optional<Output<String>> dhcpBootNextServer() {
        return Optional.ofNullable(this.dhcpBootNextServer);
    }

    /**
     * Use DHCP boot options specified in other properties
     * 
     */
    @Import(name="dhcpBootOptionsEnabled")
    private @Nullable Output<Boolean> dhcpBootOptionsEnabled;

    /**
     * @return Use DHCP boot options specified in other properties
     * 
     */
    public Optional<Output<Boolean>> dhcpBootOptionsEnabled() {
        return Optional.ofNullable(this.dhcpBootOptionsEnabled);
    }

    /**
     * The appliance&#39;s handling of DHCP requests on this VLAN. One of: &#39;Run a DHCP server&#39;, &#39;Relay DHCP to another server&#39; or &#39;Do not respond to DHCP requests&#39;
     * 
     */
    @Import(name="dhcpHandling")
    private @Nullable Output<String> dhcpHandling;

    /**
     * @return The appliance&#39;s handling of DHCP requests on this VLAN. One of: &#39;Run a DHCP server&#39;, &#39;Relay DHCP to another server&#39; or &#39;Do not respond to DHCP requests&#39;
     * 
     */
    public Optional<Output<String>> dhcpHandling() {
        return Optional.ofNullable(this.dhcpHandling);
    }

    /**
     * The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: &#39;30 minutes&#39;, &#39;1 hour&#39;, &#39;4 hours&#39;, &#39;12 hours&#39;, &#39;1 day&#39; or &#39;1 week&#39;
     * 
     */
    @Import(name="dhcpLeaseTime")
    private @Nullable Output<String> dhcpLeaseTime;

    /**
     * @return The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: &#39;30 minutes&#39;, &#39;1 hour&#39;, &#39;4 hours&#39;, &#39;12 hours&#39;, &#39;1 day&#39; or &#39;1 week&#39;
     * 
     */
    public Optional<Output<String>> dhcpLeaseTime() {
        return Optional.ofNullable(this.dhcpLeaseTime);
    }

    /**
     * The list of DHCP options that will be included in DHCP responses. Each object in the list should have &#34;code&#34;, &#34;type&#34;, and &#34;value&#34; properties.
     * 
     */
    @Import(name="dhcpOptions")
    private @Nullable Output<List<ApplianceVlansDhcpOptionArgs>> dhcpOptions;

    /**
     * @return The list of DHCP options that will be included in DHCP responses. Each object in the list should have &#34;code&#34;, &#34;type&#34;, and &#34;value&#34; properties.
     * 
     */
    public Optional<Output<List<ApplianceVlansDhcpOptionArgs>>> dhcpOptions() {
        return Optional.ofNullable(this.dhcpOptions);
    }

    /**
     * The IPs of the DHCP servers that DHCP requests should be relayed to
     * 
     */
    @Import(name="dhcpRelayServerIps")
    private @Nullable Output<List<String>> dhcpRelayServerIps;

    /**
     * @return The IPs of the DHCP servers that DHCP requests should be relayed to
     * 
     */
    public Optional<Output<List<String>>> dhcpRelayServerIps() {
        return Optional.ofNullable(this.dhcpRelayServerIps);
    }

    /**
     * The DNS nameservers used for DHCP responses, either &#34;upstream*dns&#34;, &#34;google*dns&#34;, &#34;opendns&#34;, or a newline seperated string of IP addresses or domain names
     * 
     */
    @Import(name="dnsNameservers")
    private @Nullable Output<String> dnsNameservers;

    /**
     * @return The DNS nameservers used for DHCP responses, either &#34;upstream*dns&#34;, &#34;google*dns&#34;, &#34;opendns&#34;, or a newline seperated string of IP addresses or domain names
     * 
     */
    public Optional<Output<String>> dnsNameservers() {
        return Optional.ofNullable(this.dnsNameservers);
    }

    /**
     * The id of the desired group policy to apply to the VLAN
     * 
     */
    @Import(name="groupPolicyId")
    private @Nullable Output<String> groupPolicyId;

    /**
     * @return The id of the desired group policy to apply to the VLAN
     * 
     */
    public Optional<Output<String>> groupPolicyId() {
        return Optional.ofNullable(this.groupPolicyId);
    }

    /**
     * The interface ID of the VLAN
     * 
     */
    @Import(name="interfaceId")
    private @Nullable Output<String> interfaceId;

    /**
     * @return The interface ID of the VLAN
     * 
     */
    public Optional<Output<String>> interfaceId() {
        return Optional.ofNullable(this.interfaceId);
    }

    /**
     * IPv6 configuration on the VLAN
     * 
     */
    @Import(name="ipv6")
    private @Nullable Output<ApplianceVlansIpv6Args> ipv6;

    /**
     * @return IPv6 configuration on the VLAN
     * 
     */
    public Optional<Output<ApplianceVlansIpv6Args>> ipv6() {
        return Optional.ofNullable(this.ipv6);
    }

    /**
     * Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won&#39;t be able to associate. Only available on firmware versions 17.0 and above
     * 
     */
    @Import(name="mandatoryDhcp")
    private @Nullable Output<ApplianceVlansMandatoryDhcpArgs> mandatoryDhcp;

    /**
     * @return Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won&#39;t be able to associate. Only available on firmware versions 17.0 and above
     * 
     */
    public Optional<Output<ApplianceVlansMandatoryDhcpArgs>> mandatoryDhcp() {
        return Optional.ofNullable(this.mandatoryDhcp);
    }

    /**
     * Mask used for the subnet of all bound to the template networks. Applicable only for template network.
     * 
     */
    @Import(name="mask")
    private @Nullable Output<Integer> mask;

    /**
     * @return Mask used for the subnet of all bound to the template networks. Applicable only for template network.
     * 
     */
    public Optional<Output<Integer>> mask() {
        return Optional.ofNullable(this.mask);
    }

    /**
     * The name of the VLAN
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the VLAN
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * networkId path parameter. Network ID
     * 
     */
    @Import(name="networkId")
    private @Nullable Output<String> networkId;

    /**
     * @return networkId path parameter. Network ID
     * 
     */
    public Optional<Output<String>> networkId() {
        return Optional.ofNullable(this.networkId);
    }

    /**
     * The DHCP reserved IP ranges on the VLAN
     * 
     */
    @Import(name="reservedIpRanges")
    private @Nullable Output<List<ApplianceVlansReservedIpRangeArgs>> reservedIpRanges;

    /**
     * @return The DHCP reserved IP ranges on the VLAN
     * 
     */
    public Optional<Output<List<ApplianceVlansReservedIpRangeArgs>>> reservedIpRanges() {
        return Optional.ofNullable(this.reservedIpRanges);
    }

    /**
     * The subnet of the VLAN
     * 
     */
    @Import(name="subnet")
    private @Nullable Output<String> subnet;

    /**
     * @return The subnet of the VLAN
     * 
     */
    public Optional<Output<String>> subnet() {
        return Optional.ofNullable(this.subnet);
    }

    /**
     * Type of subnetting of the VLAN. Applicable only for template network.
     * 
     */
    @Import(name="templateVlanType")
    private @Nullable Output<String> templateVlanType;

    /**
     * @return Type of subnetting of the VLAN. Applicable only for template network.
     * 
     */
    public Optional<Output<String>> templateVlanType() {
        return Optional.ofNullable(this.templateVlanType);
    }

    /**
     * The VLAN ID of the VLAN
     * 
     */
    @Import(name="vlanId")
    private @Nullable Output<String> vlanId;

    /**
     * @return The VLAN ID of the VLAN
     * 
     */
    public Optional<Output<String>> vlanId() {
        return Optional.ofNullable(this.vlanId);
    }

    /**
     * The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
     * 
     */
    @Import(name="vpnNatSubnet")
    private @Nullable Output<String> vpnNatSubnet;

    /**
     * @return The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
     * 
     */
    public Optional<Output<String>> vpnNatSubnet() {
        return Optional.ofNullable(this.vpnNatSubnet);
    }

    private ApplianceVlansState() {}

    private ApplianceVlansState(ApplianceVlansState $) {
        this.applianceIp = $.applianceIp;
        this.cidr = $.cidr;
        this.dhcpBootFilename = $.dhcpBootFilename;
        this.dhcpBootNextServer = $.dhcpBootNextServer;
        this.dhcpBootOptionsEnabled = $.dhcpBootOptionsEnabled;
        this.dhcpHandling = $.dhcpHandling;
        this.dhcpLeaseTime = $.dhcpLeaseTime;
        this.dhcpOptions = $.dhcpOptions;
        this.dhcpRelayServerIps = $.dhcpRelayServerIps;
        this.dnsNameservers = $.dnsNameservers;
        this.groupPolicyId = $.groupPolicyId;
        this.interfaceId = $.interfaceId;
        this.ipv6 = $.ipv6;
        this.mandatoryDhcp = $.mandatoryDhcp;
        this.mask = $.mask;
        this.name = $.name;
        this.networkId = $.networkId;
        this.reservedIpRanges = $.reservedIpRanges;
        this.subnet = $.subnet;
        this.templateVlanType = $.templateVlanType;
        this.vlanId = $.vlanId;
        this.vpnNatSubnet = $.vpnNatSubnet;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ApplianceVlansState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ApplianceVlansState $;

        public Builder() {
            $ = new ApplianceVlansState();
        }

        public Builder(ApplianceVlansState defaults) {
            $ = new ApplianceVlansState(Objects.requireNonNull(defaults));
        }

        /**
         * @param applianceIp The local IP of the appliance on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder applianceIp(@Nullable Output<String> applianceIp) {
            $.applianceIp = applianceIp;
            return this;
        }

        /**
         * @param applianceIp The local IP of the appliance on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder applianceIp(String applianceIp) {
            return applianceIp(Output.of(applianceIp));
        }

        /**
         * @param cidr CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
         * 
         * @return builder
         * 
         */
        public Builder cidr(@Nullable Output<String> cidr) {
            $.cidr = cidr;
            return this;
        }

        /**
         * @param cidr CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
         * 
         * @return builder
         * 
         */
        public Builder cidr(String cidr) {
            return cidr(Output.of(cidr));
        }

        /**
         * @param dhcpBootFilename DHCP boot option for boot filename
         * 
         * @return builder
         * 
         */
        public Builder dhcpBootFilename(@Nullable Output<String> dhcpBootFilename) {
            $.dhcpBootFilename = dhcpBootFilename;
            return this;
        }

        /**
         * @param dhcpBootFilename DHCP boot option for boot filename
         * 
         * @return builder
         * 
         */
        public Builder dhcpBootFilename(String dhcpBootFilename) {
            return dhcpBootFilename(Output.of(dhcpBootFilename));
        }

        /**
         * @param dhcpBootNextServer DHCP boot option to direct boot clients to the server to load the boot file from
         * 
         * @return builder
         * 
         */
        public Builder dhcpBootNextServer(@Nullable Output<String> dhcpBootNextServer) {
            $.dhcpBootNextServer = dhcpBootNextServer;
            return this;
        }

        /**
         * @param dhcpBootNextServer DHCP boot option to direct boot clients to the server to load the boot file from
         * 
         * @return builder
         * 
         */
        public Builder dhcpBootNextServer(String dhcpBootNextServer) {
            return dhcpBootNextServer(Output.of(dhcpBootNextServer));
        }

        /**
         * @param dhcpBootOptionsEnabled Use DHCP boot options specified in other properties
         * 
         * @return builder
         * 
         */
        public Builder dhcpBootOptionsEnabled(@Nullable Output<Boolean> dhcpBootOptionsEnabled) {
            $.dhcpBootOptionsEnabled = dhcpBootOptionsEnabled;
            return this;
        }

        /**
         * @param dhcpBootOptionsEnabled Use DHCP boot options specified in other properties
         * 
         * @return builder
         * 
         */
        public Builder dhcpBootOptionsEnabled(Boolean dhcpBootOptionsEnabled) {
            return dhcpBootOptionsEnabled(Output.of(dhcpBootOptionsEnabled));
        }

        /**
         * @param dhcpHandling The appliance&#39;s handling of DHCP requests on this VLAN. One of: &#39;Run a DHCP server&#39;, &#39;Relay DHCP to another server&#39; or &#39;Do not respond to DHCP requests&#39;
         * 
         * @return builder
         * 
         */
        public Builder dhcpHandling(@Nullable Output<String> dhcpHandling) {
            $.dhcpHandling = dhcpHandling;
            return this;
        }

        /**
         * @param dhcpHandling The appliance&#39;s handling of DHCP requests on this VLAN. One of: &#39;Run a DHCP server&#39;, &#39;Relay DHCP to another server&#39; or &#39;Do not respond to DHCP requests&#39;
         * 
         * @return builder
         * 
         */
        public Builder dhcpHandling(String dhcpHandling) {
            return dhcpHandling(Output.of(dhcpHandling));
        }

        /**
         * @param dhcpLeaseTime The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: &#39;30 minutes&#39;, &#39;1 hour&#39;, &#39;4 hours&#39;, &#39;12 hours&#39;, &#39;1 day&#39; or &#39;1 week&#39;
         * 
         * @return builder
         * 
         */
        public Builder dhcpLeaseTime(@Nullable Output<String> dhcpLeaseTime) {
            $.dhcpLeaseTime = dhcpLeaseTime;
            return this;
        }

        /**
         * @param dhcpLeaseTime The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: &#39;30 minutes&#39;, &#39;1 hour&#39;, &#39;4 hours&#39;, &#39;12 hours&#39;, &#39;1 day&#39; or &#39;1 week&#39;
         * 
         * @return builder
         * 
         */
        public Builder dhcpLeaseTime(String dhcpLeaseTime) {
            return dhcpLeaseTime(Output.of(dhcpLeaseTime));
        }

        /**
         * @param dhcpOptions The list of DHCP options that will be included in DHCP responses. Each object in the list should have &#34;code&#34;, &#34;type&#34;, and &#34;value&#34; properties.
         * 
         * @return builder
         * 
         */
        public Builder dhcpOptions(@Nullable Output<List<ApplianceVlansDhcpOptionArgs>> dhcpOptions) {
            $.dhcpOptions = dhcpOptions;
            return this;
        }

        /**
         * @param dhcpOptions The list of DHCP options that will be included in DHCP responses. Each object in the list should have &#34;code&#34;, &#34;type&#34;, and &#34;value&#34; properties.
         * 
         * @return builder
         * 
         */
        public Builder dhcpOptions(List<ApplianceVlansDhcpOptionArgs> dhcpOptions) {
            return dhcpOptions(Output.of(dhcpOptions));
        }

        /**
         * @param dhcpOptions The list of DHCP options that will be included in DHCP responses. Each object in the list should have &#34;code&#34;, &#34;type&#34;, and &#34;value&#34; properties.
         * 
         * @return builder
         * 
         */
        public Builder dhcpOptions(ApplianceVlansDhcpOptionArgs... dhcpOptions) {
            return dhcpOptions(List.of(dhcpOptions));
        }

        /**
         * @param dhcpRelayServerIps The IPs of the DHCP servers that DHCP requests should be relayed to
         * 
         * @return builder
         * 
         */
        public Builder dhcpRelayServerIps(@Nullable Output<List<String>> dhcpRelayServerIps) {
            $.dhcpRelayServerIps = dhcpRelayServerIps;
            return this;
        }

        /**
         * @param dhcpRelayServerIps The IPs of the DHCP servers that DHCP requests should be relayed to
         * 
         * @return builder
         * 
         */
        public Builder dhcpRelayServerIps(List<String> dhcpRelayServerIps) {
            return dhcpRelayServerIps(Output.of(dhcpRelayServerIps));
        }

        /**
         * @param dhcpRelayServerIps The IPs of the DHCP servers that DHCP requests should be relayed to
         * 
         * @return builder
         * 
         */
        public Builder dhcpRelayServerIps(String... dhcpRelayServerIps) {
            return dhcpRelayServerIps(List.of(dhcpRelayServerIps));
        }

        /**
         * @param dnsNameservers The DNS nameservers used for DHCP responses, either &#34;upstream*dns&#34;, &#34;google*dns&#34;, &#34;opendns&#34;, or a newline seperated string of IP addresses or domain names
         * 
         * @return builder
         * 
         */
        public Builder dnsNameservers(@Nullable Output<String> dnsNameservers) {
            $.dnsNameservers = dnsNameservers;
            return this;
        }

        /**
         * @param dnsNameservers The DNS nameservers used for DHCP responses, either &#34;upstream*dns&#34;, &#34;google*dns&#34;, &#34;opendns&#34;, or a newline seperated string of IP addresses or domain names
         * 
         * @return builder
         * 
         */
        public Builder dnsNameservers(String dnsNameservers) {
            return dnsNameservers(Output.of(dnsNameservers));
        }

        /**
         * @param groupPolicyId The id of the desired group policy to apply to the VLAN
         * 
         * @return builder
         * 
         */
        public Builder groupPolicyId(@Nullable Output<String> groupPolicyId) {
            $.groupPolicyId = groupPolicyId;
            return this;
        }

        /**
         * @param groupPolicyId The id of the desired group policy to apply to the VLAN
         * 
         * @return builder
         * 
         */
        public Builder groupPolicyId(String groupPolicyId) {
            return groupPolicyId(Output.of(groupPolicyId));
        }

        /**
         * @param interfaceId The interface ID of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder interfaceId(@Nullable Output<String> interfaceId) {
            $.interfaceId = interfaceId;
            return this;
        }

        /**
         * @param interfaceId The interface ID of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder interfaceId(String interfaceId) {
            return interfaceId(Output.of(interfaceId));
        }

        /**
         * @param ipv6 IPv6 configuration on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder ipv6(@Nullable Output<ApplianceVlansIpv6Args> ipv6) {
            $.ipv6 = ipv6;
            return this;
        }

        /**
         * @param ipv6 IPv6 configuration on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder ipv6(ApplianceVlansIpv6Args ipv6) {
            return ipv6(Output.of(ipv6));
        }

        /**
         * @param mandatoryDhcp Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won&#39;t be able to associate. Only available on firmware versions 17.0 and above
         * 
         * @return builder
         * 
         */
        public Builder mandatoryDhcp(@Nullable Output<ApplianceVlansMandatoryDhcpArgs> mandatoryDhcp) {
            $.mandatoryDhcp = mandatoryDhcp;
            return this;
        }

        /**
         * @param mandatoryDhcp Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won&#39;t be able to associate. Only available on firmware versions 17.0 and above
         * 
         * @return builder
         * 
         */
        public Builder mandatoryDhcp(ApplianceVlansMandatoryDhcpArgs mandatoryDhcp) {
            return mandatoryDhcp(Output.of(mandatoryDhcp));
        }

        /**
         * @param mask Mask used for the subnet of all bound to the template networks. Applicable only for template network.
         * 
         * @return builder
         * 
         */
        public Builder mask(@Nullable Output<Integer> mask) {
            $.mask = mask;
            return this;
        }

        /**
         * @param mask Mask used for the subnet of all bound to the template networks. Applicable only for template network.
         * 
         * @return builder
         * 
         */
        public Builder mask(Integer mask) {
            return mask(Output.of(mask));
        }

        /**
         * @param name The name of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param networkId networkId path parameter. Network ID
         * 
         * @return builder
         * 
         */
        public Builder networkId(@Nullable Output<String> networkId) {
            $.networkId = networkId;
            return this;
        }

        /**
         * @param networkId networkId path parameter. Network ID
         * 
         * @return builder
         * 
         */
        public Builder networkId(String networkId) {
            return networkId(Output.of(networkId));
        }

        /**
         * @param reservedIpRanges The DHCP reserved IP ranges on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder reservedIpRanges(@Nullable Output<List<ApplianceVlansReservedIpRangeArgs>> reservedIpRanges) {
            $.reservedIpRanges = reservedIpRanges;
            return this;
        }

        /**
         * @param reservedIpRanges The DHCP reserved IP ranges on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder reservedIpRanges(List<ApplianceVlansReservedIpRangeArgs> reservedIpRanges) {
            return reservedIpRanges(Output.of(reservedIpRanges));
        }

        /**
         * @param reservedIpRanges The DHCP reserved IP ranges on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder reservedIpRanges(ApplianceVlansReservedIpRangeArgs... reservedIpRanges) {
            return reservedIpRanges(List.of(reservedIpRanges));
        }

        /**
         * @param subnet The subnet of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder subnet(@Nullable Output<String> subnet) {
            $.subnet = subnet;
            return this;
        }

        /**
         * @param subnet The subnet of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder subnet(String subnet) {
            return subnet(Output.of(subnet));
        }

        /**
         * @param templateVlanType Type of subnetting of the VLAN. Applicable only for template network.
         * 
         * @return builder
         * 
         */
        public Builder templateVlanType(@Nullable Output<String> templateVlanType) {
            $.templateVlanType = templateVlanType;
            return this;
        }

        /**
         * @param templateVlanType Type of subnetting of the VLAN. Applicable only for template network.
         * 
         * @return builder
         * 
         */
        public Builder templateVlanType(String templateVlanType) {
            return templateVlanType(Output.of(templateVlanType));
        }

        /**
         * @param vlanId The VLAN ID of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder vlanId(@Nullable Output<String> vlanId) {
            $.vlanId = vlanId;
            return this;
        }

        /**
         * @param vlanId The VLAN ID of the VLAN
         * 
         * @return builder
         * 
         */
        public Builder vlanId(String vlanId) {
            return vlanId(Output.of(vlanId));
        }

        /**
         * @param vpnNatSubnet The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder vpnNatSubnet(@Nullable Output<String> vpnNatSubnet) {
            $.vpnNatSubnet = vpnNatSubnet;
            return this;
        }

        /**
         * @param vpnNatSubnet The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
         * 
         * @return builder
         * 
         */
        public Builder vpnNatSubnet(String vpnNatSubnet) {
            return vpnNatSubnet(Output.of(vpnNatSubnet));
        }

        public ApplianceVlansState build() {
            return $;
        }
    }

}
