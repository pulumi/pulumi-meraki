// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace administered {
    export interface LicensingSubscriptionSubscriptionsBindItem {
        /**
         * Array of errors if failed
         */
        errors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of entitlements required to successfully bind the networks to the subscription
         */
        insufficientEntitlements?: pulumi.Input<pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsBindItemInsufficientEntitlement>[]>;
        /**
         * Unbound networks
         */
        networks?: pulumi.Input<pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsBindItemNetwork>[]>;
        /**
         * Subscription ID
         */
        subscriptionId?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsBindItemInsufficientEntitlement {
        /**
         * Number required
         */
        quantity?: pulumi.Input<number>;
        /**
         * SKU of the required product
         */
        sku?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsBindItemNetwork {
        /**
         * Network ID
         */
        id?: pulumi.Input<string>;
        /**
         * Network name
         */
        name?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsBindParameters {
        /**
         * List of network ids to bind to the subscription
         */
        networkIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItem {
        /**
         * Numeric breakdown of network and entitlement counts
         */
        counts?: pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimItemCounts>;
        /**
         * Subscription description
         */
        description?: pulumi.Input<string>;
        /**
         * Subscription expiration date
         */
        endDate?: pulumi.Input<string>;
        /**
         * Entitlement info
         */
        entitlements?: pulumi.Input<pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimItemEntitlement>[]>;
        /**
         * Subscription name
         */
        name?: pulumi.Input<string>;
        /**
         * Products the subscription has entitlements for
         */
        productTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Subscription start date
         */
        startDate?: pulumi.Input<string>;
        /**
         * Subscription status
         */
        status?: pulumi.Input<string>;
        /**
         * Subscription's ID
         */
        subscriptionId?: pulumi.Input<string>;
        /**
         * Web order id
         */
        webOrderId?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemCounts {
        /**
         * Number of networks bound to this subscription
         */
        networks?: pulumi.Input<number>;
        /**
         * Seat distribution
         */
        seats?: pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimItemCountsSeats>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemCountsSeats {
        /**
         * Number of seats in use
         */
        assigned?: pulumi.Input<number>;
        /**
         * Number of seats available for use
         */
        available?: pulumi.Input<number>;
        /**
         * Total number of seats provided by this subscription
         */
        limit?: pulumi.Input<number>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemEntitlement {
        /**
         * Seat distribution
         */
        seats?: pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimItemEntitlementSeats>;
        /**
         * SKU of the required product
         */
        sku?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemEntitlementSeats {
        /**
         * Number of seats in use
         */
        assigned?: pulumi.Input<number>;
        /**
         * Number of seats available for use
         */
        available?: pulumi.Input<number>;
        /**
         * Total number of seats provided by this subscription for this sku
         */
        limit?: pulumi.Input<number>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItem {
        /**
         * Numeric breakdown of network and entitlement counts
         */
        counts?: pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemCounts>;
        /**
         * Subscription description
         */
        description?: pulumi.Input<string>;
        /**
         * Subscription expiration date
         */
        endDate?: pulumi.Input<string>;
        /**
         * Entitlement info
         */
        entitlements?: pulumi.Input<pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlement>[]>;
        /**
         * Subscription name
         */
        name?: pulumi.Input<string>;
        /**
         * Products the subscription has entitlements for
         */
        productTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Subscription start date
         */
        startDate?: pulumi.Input<string>;
        /**
         * Subscription status
         */
        status?: pulumi.Input<string>;
        /**
         * Subscription's ID
         */
        subscriptionId?: pulumi.Input<string>;
        /**
         * Web order id
         */
        webOrderId?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemCounts {
        /**
         * Number of networks bound to this subscription
         */
        networks?: pulumi.Input<number>;
        /**
         * Seat distribution
         */
        seats?: pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemCountsSeats>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemCountsSeats {
        /**
         * Number of seats in use
         */
        assigned?: pulumi.Input<number>;
        /**
         * Number of seats available for use
         */
        available?: pulumi.Input<number>;
        /**
         * Total number of seats provided by this subscription
         */
        limit?: pulumi.Input<number>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlement {
        /**
         * Seat distribution
         */
        seats?: pulumi.Input<inputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlementSeats>;
        /**
         * SKU of the required product
         */
        sku?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlementSeats {
        /**
         * Number of seats in use
         */
        assigned?: pulumi.Input<number>;
        /**
         * Number of seats available for use
         */
        available?: pulumi.Input<number>;
        /**
         * Total number of seats provided by this subscription for this sku
         */
        limit?: pulumi.Input<number>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateParameters {
        /**
         * The subscription's claim key
         */
        claimKey?: pulumi.Input<string>;
    }

    export interface LicensingSubscriptionSubscriptionsClaimParameters {
        /**
         * The subscription's claim key
         */
        claimKey?: pulumi.Input<string>;
        /**
         * Extra details or notes about the subscription
         */
        description?: pulumi.Input<string>;
        /**
         * Friendly name to identify the subscription
         */
        name?: pulumi.Input<string>;
        /**
         * The id of the organization claiming the subscription
         */
        organizationId?: pulumi.Input<string>;
    }
}

export namespace devices {
    export interface ApplianceRadioSettingsFiveGhzSettings {
        /**
         * Manual channel for 5 GHz
         */
        channel?: pulumi.Input<number>;
        /**
         * Manual channel width for 5 GHz
         */
        channelWidth?: pulumi.Input<number>;
        /**
         * Manual target power for 5 GHz
         */
        targetPower?: pulumi.Input<number>;
    }

    export interface ApplianceRadioSettingsTwoFourGhzSettings {
        /**
         * Manual channel for 2.4 GHz
         */
        channel?: pulumi.Input<number>;
        /**
         * Manual target power for 2.4 GHz
         */
        targetPower?: pulumi.Input<number>;
    }

    export interface ApplianceUplinksSettingsInterfaces {
        /**
         * WAN 1 settings.
         */
        wan1?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1>;
        /**
         * WAN 2 settings.
         */
        wan2?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1 {
        /**
         * Enable or disable the interface.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Configuration options for PPPoE.
         */
        pppoe?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1Pppoe>;
        /**
         * SVI settings by protocol.
         */
        svis?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1Svis>;
        /**
         * VLAN tagging settings.
         */
        vlanTagging?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1VlanTagging>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1Pppoe {
        /**
         * Settings for PPPoE Authentication.
         */
        authentication?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1PppoeAuthentication>;
        /**
         * Whether PPPoE is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1PppoeAuthentication {
        /**
         * Whether PPPoE authentication is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Password for PPPoE authentication. This parameter is not returned.
         */
        password?: pulumi.Input<string>;
        /**
         * Username for PPPoE authentication.
         */
        username?: pulumi.Input<string>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1Svis {
        /**
         * IPv4 settings for static/dynamic mode.
         */
        ipv4?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv4>;
        /**
         * IPv6 settings for static/dynamic mode.
         */
        ipv6?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv6>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv4 {
        /**
         * IP address and subnet mask when in static mode.
         */
        address?: pulumi.Input<string>;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * Gateway IP address when in static mode.
         */
        gateway?: pulumi.Input<string>;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv4Nameservers>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv4Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv6 {
        /**
         * Static address that will override the one(s) received by SLAAC.
         */
        address?: pulumi.Input<string>;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * Static gateway that will override the one received by autoconf.
         */
        gateway?: pulumi.Input<string>;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv6Nameservers>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv6Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1VlanTagging {
        /**
         * Whether VLAN tagging is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The ID of the VLAN to use for VLAN tagging.
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2 {
        /**
         * Enable or disable the interface.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Configuration options for PPPoE.
         */
        pppoe?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2Pppoe>;
        /**
         * SVI settings by protocol.
         */
        svis?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2Svis>;
        /**
         * VLAN tagging settings.
         */
        vlanTagging?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2VlanTagging>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2Pppoe {
        /**
         * Settings for PPPoE Authentication.
         */
        authentication?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2PppoeAuthentication>;
        /**
         * Whether PPPoE is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2PppoeAuthentication {
        /**
         * Whether PPPoE authentication is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Password for PPPoE authentication. This parameter is not returned.
         */
        password?: pulumi.Input<string>;
        /**
         * Username for PPPoE authentication.
         */
        username?: pulumi.Input<string>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2Svis {
        /**
         * IPv4 settings for static/dynamic mode.
         */
        ipv4?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv4>;
        /**
         * IPv6 settings for static/dynamic mode.
         */
        ipv6?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv6>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv4 {
        /**
         * IP address and subnet mask when in static mode.
         */
        address?: pulumi.Input<string>;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * Gateway IP address when in static mode.
         */
        gateway?: pulumi.Input<string>;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv4Nameservers>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv4Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv6 {
        /**
         * Static address that will override the one(s) received by SLAAC.
         */
        address?: pulumi.Input<string>;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * Static gateway that will override the one received by autoconf.
         */
        gateway?: pulumi.Input<string>;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers?: pulumi.Input<inputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv6Nameservers>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv6Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2VlanTagging {
        /**
         * Whether VLAN tagging is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The ID of the VLAN to use for VLAN tagging.
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface ApplianceVmxAuthenticationTokenItem {
        /**
         * The expiration time for the token, in ISO 8601 format
         */
        expiresAt?: pulumi.Input<string>;
        /**
         * The newly generated authentication token for the vMX instance
         */
        token?: pulumi.Input<string>;
    }

    export interface BaseDetail {
        /**
         * Additional property name
         */
        name?: pulumi.Input<string>;
        /**
         * Additional property value
         */
        value?: pulumi.Input<string>;
    }

    export interface BlinkLedsItem {
        /**
         * The duration in seconds. Will be between 5 and 120. Default is 20 seconds
         */
        duration?: pulumi.Input<number>;
        /**
         * The duty cycle as the percent active. Will be between 10 and 90. Default is 50
         */
        duty?: pulumi.Input<number>;
        /**
         * The period in milliseconds. Will be between 100 and 1000. Default is 160 milliseconds
         */
        period?: pulumi.Input<number>;
    }

    export interface BlinkLedsParameters {
        /**
         * The duration in seconds. Must be between 5 and 120. Default is 20 seconds
         */
        duration?: pulumi.Input<number>;
        /**
         * The duty cycle as the percent active. Must be between 10 and 90. Default is 50.
         */
        duty?: pulumi.Input<number>;
        /**
         * The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds
         */
        period?: pulumi.Input<number>;
    }

    export interface CameraCustomAnalyticsParameter {
        /**
         * Name of the parameter
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the parameter
         */
        value?: pulumi.Input<number>;
    }

    export interface CameraGenerateSnapshotParameters {
        /**
         * [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
         */
        fullframe?: pulumi.Input<boolean>;
        /**
         * [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
         */
        timestamp?: pulumi.Input<string>;
    }

    export interface CameraSenseAudioDetection {
        /**
         * Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface CameraWirelessProfilesIds {
        /**
         * The id of the backup wireless profile
         */
        backup?: pulumi.Input<string>;
        /**
         * The id of the primary wireless profile
         */
        primary?: pulumi.Input<string>;
        /**
         * The id of the secondary wireless profile
         */
        secondary?: pulumi.Input<string>;
    }

    export interface CellularGatewayLanFixedIpAssignment {
        /**
         * The IP address you want to assign to a specific server or device
         */
        ip?: pulumi.Input<string>;
        /**
         * The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
         */
        mac?: pulumi.Input<string>;
        /**
         * A descriptive name of the assignment
         */
        name?: pulumi.Input<string>;
    }

    export interface CellularGatewayLanReservedIpRange {
        /**
         * Comment explaining the reserved IP range
         */
        comment?: pulumi.Input<string>;
        /**
         * Ending IP included in the reserved range of IPs
         */
        end?: pulumi.Input<string>;
        /**
         * Starting IP included in the reserved range of IPs
         */
        start?: pulumi.Input<string>;
    }

    export interface CellularGatewayPortForwardingRulesRule {
        /**
         * *any* or *restricted*. Specify the right to make inbound connections on the specified ports or port ranges. If *restricted*, a list of allowed IPs is mandatory.
         */
        access?: pulumi.Input<string>;
        /**
         * An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.
         */
        allowedIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
         */
        lanIp?: pulumi.Input<string>;
        /**
         * A port or port ranges that will receive the forwarded traffic from the WAN
         */
        localPort?: pulumi.Input<string>;
        /**
         * A descriptive name for the rule
         */
        name?: pulumi.Input<string>;
        /**
         * TCP or UDP
         */
        protocol?: pulumi.Input<string>;
        /**
         * A port or port ranges that will be forwarded to the host on the LAN
         */
        publicPort?: pulumi.Input<string>;
        uplink?: pulumi.Input<string>;
    }

    export interface CellularSimsSim {
        /**
         * APN configurations. If empty, the default APN will be used.
         */
        apns?: pulumi.Input<pulumi.Input<inputs.devices.CellularSimsSimApn>[]>;
        /**
         * If true, this SIM is used for boot. Must be true on single-sim devices.
         */
        isPrimary?: pulumi.Input<boolean>;
        /**
         * SIM slot being configured. Must be 'sim1' on single-sim devices.
         */
        slot?: pulumi.Input<string>;
    }

    export interface CellularSimsSimApn {
        /**
         * IP versions to support (permitted values include 'ipv4', 'ipv6').
         */
        allowedIpTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * APN authentication configurations.
         */
        authentication?: pulumi.Input<inputs.devices.CellularSimsSimApnAuthentication>;
        /**
         * APN name.
         */
        name?: pulumi.Input<string>;
    }

    export interface CellularSimsSimApnAuthentication {
        /**
         * APN password, if type is set (if APN password is not supplied, the password is left unchanged).
         */
        password?: pulumi.Input<string>;
        /**
         * APN auth type.
         */
        type?: pulumi.Input<string>;
        /**
         * APN username, if type is set.
         */
        username?: pulumi.Input<string>;
    }

    export interface CellularSimsSimFailover {
        /**
         * Failover to secondary SIM (optional)
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Failover timeout in seconds (optional)
         */
        timeout?: pulumi.Input<number>;
    }

    export interface LiveToolsArpTableCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer?: pulumi.Input<inputs.devices.LiveToolsArpTableCallbackHttpServer>;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate?: pulumi.Input<inputs.devices.LiveToolsArpTableCallbackPayloadTemplate>;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsArpTableCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsArpTableCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsArpTableEntry {
        /**
         * The IP address of the ARP table entry
         */
        ip?: pulumi.Input<string>;
        /**
         * Time of the last update of the ARP table entry
         */
        lastUpdatedAt?: pulumi.Input<string>;
        /**
         * The MAC address of the ARP table entry
         */
        mac?: pulumi.Input<string>;
        /**
         * The VLAN ID of the ARP table entry
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface LiveToolsArpTableRequest {
        /**
         * Device serial number
         */
        serial?: pulumi.Input<string>;
    }

    export interface LiveToolsCableCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer?: pulumi.Input<inputs.devices.LiveToolsCableCallbackHttpServer>;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate?: pulumi.Input<inputs.devices.LiveToolsCableCallbackPayloadTemplate>;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsCableCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsCableCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsCableRequest {
        /**
         * A list of ports for which to perform the cable test.
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Device serial number
         */
        serial?: pulumi.Input<string>;
    }

    export interface LiveToolsCableResult {
        /**
         * If an error occurred during the cable test, the error message will be populated here.
         */
        error?: pulumi.Input<string>;
        /**
         * Results for each twisted pair within the cable.
         */
        pairs?: pulumi.Input<pulumi.Input<inputs.devices.LiveToolsCableResultPair>[]>;
        /**
         * The port for which the test was performed.
         */
        port?: pulumi.Input<string>;
        /**
         * Speed in Mbps.  A speed of 0 indicates the port is down or the port speed is automatic.
         */
        speedMbps?: pulumi.Input<number>;
        /**
         * The current status of the port. If the cable test is still being performed on the port, "in-progress" is used. If an error occurred during the cable test, "error" is used and the error property will be populated.
         */
        status?: pulumi.Input<string>;
    }

    export interface LiveToolsCableResultPair {
        /**
         * The index of the twisted pair tested.
         */
        index?: pulumi.Input<number>;
        /**
         * The detected length of the twisted pair.
         */
        lengthMeters?: pulumi.Input<number>;
        /**
         * The test result of the twisted pair tested.
         */
        status?: pulumi.Input<string>;
    }

    export interface LiveToolsPingDeviceItem {
        /**
         * Information for callback used to send back results
         */
        callback?: pulumi.Input<inputs.devices.LiveToolsPingDeviceItemCallback>;
        /**
         * Id to check the status of your ping request.
         */
        pingId?: pulumi.Input<string>;
        /**
         * Ping request parameters
         */
        request?: pulumi.Input<inputs.devices.LiveToolsPingDeviceItemRequest>;
        /**
         * Status of the ping request.
         */
        status?: pulumi.Input<string>;
        /**
         * GET this url to check the status of your ping request.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsPingDeviceItemCallback {
        /**
         * The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
         */
        id?: pulumi.Input<string>;
        /**
         * The status of the callback
         */
        status?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsPingDeviceItemRequest {
        /**
         * Number of pings to send
         */
        count?: pulumi.Input<number>;
        /**
         * Device serial number
         */
        serial?: pulumi.Input<string>;
        /**
         * IP address or FQDN to ping
         */
        target?: pulumi.Input<string>;
    }

    export interface LiveToolsPingDeviceParameters {
        /**
         * Details for the callback. Please include either an httpServerId OR url and sharedSecret
         */
        callback?: pulumi.Input<inputs.devices.LiveToolsPingDeviceParametersCallback>;
        /**
         * Count parameter to pass to ping. [1..5], default 5
         */
        count?: pulumi.Input<number>;
    }

    export interface LiveToolsPingDeviceParametersCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer?: pulumi.Input<inputs.devices.LiveToolsPingDeviceParametersCallbackHttpServer>;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate?: pulumi.Input<inputs.devices.LiveToolsPingDeviceParametersCallbackPayloadTemplate>;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsPingDeviceParametersCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsPingDeviceParametersCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsPingItem {
        /**
         * Information for callback used to send back results
         */
        callback?: pulumi.Input<inputs.devices.LiveToolsPingItemCallback>;
        /**
         * Id to check the status of your ping request.
         */
        pingId?: pulumi.Input<string>;
        /**
         * Ping request parameters
         */
        request?: pulumi.Input<inputs.devices.LiveToolsPingItemRequest>;
        /**
         * Status of the ping request.
         */
        status?: pulumi.Input<string>;
        /**
         * GET this url to check the status of your ping request.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsPingItemCallback {
        /**
         * The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
         */
        id?: pulumi.Input<string>;
        /**
         * The status of the callback
         */
        status?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsPingItemRequest {
        /**
         * Number of pings to send
         */
        count?: pulumi.Input<number>;
        /**
         * Device serial number
         */
        serial?: pulumi.Input<string>;
        /**
         * IP address or FQDN to ping
         */
        target?: pulumi.Input<string>;
    }

    export interface LiveToolsPingParameters {
        /**
         * Details for the callback. Please include either an httpServerId OR url and sharedSecret
         */
        callback?: pulumi.Input<inputs.devices.LiveToolsPingParametersCallback>;
        /**
         * Count parameter to pass to ping. [1..5], default 5
         */
        count?: pulumi.Input<number>;
        /**
         * FQDN, IPv4 or IPv6 address
         */
        target?: pulumi.Input<string>;
    }

    export interface LiveToolsPingParametersCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer?: pulumi.Input<inputs.devices.LiveToolsPingParametersCallbackHttpServer>;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate?: pulumi.Input<inputs.devices.LiveToolsPingParametersCallbackPayloadTemplate>;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsPingParametersCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsPingParametersCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsThroughputTestCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer?: pulumi.Input<inputs.devices.LiveToolsThroughputTestCallbackHttpServer>;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate?: pulumi.Input<inputs.devices.LiveToolsThroughputTestCallbackPayloadTemplate>;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsThroughputTestCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsThroughputTestCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsThroughputTestRequest {
        /**
         * Device serial number
         */
        serial?: pulumi.Input<string>;
    }

    export interface LiveToolsThroughputTestResult {
        /**
         * Shows the speeds (Mbps)
         */
        speeds?: pulumi.Input<inputs.devices.LiveToolsThroughputTestResultSpeeds>;
    }

    export interface LiveToolsThroughputTestResultSpeeds {
        /**
         * Shows the download speed from shard (Mbps)
         */
        downstream?: pulumi.Input<number>;
    }

    export interface LiveToolsWakeOnLanCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer?: pulumi.Input<inputs.devices.LiveToolsWakeOnLanCallbackHttpServer>;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate?: pulumi.Input<inputs.devices.LiveToolsWakeOnLanCallbackPayloadTemplate>;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url?: pulumi.Input<string>;
    }

    export interface LiveToolsWakeOnLanCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsWakeOnLanCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id?: pulumi.Input<string>;
    }

    export interface LiveToolsWakeOnLanRequest {
        /**
         * The target's MAC address
         */
        mac?: pulumi.Input<string>;
        /**
         * Device serial number
         */
        serial?: pulumi.Input<string>;
        /**
         * The target's VLAN (1 to 4094)
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface ManagementInterfaceDdnsHostnames {
        /**
         * Active dynamic DNS hostname.
         */
        activeDdnsHostname?: pulumi.Input<string>;
        /**
         * WAN 1 dynamic DNS hostname.
         */
        ddnsHostnameWan1?: pulumi.Input<string>;
        /**
         * WAN 2 dynamic DNS hostname.
         */
        ddnsHostnameWan2?: pulumi.Input<string>;
    }

    export interface ManagementInterfaceWan1 {
        /**
         * Up to two DNS IPs.
         */
        staticDns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP of the gateway on the WAN.
         */
        staticGatewayIp?: pulumi.Input<string>;
        /**
         * The IP the device should use on the WAN.
         */
        staticIp?: pulumi.Input<string>;
        /**
         * The subnet mask for the WAN.
         */
        staticSubnetMask?: pulumi.Input<string>;
        /**
         * Configure the interface to have static IP settings or use DHCP.
         */
        usingStaticIp?: pulumi.Input<boolean>;
        /**
         * The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
         */
        vlan?: pulumi.Input<number>;
        /**
         * Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
         */
        wanEnabled?: pulumi.Input<string>;
    }

    export interface ManagementInterfaceWan2 {
        /**
         * Up to two DNS IPs.
         */
        staticDns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP of the gateway on the WAN.
         */
        staticGatewayIp?: pulumi.Input<string>;
        /**
         * The IP the device should use on the WAN.
         */
        staticIp?: pulumi.Input<string>;
        /**
         * The subnet mask for the WAN.
         */
        staticSubnetMask?: pulumi.Input<string>;
        /**
         * Configure the interface to have static IP settings or use DHCP.
         */
        usingStaticIp?: pulumi.Input<boolean>;
        /**
         * The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
         */
        vlan?: pulumi.Input<number>;
        /**
         * Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
         */
        wanEnabled?: pulumi.Input<string>;
    }

    export interface SensorRelationshipsLivestream {
        /**
         * An array of the related devices for the role
         */
        relatedDevices?: pulumi.Input<pulumi.Input<inputs.devices.SensorRelationshipsLivestreamRelatedDevice>[]>;
    }

    export interface SensorRelationshipsLivestreamRelatedDevice {
        /**
         * The product type of the related device
         */
        productType?: pulumi.Input<string>;
        /**
         * The serial of the related device
         */
        serial?: pulumi.Input<string>;
    }

    export interface SensorRelationshipsLivestreamRequest {
        /**
         * An array of the related devices for the role
         */
        relatedDevices?: pulumi.Input<pulumi.Input<inputs.devices.SensorRelationshipsLivestreamRequestRelatedDevice>[]>;
    }

    export interface SensorRelationshipsLivestreamRequestRelatedDevice {
        /**
         * The product type of the related device
         */
        productType?: pulumi.Input<string>;
        /**
         * The serial of the related device
         */
        serial?: pulumi.Input<string>;
    }

    export interface SwitchPortsCycleItem {
        /**
         * List of switch ports
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchPortsCycleParameters {
        /**
         * List of switch ports
         */
        ports?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchPortsMirror {
        /**
         * The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
         */
        mode?: pulumi.Input<string>;
    }

    export interface SwitchPortsModule {
        /**
         * The model of the expansion module.
         */
        model?: pulumi.Input<string>;
    }

    export interface SwitchPortsProfile {
        /**
         * When enabled, override this port's configuration with a port profile.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * When enabled, the ID of the port profile used to override the port's configuration.
         */
        id?: pulumi.Input<string>;
        /**
         * When enabled, the IName of the profile.
         */
        iname?: pulumi.Input<string>;
    }

    export interface SwitchRoutingInterfacesDhcpDhcpOption {
        /**
         * The code for DHCP option which should be from 2 to 254
         */
        code?: pulumi.Input<string>;
        /**
         * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
         */
        type?: pulumi.Input<string>;
        /**
         * The value of the DHCP option
         */
        value?: pulumi.Input<string>;
    }

    export interface SwitchRoutingInterfacesDhcpFixedIpAssignment {
        /**
         * The IP address of the client which has fixed IP address assigned to it
         */
        ip?: pulumi.Input<string>;
        /**
         * The MAC address of the client which has fixed IP address
         */
        mac?: pulumi.Input<string>;
        /**
         * The name of the client which has fixed IP address
         */
        name?: pulumi.Input<string>;
    }

    export interface SwitchRoutingInterfacesDhcpReservedIpRange {
        /**
         * The comment for the reserved IP range
         */
        comment?: pulumi.Input<string>;
        /**
         * The ending IP address of the reserved IP range
         */
        end?: pulumi.Input<string>;
        /**
         * The starting IP address of the reserved IP range
         */
        start?: pulumi.Input<string>;
    }

    export interface SwitchRoutingInterfacesIpv6 {
        /**
         * IPv6 address
         */
        address?: pulumi.Input<string>;
        /**
         * Assignment mode
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * IPv6 gateway
         */
        gateway?: pulumi.Input<string>;
        /**
         * IPv6 subnet
         */
        prefix?: pulumi.Input<string>;
    }

    export interface SwitchRoutingInterfacesOspfSettings {
        /**
         * Area id
         */
        area?: pulumi.Input<string>;
        /**
         * OSPF Cost
         */
        cost?: pulumi.Input<number>;
        /**
         * Disable sending Hello packets on this interface's IPv4 area
         */
        isPassiveEnabled?: pulumi.Input<boolean>;
    }

    export interface SwitchRoutingInterfacesOspfV3 {
        /**
         * Area id
         */
        area?: pulumi.Input<string>;
        /**
         * OSPF Cost
         */
        cost?: pulumi.Input<number>;
        /**
         * Disable sending Hello packets on this interface's IPv6 area
         */
        isPassiveEnabled?: pulumi.Input<boolean>;
    }

    export interface WirelessAlternateManagementInterfaceIpv6Item {
        /**
         * configured alternate management interface addresses
         */
        addresses?: pulumi.Input<pulumi.Input<inputs.devices.WirelessAlternateManagementInterfaceIpv6ItemAddress>[]>;
    }

    export interface WirelessAlternateManagementInterfaceIpv6ItemAddress {
        /**
         * The IP address configured for the alternate management interface
         */
        address?: pulumi.Input<string>;
        /**
         * The type of address assignment. Either static or dynamic.
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * The gateway address configured for the alternate managment interface
         */
        gateway?: pulumi.Input<string>;
        /**
         * The DNS servers settings for this address.
         */
        nameservers?: pulumi.Input<inputs.devices.WirelessAlternateManagementInterfaceIpv6ItemAddressNameservers>;
        /**
         * The IPv6 prefix of the interface. Required if IPv6 object is included.
         */
        prefix?: pulumi.Input<string>;
        /**
         * The IP protocol used for the address
         */
        protocol?: pulumi.Input<string>;
    }

    export interface WirelessAlternateManagementInterfaceIpv6ItemAddressNameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessAlternateManagementInterfaceIpv6Parameters {
        /**
         * configured alternate management interface addresses
         */
        addresses?: pulumi.Input<pulumi.Input<inputs.devices.WirelessAlternateManagementInterfaceIpv6ParametersAddress>[]>;
    }

    export interface WirelessAlternateManagementInterfaceIpv6ParametersAddress {
        /**
         * The IP address configured for the alternate management interface
         */
        address?: pulumi.Input<string>;
        /**
         * The type of address assignment. Either static or dynamic.
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * The gateway address configured for the alternate managment interface
         */
        gateway?: pulumi.Input<string>;
        /**
         * The DNS servers settings for this address.
         */
        nameservers?: pulumi.Input<inputs.devices.WirelessAlternateManagementInterfaceIpv6ParametersAddressNameservers>;
        /**
         * The IPv6 prefix length of the IPv6 interface. Required if IPv6 object is included.
         */
        prefix?: pulumi.Input<string>;
        /**
         * The IP protocol used for the address
         */
        protocol?: pulumi.Input<string>;
    }

    export interface WirelessAlternateManagementInterfaceIpv6ParametersAddressNameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRadioSettingsFiveGhzSettings {
        /**
         * Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel.
         */
        channel?: pulumi.Input<number>;
        /**
         * Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width.
         */
        channelWidth?: pulumi.Input<number>;
        /**
         * Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range.
         */
        targetPower?: pulumi.Input<number>;
    }

    export interface WirelessRadioSettingsTwoFourGhzSettings {
        /**
         * Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel.
         */
        channel?: pulumi.Input<number>;
        /**
         * Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range.
         */
        targetPower?: pulumi.Input<number>;
    }
}

export namespace networks {
    export interface AlertsSettingsAlert {
        /**
         * A hash of destinations for this specific alert
         */
        alertDestinations?: pulumi.Input<inputs.networks.AlertsSettingsAlertAlertDestinations>;
        /**
         * A boolean depicting if the alert is turned on or off
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
         */
        filters?: pulumi.Input<inputs.networks.AlertsSettingsAlertFilters>;
        /**
         * The type of alert
         */
        type?: pulumi.Input<string>;
    }

    export interface AlertsSettingsAlertAlertDestinations {
        /**
         * If true, then all network admins will receive emails for this alert
         */
        allAdmins?: pulumi.Input<boolean>;
        /**
         * A list of emails that will receive information about the alert
         */
        emails?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of HTTP server IDs to send a Webhook to for this alert
         */
        httpServerIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
         */
        snmp?: pulumi.Input<boolean>;
    }

    export interface AlertsSettingsAlertFilters {
        period?: pulumi.Input<number>;
        threshold?: pulumi.Input<number>;
        timeout?: pulumi.Input<number>;
    }

    export interface AlertsSettingsAlertsResponse {
        /**
         * A hash of destinations for this specific alert
         */
        alertDestinations?: pulumi.Input<inputs.networks.AlertsSettingsAlertsResponseAlertDestinations>;
        /**
         * A boolean depicting if the alert is turned on or off
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
         */
        filters?: pulumi.Input<inputs.networks.AlertsSettingsAlertsResponseFilters>;
        /**
         * The type of alert
         */
        type?: pulumi.Input<string>;
    }

    export interface AlertsSettingsAlertsResponseAlertDestinations {
        /**
         * If true, then all network admins will receive emails for this alert
         */
        allAdmins?: pulumi.Input<boolean>;
        /**
         * A list of emails that will receive information about the alert
         */
        emails?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of HTTP server IDs to send a Webhook to for this alert
         */
        httpServerIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
         */
        snmp?: pulumi.Input<boolean>;
    }

    export interface AlertsSettingsAlertsResponseFilters {
        period?: pulumi.Input<number>;
        threshold?: pulumi.Input<number>;
        timeout?: pulumi.Input<number>;
    }

    export interface AlertsSettingsDefaultDestinations {
        /**
         * If true, then all network admins will receive emails.
         */
        allAdmins?: pulumi.Input<boolean>;
        /**
         * A list of emails that will receive the alert(s).
         */
        emails?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of HTTP server IDs to send a Webhook to
         */
        httpServerIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
         */
        snmp?: pulumi.Input<boolean>;
    }

    export interface AlertsSettingsMuting {
        /**
         * by_port_schedules
         */
        byPortSchedules?: pulumi.Input<inputs.networks.AlertsSettingsMutingByPortSchedules>;
    }

    export interface AlertsSettingsMutingByPortSchedules {
        /**
         * enabled
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceConnectivityMonitoringDestinationsDestination {
        /**
         * Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
         */
        default?: pulumi.Input<boolean>;
        /**
         * Description of the testing destination. Optional, defaults to null
         */
        description?: pulumi.Input<string>;
        /**
         * The IP address to test connectivity with
         */
        ip?: pulumi.Input<string>;
    }

    export interface ApplianceContentFilteringBlockedUrlCategoriesResponse {
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallCellularFirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: pulumi.Input<string>;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceFirewallInboundFirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: pulumi.Input<string>;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceFirewallInboundFirewallRulesRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: pulumi.Input<string>;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceFirewallL3FirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: pulumi.Input<string>;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceFirewallL3FirewallRulesRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: pulumi.Input<string>;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceFirewallL7FirewallRulesRule {
        /**
         * 'Deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
         */
        type?: pulumi.Input<string>;
        /**
         * The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. Send a string to request.
         */
        value?: pulumi.Input<string>;
        /**
         * The 'value_list' of what you want to block. Send a lis of string in request.
         */
        valueLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The 'value_obj' of what you want to block. Send a dict in request.
         */
        valueObj?: pulumi.Input<inputs.networks.ApplianceFirewallL7FirewallRulesRuleValueObj>;
    }

    export interface ApplianceFirewallL7FirewallRulesRuleValueObj {
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallL7FirewallRulesRulesResponse {
        /**
         * 'Deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
         */
        type?: pulumi.Input<string>;
        /**
         * The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
         */
        value?: pulumi.Input<string>;
        /**
         * The 'value_list' of what you want to block. Send a list in request
         */
        valueLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The 'value_obj' of what you want to block. Send a dict in request
         */
        valueObj?: pulumi.Input<inputs.networks.ApplianceFirewallL7FirewallRulesRulesResponseValueObj>;
    }

    export interface ApplianceFirewallL7FirewallRulesRulesResponseValueObj {
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallOneToManyNatRulesRule {
        /**
         * An array of associated forwarding rules
         */
        portRules?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceFirewallOneToManyNatRulesRulePortRule>[]>;
        /**
         * The IP address that will be used to access the internal resource from the WAN
         */
        publicIp?: pulumi.Input<string>;
        /**
         * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
         */
        uplink?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallOneToManyNatRulesRulePortRule {
        /**
         * Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
         */
        allowedIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Local IP address to which traffic will be forwarded
         */
        localIp?: pulumi.Input<string>;
        /**
         * Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
         */
        localPort?: pulumi.Input<string>;
        /**
         * A description of the rule
         */
        name?: pulumi.Input<string>;
        /**
         * 'tcp' or 'udp'
         */
        protocol?: pulumi.Input<string>;
        /**
         * Destination port of the traffic that is arriving on the WAN
         */
        publicPort?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallOneToOneNatRulesRule {
        /**
         * The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
         */
        allowedInbounds?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceFirewallOneToOneNatRulesRuleAllowedInbound>[]>;
        /**
         * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
         */
        lanIp?: pulumi.Input<string>;
        /**
         * A descriptive name for the rule
         */
        name?: pulumi.Input<string>;
        /**
         * The IP address that will be used to access the internal resource from the WAN
         */
        publicIp?: pulumi.Input<string>;
        /**
         * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
         */
        uplink?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallOneToOneNatRulesRuleAllowedInbound {
        /**
         * An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
         */
        allowedIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An array of ports or port ranges that will be forwarded to the host on the LAN
         */
        destinationPorts?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
         */
        protocol?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallPortForwardingRulesRule {
        /**
         * An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
         */
        allowedIps?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
         */
        lanIp?: pulumi.Input<string>;
        /**
         * A port or port ranges that will receive the forwarded traffic from the WAN
         */
        localPort?: pulumi.Input<string>;
        /**
         * A descriptive name for the rule
         */
        name?: pulumi.Input<string>;
        /**
         * TCP or UDP
         */
        protocol?: pulumi.Input<string>;
        /**
         * A port or port ranges that will be forwarded to the host on the LAN
         */
        publicPort?: pulumi.Input<string>;
        /**
         * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
         */
        uplink?: pulumi.Input<string>;
    }

    export interface ApplianceFirewallSettingsSpoofingProtection {
        /**
         * IP source address spoofing settings
         */
        ipSourceGuard?: pulumi.Input<inputs.networks.ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard>;
    }

    export interface ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard {
        /**
         * Mode of protection
         */
        mode?: pulumi.Input<string>;
    }

    export interface AppliancePrefixesDelegatedStaticsOrigin {
        /**
         * Uplink provided or independent
         */
        interfaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Origin type
         */
        type?: pulumi.Input<string>;
    }

    export interface ApplianceRfProfilesFiveGhzSettings {
        /**
         * Whether ax radio on 5Ghz band is on or off.
         */
        axEnabled?: pulumi.Input<boolean>;
        /**
         * Min bitrate (Mbps) of 2.4Ghz band.
         */
        minBitrate?: pulumi.Input<number>;
    }

    export interface ApplianceRfProfilesPerSsidSettings {
        /**
         * Settings for SSID 1.
         */
        status1?: pulumi.Input<inputs.networks.ApplianceRfProfilesPerSsidSettingsStatus1>;
        /**
         * Settings for SSID 2.
         */
        status2?: pulumi.Input<inputs.networks.ApplianceRfProfilesPerSsidSettingsStatus2>;
        /**
         * Settings for SSID 3.
         */
        status3?: pulumi.Input<inputs.networks.ApplianceRfProfilesPerSsidSettingsStatus3>;
        /**
         * Settings for SSID 4.
         */
        status4?: pulumi.Input<inputs.networks.ApplianceRfProfilesPerSsidSettingsStatus4>;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus1 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus2 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus3 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus4 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceRfProfilesTwoFourGhzSettings {
        /**
         * Whether ax radio on 2.4Ghz band is on or off.
         */
        axEnabled?: pulumi.Input<boolean>;
        /**
         * Min bitrate (Mbps) of 2.4Ghz band.
         */
        minBitrate?: pulumi.Input<number>;
    }

    export interface ApplianceSecurityIntrusionProtectedNetworks {
        /**
         * List of IP addresses or subnets being excluded from protection
         */
        excludedCidrs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of IP addresses or subnets being protected
         */
        includedCidrs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether special IPv4 addresses should be used (see: https://tools.ietf.org/html/rfc5735)
         */
        useDefault?: pulumi.Input<boolean>;
    }

    export interface ApplianceSecurityMalwareAllowedFile {
        /**
         * Comment about the allowed file
         */
        comment?: pulumi.Input<string>;
        /**
         * The sha256 digest of allowed file
         */
        sha256?: pulumi.Input<string>;
    }

    export interface ApplianceSecurityMalwareAllowedUrl {
        /**
         * Comment about the allowed URL
         */
        comment?: pulumi.Input<string>;
        /**
         * The allowed URL
         */
        url?: pulumi.Input<string>;
    }

    export interface ApplianceSettingsDynamicDns {
        /**
         * Dynamic DNS enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Dynamic DNS url prefix. DDNS must be enabled to update
         */
        prefix?: pulumi.Input<string>;
        /**
         * Dynamic DNS url. DDNS must be enabled to update
         */
        url?: pulumi.Input<string>;
    }

    export interface ApplianceSingleLanIpv6 {
        /**
         * Enable IPv6 on single LAN
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Prefix assignments on the single LAN
         */
        prefixAssignments?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceSingleLanIpv6PrefixAssignment>[]>;
    }

    export interface ApplianceSingleLanIpv6PrefixAssignment {
        /**
         * Auto assign a /64 prefix from the origin to the single LAN
         */
        autonomous?: pulumi.Input<boolean>;
        /**
         * The origin of the prefix
         */
        origin?: pulumi.Input<inputs.networks.ApplianceSingleLanIpv6PrefixAssignmentOrigin>;
        /**
         * Manual configuration of the IPv6 Appliance IP
         */
        staticApplianceIp6?: pulumi.Input<string>;
        /**
         * Manual configuration of a /64 prefix on the single LAN
         */
        staticPrefix?: pulumi.Input<string>;
    }

    export interface ApplianceSingleLanIpv6PrefixAssignmentOrigin {
        /**
         * Interfaces associated with the prefix
         */
        interfaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of the origin
         */
        type?: pulumi.Input<string>;
    }

    export interface ApplianceSingleLanMandatoryDhcp {
        /**
         * Enable Mandatory DHCP on single LAN.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceSsidsDhcpEnforcedDeauthentication {
        /**
         * Enable DCHP Enforced Deauthentication on the SSID.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceSsidsDot11w {
        /**
         * Whether 802.11w is enabled or not.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Optional) Whether 802.11w is required or not.
         */
        required?: pulumi.Input<boolean>;
    }

    export interface ApplianceSsidsRadiusServer {
        /**
         * The IP address of your RADIUS server.
         */
        host?: pulumi.Input<string>;
        /**
         * The UDP port your RADIUS servers listens on for Access-requests.
         */
        port?: pulumi.Input<number>;
        /**
         * The RADIUS client shared secret.
         */
        secret?: pulumi.Input<string>;
    }

    export interface ApplianceSsidsRadiusServersResponse {
        /**
         * The IP address of your RADIUS server.
         */
        host?: pulumi.Input<string>;
        /**
         * The UDP port your RADIUS servers listens on for Access-requests.
         */
        port?: pulumi.Input<number>;
        /**
         * The RADIUS client shared secret.
         */
        secret?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingCustomPerformanceClassesParameters {
        /**
         * Maximum jitter in milliseconds
         */
        maxJitter?: pulumi.Input<number>;
        /**
         * Maximum latency in milliseconds
         */
        maxLatency?: pulumi.Input<number>;
        /**
         * Maximum percentage of packet loss
         */
        maxLossPercentage?: pulumi.Input<number>;
        /**
         * Name of the custom performance class
         */
        name?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingGlobalBandwidthLimits {
        /**
         * The download bandwidth limit in Kbps. (0 represents no limit.)
         */
        limitDown?: pulumi.Input<number>;
        /**
         * The upload bandwidth limit in Kbps. (0 represents no limit.)
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingRulesRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceTrafficShapingRulesRuleDefinition>[]>;
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue?: pulumi.Input<number>;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits?: pulumi.Input<inputs.networks.ApplianceTrafficShapingRulesRulePerClientBandwidthLimits>;
        /**
         * A string, indicating the priority level for packets bound to your rule.
         * Can be 'low', 'normal' or 'high'.
         */
        priority?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingRulesRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type?: pulumi.Input<string>;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         * custom ports.
         *  If "type" is 'application' or 'applicationCategory', then "value" must be an object
         * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         * endpoint).
         */
        value?: pulumi.Input<string>;
        /**
         * The 'value_list' of what you want to block. Send a list in request
         */
        valueLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The 'value_obj' of what you want to block. Send a dict in request
         */
        valueObj?: pulumi.Input<inputs.networks.ApplianceTrafficShapingRulesRuleDefinitionValueObj>;
    }

    export interface ApplianceTrafficShapingRulesRuleDefinitionValueObj {
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingRulesRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits?: pulumi.Input<inputs.networks.ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits>;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown?: pulumi.Input<number>;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimits {
        /**
         * uplink cellular configured limits [optional]
         */
        cellular?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular>;
        /**
         * uplink wan1 configured limits [optional]
         */
        wan1?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1>;
        /**
         * uplink wan2 configured limits [optional]
         */
        wan2?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2>;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown?: pulumi.Input<number>;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1 {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown?: pulumi.Input<number>;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2 {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown?: pulumi.Input<number>;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionFailoverAndFailback {
        /**
         * Immediate WAN failover and failback
         */
        immediate?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate {
        /**
         * Whether immediate WAN failover and failback is enabled
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreference {
        /**
         * Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
         */
        failOverCriterion?: pulumi.Input<string>;
        /**
         * Performance class setting for uplink preference rule
         */
        performanceClass?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass>;
        /**
         * Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
         */
        preferredUplink?: pulumi.Input<string>;
        /**
         * Traffic filters
         */
        trafficFilters?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter>[]>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass {
        /**
         * Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
         */
        builtinPerformanceClassName?: pulumi.Input<string>;
        /**
         * ID of created custom performance class, must be present when performanceClass type is "custom"
         */
        customPerformanceClassId?: pulumi.Input<string>;
        /**
         * Type of this performance class. Must be one of: 'builtin' or 'custom'
         */
        type?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter {
        /**
         * Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
         */
        type?: pulumi.Input<string>;
        /**
         * Value of traffic filter
         */
        value?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue {
        /**
         * Destination of 'custom' type traffic filter
         */
        destination?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination>;
        /**
         * ID of 'applicationCategory' or 'application' type traffic filter
         */
        id?: pulumi.Input<string>;
        /**
         * Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
         */
        protocol?: pulumi.Input<string>;
        /**
         * Source of 'custom' type traffic filter
         */
        source?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
         */
        cidr?: pulumi.Input<string>;
        /**
         * FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
         */
        fqdn?: pulumi.Input<string>;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host?: pulumi.Input<number>;
        /**
         * Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
         */
        network?: pulumi.Input<string>;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port?: pulumi.Input<string>;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
         */
        vlan?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
         */
        cidr?: pulumi.Input<string>;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host?: pulumi.Input<number>;
        /**
         * Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
         */
        network?: pulumi.Input<string>;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port?: pulumi.Input<string>;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
         */
        vlan?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreference {
        /**
         * Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
         */
        preferredUplink?: pulumi.Input<string>;
        /**
         * Traffic filters
         */
        trafficFilters?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter>[]>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter {
        /**
         * Traffic filter type. Must be "custom"
         */
        type?: pulumi.Input<string>;
        /**
         * Value of traffic filter
         */
        value?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue {
        /**
         * Destination of 'custom' type traffic filter
         */
        destination?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination>;
        /**
         * Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
         */
        protocol?: pulumi.Input<string>;
        /**
         * Source of 'custom' type traffic filter
         */
        source?: pulumi.Input<inputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
         */
        cidr?: pulumi.Input<string>;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
         */
        cidr?: pulumi.Input<string>;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host?: pulumi.Input<number>;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port?: pulumi.Input<string>;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
         */
        vlan?: pulumi.Input<number>;
    }

    export interface ApplianceTrafficShapingVpnExclusionsItem {
        /**
         * Custom VPN exclusion rules.
         */
        customs?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceTrafficShapingVpnExclusionsItemCustom>[]>;
        /**
         * Major Application based VPN exclusion rules.
         */
        majorApplications?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceTrafficShapingVpnExclusionsItemMajorApplication>[]>;
        /**
         * ID of the network whose VPN exclusion rules are returned.
         */
        networkId?: pulumi.Input<string>;
        /**
         * Name of the network whose VPN exclusion rules are returned.
         */
        networkName?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingVpnExclusionsItemCustom {
        /**
         * Destination address; hostname required for DNS, IPv4 otherwise.
         */
        destination?: pulumi.Input<string>;
        /**
         * Destination port.
         */
        port?: pulumi.Input<string>;
        /**
         * Protocol.
         */
        protocol?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingVpnExclusionsItemMajorApplication {
        /**
         * Application's Meraki ID.
         */
        id?: pulumi.Input<string>;
        /**
         * Application's name.
         */
        name?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingVpnExclusionsParameters {
        /**
         * Custom VPN exclusion rules. Pass an empty array to clear existing rules.
         */
        customs?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceTrafficShapingVpnExclusionsParametersCustom>[]>;
        /**
         * Major Application based VPN exclusion rules. Pass an empty array to clear existing rules.
         */
        majorApplications?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceTrafficShapingVpnExclusionsParametersMajorApplication>[]>;
    }

    export interface ApplianceTrafficShapingVpnExclusionsParametersCustom {
        /**
         * Destination address; hostname required for DNS, IPv4 otherwise.
         */
        destination?: pulumi.Input<string>;
        /**
         * Destination port.
         */
        port?: pulumi.Input<string>;
        /**
         * Protocol.
         */
        protocol?: pulumi.Input<string>;
    }

    export interface ApplianceTrafficShapingVpnExclusionsParametersMajorApplication {
        /**
         * Application's Meraki ID.
         */
        id?: pulumi.Input<string>;
        /**
         * Application's name.
         */
        name?: pulumi.Input<string>;
    }

    export interface ApplianceVlansDhcpOption {
        /**
         * The code for the DHCP option. This should be an integer between 2 and 254.
         */
        code?: pulumi.Input<string>;
        /**
         * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
         */
        type?: pulumi.Input<string>;
        /**
         * The value for the DHCP option
         */
        value?: pulumi.Input<string>;
    }

    export interface ApplianceVlansIpv6 {
        /**
         * Enable IPv6 on VLAN
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Prefix assignments on the VLAN
         */
        prefixAssignments?: pulumi.Input<pulumi.Input<inputs.networks.ApplianceVlansIpv6PrefixAssignment>[]>;
    }

    export interface ApplianceVlansIpv6PrefixAssignment {
        /**
         * Auto assign a /64 prefix from the origin to the VLAN
         */
        autonomous?: pulumi.Input<boolean>;
        /**
         * The origin of the prefix
         */
        origin?: pulumi.Input<inputs.networks.ApplianceVlansIpv6PrefixAssignmentOrigin>;
        /**
         * Manual configuration of the IPv6 Appliance IP
         */
        staticApplianceIp6?: pulumi.Input<string>;
        /**
         * Manual configuration of a /64 prefix on the VLAN
         */
        staticPrefix?: pulumi.Input<string>;
    }

    export interface ApplianceVlansIpv6PrefixAssignmentOrigin {
        /**
         * Interfaces associated with the prefix
         */
        interfaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of the origin
         */
        type?: pulumi.Input<string>;
    }

    export interface ApplianceVlansMandatoryDhcp {
        /**
         * Enable Mandatory DHCP on VLAN.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceVlansReservedIpRange {
        /**
         * A text comment for the reserved range
         */
        comment?: pulumi.Input<string>;
        /**
         * The last IP in the reserved range
         */
        end?: pulumi.Input<string>;
        /**
         * The first IP in the reserved range
         */
        start?: pulumi.Input<string>;
    }

    export interface ApplianceVpnBgpNeighbor {
        /**
         * When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
         */
        allowTransit?: pulumi.Input<boolean>;
        /**
         * Authentication settings between BGP peers.
         */
        authentication?: pulumi.Input<inputs.networks.ApplianceVpnBgpNeighborAuthentication>;
        /**
         * The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
         */
        ebgpHoldTimer?: pulumi.Input<number>;
        /**
         * Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
         */
        ebgpMultihop?: pulumi.Input<number>;
        /**
         * The IPv4 address of the neighbor
         */
        ip?: pulumi.Input<string>;
        /**
         * Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
         */
        ipv6?: pulumi.Input<inputs.networks.ApplianceVpnBgpNeighborIpv6>;
        /**
         * The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
         */
        nextHopIp?: pulumi.Input<string>;
        /**
         * The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
         */
        receiveLimit?: pulumi.Input<number>;
        /**
         * Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
         */
        remoteAsNumber?: pulumi.Input<number>;
        /**
         * The output interface for peering with the remote BGP peer. Valid values are: 'wan1', 'wan2' or 'vlan{VLAN ID}'(e.g. 'vlan123').
         */
        sourceInterface?: pulumi.Input<string>;
        /**
         * Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
         */
        ttlSecurity?: pulumi.Input<inputs.networks.ApplianceVpnBgpNeighborTtlSecurity>;
    }

    export interface ApplianceVpnBgpNeighborAuthentication {
        /**
         * Password to configure MD5 authentication between BGP peers.
         */
        password?: pulumi.Input<string>;
    }

    export interface ApplianceVpnBgpNeighborIpv6 {
        /**
         * The IPv6 address of the neighbor.
         */
        address?: pulumi.Input<string>;
    }

    export interface ApplianceVpnBgpNeighborTtlSecurity {
        /**
         * Boolean value to enable or disable BGP TTL security.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface ApplianceVpnSiteToSiteVpnHub {
        /**
         * The network ID of the hub.
         */
        hubId?: pulumi.Input<string>;
        /**
         * Indicates whether default route traffic should be sent to this hub.
         */
        useDefaultRoute?: pulumi.Input<boolean>;
    }

    export interface ApplianceVpnSiteToSiteVpnSubnet {
        /**
         * The CIDR notation subnet used within the VPN
         */
        localSubnet?: pulumi.Input<string>;
        /**
         * Indicates the presence of the subnet in the VPN
         */
        useVpn?: pulumi.Input<boolean>;
    }

    export interface ApplianceWarmSpareWan1 {
        ip?: pulumi.Input<string>;
        subnet?: pulumi.Input<string>;
    }

    export interface ApplianceWarmSpareWan2 {
        ip?: pulumi.Input<string>;
        subnet?: pulumi.Input<string>;
    }

    export interface BindItem {
        /**
         * ID of the config template the network is being bound to
         */
        configTemplateId?: pulumi.Input<string>;
        /**
         * Enrollment string for the network
         */
        enrollmentString?: pulumi.Input<string>;
        /**
         * Network ID
         */
        id?: pulumi.Input<string>;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate?: pulumi.Input<boolean>;
        /**
         * Network name
         */
        name?: pulumi.Input<string>;
        /**
         * Notes for the network
         */
        notes?: pulumi.Input<string>;
        /**
         * Organization ID
         */
        organizationId?: pulumi.Input<string>;
        /**
         * List of the product types that the network supports
         */
        productTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network tags
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Timezone of the network
         */
        timeZone?: pulumi.Input<string>;
        /**
         * URL to the network Dashboard UI
         */
        url?: pulumi.Input<string>;
    }

    export interface BindParameters {
        /**
         * Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
         */
        autoBind?: pulumi.Input<boolean>;
        /**
         * The ID of the template to which the network should be bound.
         */
        configTemplateId?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettings {
        /**
         * Quality and resolution for MV12/MV22/MV72 camera models.
         */
        mV12MV22MV72?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72>;
        /**
         * Quality and resolution for MV12WE camera models.
         */
        mV12We?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV12We>;
        /**
         * Quality and resolution for MV13 camera models.
         */
        mV13?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV13>;
        /**
         * Quality and resolution for MV21/MV71 camera models.
         */
        mV21MV71?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV21MV71>;
        /**
         * Quality and resolution for MV22X/MV72X camera models.
         */
        mV22Xmv72X?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X>;
        /**
         * Quality and resolution for MV32 camera models.
         */
        mV32?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV32>;
        /**
         * Quality and resolution for MV33 camera models.
         */
        mV33?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV33>;
        /**
         * Quality and resolution for MV52 camera models.
         */
        mV52?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV52>;
        /**
         * Quality and resolution for MV63 camera models.
         */
        mV63?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV63>;
        /**
         * Quality and resolution for MV63X camera models.
         */
        mV63X?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV63X>;
        /**
         * Quality and resolution for MV93 camera models.
         */
        mV93?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV93>;
        /**
         * Quality and resolution for MV93X camera models.
         */
        mV93X?: pulumi.Input<inputs.networks.CameraQualityRetentionProfilesVideoSettingsMV93X>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV12We {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV13 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV21MV71 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1280x720'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV32 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV33 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV52 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV63 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV63X {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV93 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV93X {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality?: pulumi.Input<string>;
        /**
         * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
         */
        resolution?: pulumi.Input<string>;
    }

    export interface CameraWirelessProfilesIdentity {
        /**
         * The password of the identity.
         */
        password?: pulumi.Input<string>;
        /**
         * The username of the identity.
         */
        username?: pulumi.Input<string>;
    }

    export interface CameraWirelessProfilesSsid {
        /**
         * The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
         */
        authMode?: pulumi.Input<string>;
        /**
         * The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
         */
        encryptionMode?: pulumi.Input<string>;
        /**
         * The name of the SSID.
         */
        name?: pulumi.Input<string>;
        /**
         * The pre-shared key of the SSID.
         */
        psk?: pulumi.Input<string>;
    }

    export interface CellularGatewayConnectivityMonitoringDestinationsDestination {
        /**
         * Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
         */
        default?: pulumi.Input<boolean>;
        /**
         * Description of the testing destination. Optional, defaults to an empty string
         */
        description?: pulumi.Input<string>;
        /**
         * The IP address to test connectivity with
         */
        ip?: pulumi.Input<string>;
    }

    export interface CellularGatewaySubnetPoolSubnet {
        applianceIp?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
        serial?: pulumi.Input<string>;
        subnet?: pulumi.Input<string>;
    }

    export interface CellularGatewayUplinkBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps). 'null' indicates no limit.
         */
        limitDown?: pulumi.Input<number>;
        /**
         * The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface ClientsProvisionItem {
        /**
         * The list of clients to provision
         */
        clients?: pulumi.Input<pulumi.Input<inputs.networks.ClientsProvisionItemClient>[]>;
        /**
         * The name of the client's policy
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The group policy identifier of the client
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionItemClient {
        /**
         * The identifier of the client
         */
        clientId?: pulumi.Input<string>;
        /**
         * The MAC address of the client
         */
        mac?: pulumi.Input<string>;
        /**
         * The client's display message if its group policy is 'Blocked'
         */
        message?: pulumi.Input<string>;
        /**
         * The name of the client
         */
        name?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParameters {
        /**
         * The array of clients to provision
         */
        clients?: pulumi.Input<pulumi.Input<inputs.networks.ClientsProvisionParametersClient>[]>;
        /**
         * The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
        /**
         * An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
         */
        policiesBySecurityAppliance?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySecurityAppliance>;
        /**
         * An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
         */
        policiesBySsid?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsid>;
    }

    export interface ClientsProvisionParametersClient {
        /**
         * The MAC address of the client. Required.
         */
        mac?: pulumi.Input<string>;
        /**
         * The display name for the client. Optional. Limited to 255 bytes.
         */
        name?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySecurityAppliance {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsid {
        /**
         * The number for the SSID
         */
        status0?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus0>;
        /**
         * The number for the SSID
         */
        status1?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus1>;
        /**
         * The number for the SSID
         */
        status10?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus10>;
        /**
         * The number for the SSID
         */
        status11?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus11>;
        /**
         * The number for the SSID
         */
        status12?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus12>;
        /**
         * The number for the SSID
         */
        status13?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus13>;
        /**
         * The number for the SSID
         */
        status14?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus14>;
        /**
         * The number for the SSID
         */
        status2?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus2>;
        /**
         * The number for the SSID
         */
        status3?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus3>;
        /**
         * The number for the SSID
         */
        status4?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus4>;
        /**
         * The number for the SSID
         */
        status5?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus5>;
        /**
         * The number for the SSID
         */
        status6?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus6>;
        /**
         * The number for the SSID
         */
        status7?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus7>;
        /**
         * The number for the SSID
         */
        status8?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus8>;
        /**
         * The number for the SSID
         */
        status9?: pulumi.Input<inputs.networks.ClientsProvisionParametersPoliciesBySsidStatus9>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus0 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus1 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus10 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus11 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus12 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus13 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus14 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus2 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus3 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus4 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus5 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus6 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus7 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus8 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus9 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId?: pulumi.Input<string>;
    }

    export interface ClientsSplashAuthorizationStatusSsids {
        /**
         * Splash authorization for SSID 0
         */
        status0?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus0>;
        /**
         * Splash authorization for SSID 1
         */
        status1?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus1>;
        /**
         * Splash authorization for SSID 10
         */
        status10?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus10>;
        /**
         * Splash authorization for SSID 11
         */
        status11?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus11>;
        /**
         * Splash authorization for SSID 12
         */
        status12?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus12>;
        /**
         * Splash authorization for SSID 13
         */
        status13?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus13>;
        /**
         * Splash authorization for SSID 14
         */
        status14?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus14>;
        /**
         * Splash authorization for SSID 2
         */
        status2?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus2>;
        /**
         * Splash authorization for SSID 3
         */
        status3?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus3>;
        /**
         * Splash authorization for SSID 4
         */
        status4?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus4>;
        /**
         * Splash authorization for SSID 5
         */
        status5?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus5>;
        /**
         * Splash authorization for SSID 6
         */
        status6?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus6>;
        /**
         * Splash authorization for SSID 7
         */
        status7?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus7>;
        /**
         * Splash authorization for SSID 8
         */
        status8?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus8>;
        /**
         * Splash authorization for SSID 9
         */
        status9?: pulumi.Input<inputs.networks.ClientsSplashAuthorizationStatusSsidsStatus9>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus0 {
        authorizedAt?: pulumi.Input<string>;
        expiresAt?: pulumi.Input<string>;
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus1 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus10 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus11 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus12 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus13 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus14 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus2 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus3 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus4 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus5 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus6 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus7 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus8 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus9 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized?: pulumi.Input<boolean>;
    }

    export interface DevicesClaimItem {
        /**
         * The serials of the devices
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DevicesClaimParameters {
        /**
         * A list of serials of devices to claim
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DevicesClaimVmxItem {
        /**
         * Physical address of the device
         */
        address?: pulumi.Input<string>;
        /**
         * Additional device information
         */
        details?: pulumi.Input<pulumi.Input<inputs.networks.DevicesClaimVmxItemDetail>[]>;
        /**
         * Firmware version of the device
         */
        firmware?: pulumi.Input<string>;
        /**
         * IMEI of the device, if applicable
         */
        imei?: pulumi.Input<string>;
        /**
         * LAN IP address of the device
         */
        lanIp?: pulumi.Input<string>;
        /**
         * Latitude of the device
         */
        lat?: pulumi.Input<number>;
        /**
         * Longitude of the device
         */
        lng?: pulumi.Input<number>;
        /**
         * MAC address of the device
         */
        mac?: pulumi.Input<string>;
        /**
         * Model of the device
         */
        model?: pulumi.Input<string>;
        /**
         * Name of the device
         */
        name?: pulumi.Input<string>;
        /**
         * ID of the network the device belongs to
         */
        networkId?: pulumi.Input<string>;
        /**
         * Notes for the device, limited to 255 characters
         */
        notes?: pulumi.Input<string>;
        /**
         * Product type of the device
         */
        productType?: pulumi.Input<string>;
        /**
         * Serial number of the device
         */
        serial?: pulumi.Input<string>;
        /**
         * List of tags assigned to the device
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface DevicesClaimVmxItemDetail {
        /**
         * Additional property name
         */
        name?: pulumi.Input<string>;
        /**
         * Additional property value
         */
        value?: pulumi.Input<string>;
    }

    export interface DevicesClaimVmxParameters {
        /**
         * The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100
         */
        size?: pulumi.Input<string>;
    }

    export interface DevicesRemoveParameters {
        /**
         * The serial of a device
         */
        serial?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProducts {
        /**
         * The network device to be updated
         */
        appliance?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsAppliance>;
        /**
         * The network device to be updated
         */
        camera?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCamera>;
        /**
         * The network device to be updated
         */
        cellularGateway?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGateway>;
        /**
         * The network device to be updated
         */
        sensor?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensor>;
        /**
         * The network device to be updated
         */
        switch?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitch>;
        /**
         * The network device to be updated
         */
        switchCatalyst?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchCatalyst>;
        /**
         * The network device to be updated
         */
        wireless?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsWireless>;
    }

    export interface FirmwareUpgradesProductsAppliance {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesProductsApplianceAvailableVersion>[]>;
        /**
         * Details of the current version on the device
         */
        currentVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsApplianceCurrentVersion>;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsApplianceLastUpgrade>;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsApplianceNextUpgrade>;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease?: pulumi.Input<boolean>;
    }

    export interface FirmwareUpgradesProductsApplianceAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsApplianceCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsApplianceLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsApplianceLastUpgradeFromVersion>;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device upgraded to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsApplianceLastUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsApplianceLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsApplianceLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsApplianceNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsApplianceNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsApplianceNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCamera {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesProductsCameraAvailableVersion>[]>;
        /**
         * Details of the current version on the device
         */
        currentVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCameraCurrentVersion>;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCameraLastUpgrade>;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCameraNextUpgrade>;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease?: pulumi.Input<boolean>;
    }

    export interface FirmwareUpgradesProductsCameraAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCameraCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCameraLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCameraLastUpgradeFromVersion>;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device upgraded to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCameraLastUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsCameraLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCameraLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCameraNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCameraNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsCameraNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCellularGateway {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGatewayAvailableVersion>[]>;
        /**
         * Details of the current version on the device
         */
        currentVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGatewayCurrentVersion>;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGatewayLastUpgrade>;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGatewayNextUpgrade>;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease?: pulumi.Input<boolean>;
    }

    export interface FirmwareUpgradesProductsCellularGatewayAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCellularGatewayCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCellularGatewayLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion>;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device upgraded to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsCellularGatewayNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSensor {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensorAvailableVersion>[]>;
        /**
         * Details of the current version on the device
         */
        currentVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensorCurrentVersion>;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensorLastUpgrade>;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensorNextUpgrade>;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease?: pulumi.Input<boolean>;
    }

    export interface FirmwareUpgradesProductsSensorAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSensorCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSensorLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensorLastUpgradeFromVersion>;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device upgraded to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensorLastUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsSensorLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSensorLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSensorNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSensorNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsSensorNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSwitch {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchAvailableVersion>[]>;
        /**
         * Details of the current version on the device
         */
        currentVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchCurrentVersion>;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchLastUpgrade>;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchNextUpgrade>;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease?: pulumi.Input<boolean>;
    }

    export interface FirmwareUpgradesProductsSwitchAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSwitchCatalyst {
        /**
         * The pending firmware upgrade if it exists
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchCatalystNextUpgrade>;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease?: pulumi.Input<boolean>;
    }

    export interface FirmwareUpgradesProductsSwitchCatalystNextUpgrade {
        /**
         * The time of the last successful upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * The version to be updated to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion {
        /**
         * The version ID
         */
        id?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSwitchCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSwitchLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchLastUpgradeFromVersion>;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device upgraded to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchLastUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsSwitchLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSwitchLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsSwitchNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsSwitchNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsSwitchNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsWireless {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesProductsWirelessAvailableVersion>[]>;
        /**
         * Details of the current version on the device
         */
        currentVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsWirelessCurrentVersion>;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsWirelessLastUpgrade>;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsWirelessNextUpgrade>;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease?: pulumi.Input<boolean>;
    }

    export interface FirmwareUpgradesProductsWirelessAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsWirelessCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsWirelessLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsWirelessLastUpgradeFromVersion>;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device upgraded to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsWirelessLastUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsWirelessLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsWirelessLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesProductsWirelessNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time?: pulumi.Input<string>;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesProductsWirelessNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesProductsWirelessNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesRollbacksItem {
        /**
         * Product type to rollback (if the network is a combined network)
         */
        product?: pulumi.Input<string>;
        /**
         * Reasons for the rollback
         */
        reasons?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesRollbacksItemReason>[]>;
        /**
         * Status of the rollback
         */
        status?: pulumi.Input<string>;
        /**
         * Scheduled time for the rollback
         */
        time?: pulumi.Input<string>;
        /**
         * Version to downgrade to (if the network has firmware flexibility)
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesRollbacksItemToVersion>;
        /**
         * Batch ID of the firmware rollback
         */
        upgradeBatchId?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesRollbacksItemReason {
        /**
         * Reason for the rollback
         */
        category?: pulumi.Input<string>;
        /**
         * Additional comment about the rollback
         */
        comment?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesRollbacksItemToVersion {
        /**
         * Name of the firmware version
         */
        firmware?: pulumi.Input<string>;
        /**
         * Firmware version identifier
         */
        id?: pulumi.Input<string>;
        /**
         * Release date of the firmware version
         */
        releaseDate?: pulumi.Input<string>;
        /**
         * Release type of the firmware version
         */
        releaseType?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesRollbacksParameters {
        /**
         * Product type to rollback (if the network is a combined network)
         */
        product?: pulumi.Input<string>;
        /**
         * Reasons for the rollback
         */
        reasons?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesRollbacksParametersReason>[]>;
        /**
         * Scheduled time for the rollback
         */
        time?: pulumi.Input<string>;
        /**
         * Version to downgrade to (if the network has firmware flexibility)
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesRollbacksParametersToVersion>;
    }

    export interface FirmwareUpgradesRollbacksParametersReason {
        /**
         * Reason for the rollback
         */
        category?: pulumi.Input<string>;
        /**
         * Additional comment about the rollback
         */
        comment?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesRollbacksParametersToVersion {
        /**
         * The version ID
         */
        id?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItem {
        /**
         * The network devices to be updated
         */
        products?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemProducts>;
        /**
         * Reasons for the rollback
         */
        reasons?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemReason>[]>;
        /**
         * The ordered stages in the network
         */
        stages?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemStage>[]>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProducts {
        /**
         * The Switch network to be updated
         */
        switch?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemProductsSwitch>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProductsSwitch {
        /**
         * Details of the next firmware upgrade
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade {
        /**
         * Details of the version the device will upgrade to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion {
        /**
         * Id of the Version being upgraded to
         */
        id?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemReason {
        /**
         * Reason for the rollback
         */
        category?: pulumi.Input<string>;
        /**
         * Additional comment about the rollback
         */
        comment?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemStage {
        /**
         * The staged upgrade group
         */
        group?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemStageGroup>;
        /**
         * The Staged Upgrade Milestones for the stage
         */
        milestones?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsDeferItemStageMilestones>;
        /**
         * Current upgrade status of the group
         */
        status?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemStageGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description?: pulumi.Input<string>;
        /**
         * Id of the Staged Upgrade Group
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the Staged Upgrade Group
         */
        name?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemStageMilestones {
        /**
         * Time that the group was canceled
         */
        canceledAt?: pulumi.Input<string>;
        /**
         * Finish time for the group
         */
        completedAt?: pulumi.Input<string>;
        /**
         * Scheduled start time for the group
         */
        scheduledFor?: pulumi.Input<string>;
        /**
         * Start time for the group
         */
        startedAt?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsProducts {
        /**
         * The Switch network to be updated
         */
        switch?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsProductsSwitch>;
        /**
         * Version information for the switch network being upgraded
         */
        switchCatalyst?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsProductsSwitchCatalyst>;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitch {
        /**
         * Details of the next firmware upgrade
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade>;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchCatalyst {
        /**
         * The next upgrade version for the switch network
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade>;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade {
        /**
         * The version to be updated to for switch Catalyst devices
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion {
        /**
         * The version ID
         */
        id?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade {
        /**
         * Details of the version the device will upgrade to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion {
        /**
         * Id of the Version being upgraded to
         */
        id?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsReason {
        /**
         * Reason for the rollback
         */
        category?: pulumi.Input<string>;
        /**
         * Additional comment about the rollback
         */
        comment?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItem {
        /**
         * The network devices to be updated
         */
        products?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProducts>;
        /**
         * Reasons for the rollback
         */
        reasons?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemReason>[]>;
        /**
         * The ordered stages in the network
         */
        stages?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemStage>[]>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProducts {
        /**
         * The Switch network to be updated
         */
        switch?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch {
        /**
         * Details of the next firmware upgrade
         */
        nextUpgrade?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade {
        /**
         * Details of the version the device will upgrade to
         */
        toVersion?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion {
        /**
         * Id of the Version being upgraded to
         */
        id?: pulumi.Input<string>;
        /**
         * Firmware version short name
         */
        shortName?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemReason {
        /**
         * Reason for the rollback
         */
        category?: pulumi.Input<string>;
        /**
         * Additional comment about the rollback
         */
        comment?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemStage {
        /**
         * The staged upgrade group
         */
        group?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemStageGroup>;
        /**
         * The Staged Upgrade Milestones for the stage
         */
        milestones?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksItemStageMilestones>;
        /**
         * Current upgrade status of the group
         */
        status?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemStageGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description?: pulumi.Input<string>;
        /**
         * Id of the Staged Upgrade Group
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the Staged Upgrade Group
         */
        name?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemStageMilestones {
        /**
         * Time that the group was canceled
         */
        canceledAt?: pulumi.Input<string>;
        /**
         * Finish time for the group
         */
        completedAt?: pulumi.Input<string>;
        /**
         * Scheduled start time for the group
         */
        scheduledFor?: pulumi.Input<string>;
        /**
         * Start time for the group
         */
        startedAt?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParameters {
        /**
         * The reason for rolling back the staged upgrade
         */
        reasons?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersReason>[]>;
        /**
         * All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
         */
        stages?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersStage>[]>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersReason {
        /**
         * Reason for the rollback
         */
        category?: pulumi.Input<string>;
        /**
         * Additional comment about the rollback
         */
        comment?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersStage {
        /**
         * The Staged Upgrade Group containing the name and ID
         */
        group?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersStageGroup>;
        /**
         * The Staged Upgrade Milestones for the specific stage
         */
        milestones?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersStageGroup {
        /**
         * ID of the Staged Upgrade Group
         */
        id?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones {
        /**
         * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
         */
        scheduledFor?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsStage {
        /**
         * The staged upgrade group
         */
        group?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsStageGroup>;
        /**
         * The Staged Upgrade Milestones for the stage
         */
        milestones?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedEventsStageMilestones>;
        /**
         * Current upgrade status of the group
         */
        status?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsStageGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description?: pulumi.Input<string>;
        /**
         * Id of the Staged Upgrade Group
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the Staged Upgrade Group
         */
        name?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedEventsStageMilestones {
        /**
         * Time that the group was canceled
         */
        canceledAt?: pulumi.Input<string>;
        /**
         * Finish time for the group
         */
        completedAt?: pulumi.Input<string>;
        /**
         * Scheduled start time for the group
         */
        scheduledFor?: pulumi.Input<string>;
        /**
         * Start time for the group
         */
        startedAt?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedGroupsAssignedDevices {
        /**
         * Data Array of Devices containing the name and serial
         */
        devices?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedGroupsAssignedDevicesDevice>[]>;
        /**
         * Data Array of Switch Stacks containing the name and id
         */
        switchStacks?: pulumi.Input<pulumi.Input<inputs.networks.FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack>[]>;
    }

    export interface FirmwareUpgradesStagedGroupsAssignedDevicesDevice {
        /**
         * Name of the device
         */
        name?: pulumi.Input<string>;
        /**
         * Serial of the device
         */
        serial?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack {
        /**
         * ID of the Switch Stack
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the Switch Stack
         */
        name?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedStagesGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description?: pulumi.Input<string>;
        /**
         * Id of the Staged Upgrade Group
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the Staged Upgrade Group
         */
        name?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesStagedStagesJson {
        /**
         * The Staged Upgrade Group
         */
        group?: pulumi.Input<inputs.networks.FirmwareUpgradesStagedStagesJsonGroup>;
    }

    export interface FirmwareUpgradesStagedStagesJsonGroup {
        /**
         * ID of the Staged Upgrade Group
         */
        id?: pulumi.Input<string>;
    }

    export interface FirmwareUpgradesUpgradeWindow {
        /**
         * Day of the week
         */
        dayOfWeek?: pulumi.Input<string>;
        /**
         * Hour of the day
         */
        hourOfDay?: pulumi.Input<string>;
    }

    export interface FloorPlansBottomLeftCorner {
        /**
         * Latitude
         */
        lat?: pulumi.Input<number>;
        /**
         * Longitude
         */
        lng?: pulumi.Input<number>;
    }

    export interface FloorPlansBottomRightCorner {
        /**
         * Latitude
         */
        lat?: pulumi.Input<number>;
        /**
         * Longitude
         */
        lng?: pulumi.Input<number>;
    }

    export interface FloorPlansCenter {
        /**
         * Latitude
         */
        lat?: pulumi.Input<number>;
        /**
         * Longitude
         */
        lng?: pulumi.Input<number>;
    }

    export interface FloorPlansDevice {
        /**
         * Physical address of the device
         */
        address?: pulumi.Input<string>;
        /**
         * Additional device information
         */
        details?: pulumi.Input<pulumi.Input<inputs.networks.FloorPlansDeviceDetail>[]>;
        /**
         * Firmware version of the device
         */
        firmware?: pulumi.Input<string>;
        /**
         * IMEI of the device, if applicable
         */
        imei?: pulumi.Input<string>;
        /**
         * LAN IP address of the device
         */
        lanIp?: pulumi.Input<string>;
        /**
         * Latitude of the device
         */
        lat?: pulumi.Input<number>;
        /**
         * Longitude of the device
         */
        lng?: pulumi.Input<number>;
        /**
         * MAC address of the device
         */
        mac?: pulumi.Input<string>;
        /**
         * Model of the device
         */
        model?: pulumi.Input<string>;
        /**
         * Name of the device
         */
        name?: pulumi.Input<string>;
        /**
         * ID of the network the device belongs to
         */
        networkId?: pulumi.Input<string>;
        /**
         * Notes for the device, limited to 255 characters
         */
        notes?: pulumi.Input<string>;
        /**
         * Product type of the device
         */
        productType?: pulumi.Input<string>;
        /**
         * Serial number of the device
         */
        serial?: pulumi.Input<string>;
        /**
         * List of tags assigned to the device
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FloorPlansDeviceDetail {
        /**
         * Additional property name
         */
        name?: pulumi.Input<string>;
        /**
         * Additional property value
         */
        value?: pulumi.Input<string>;
    }

    export interface FloorPlansTopLeftCorner {
        /**
         * Latitude
         */
        lat?: pulumi.Input<number>;
        /**
         * Longitude
         */
        lng?: pulumi.Input<number>;
    }

    export interface FloorPlansTopRightCorner {
        /**
         * Latitude
         */
        lat?: pulumi.Input<number>;
        /**
         * Longitude
         */
        lng?: pulumi.Input<number>;
    }

    export interface GroupPoliciesBandwidth {
        /**
         * The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits?: pulumi.Input<inputs.networks.GroupPoliciesBandwidthBandwidthLimits>;
        /**
         * How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface GroupPoliciesBandwidthBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps). null indicates no limit
         */
        limitDown?: pulumi.Input<number>;
        /**
         * The maximum upload limit (integer, in Kbps). null indicates no limit
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface GroupPoliciesBonjourForwarding {
        /**
         * A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
         */
        rules?: pulumi.Input<pulumi.Input<inputs.networks.GroupPoliciesBonjourForwardingRule>[]>;
        /**
         * How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface GroupPoliciesBonjourForwardingRule {
        /**
         * A description for your Bonjour forwarding rule. Optional.
         */
        description?: pulumi.Input<string>;
        /**
         * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
         */
        services?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the service VLAN. Required.
         */
        vlanId?: pulumi.Input<string>;
    }

    export interface GroupPoliciesContentFiltering {
        /**
         * Settings for allowed URL patterns
         */
        allowedUrlPatterns?: pulumi.Input<inputs.networks.GroupPoliciesContentFilteringAllowedUrlPatterns>;
        /**
         * Settings for blocked URL categories
         */
        blockedUrlCategories?: pulumi.Input<inputs.networks.GroupPoliciesContentFilteringBlockedUrlCategories>;
        /**
         * Settings for blocked URL patterns
         */
        blockedUrlPatterns?: pulumi.Input<inputs.networks.GroupPoliciesContentFilteringBlockedUrlPatterns>;
    }

    export interface GroupPoliciesContentFilteringAllowedUrlPatterns {
        /**
         * A list of URL patterns that are allowed
         */
        patterns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * How URL patterns are applied. Can be 'network default', 'append' or 'override'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface GroupPoliciesContentFilteringBlockedUrlCategories {
        /**
         * A list of URL categories to block
         */
        categories?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * How URL categories are applied. Can be 'network default', 'append' or 'override'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface GroupPoliciesContentFilteringBlockedUrlPatterns {
        /**
         * A list of URL patterns that are blocked
         */
        patterns?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * How URL patterns are applied. Can be 'network default', 'append' or 'override'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface GroupPoliciesFirewallAndTrafficShaping {
        /**
         * An ordered array of the L3 firewall rules
         */
        l3FirewallRules?: pulumi.Input<pulumi.Input<inputs.networks.GroupPoliciesFirewallAndTrafficShapingL3FirewallRule>[]>;
        /**
         * An ordered array of L7 firewall rules
         */
        l7FirewallRules?: pulumi.Input<pulumi.Input<inputs.networks.GroupPoliciesFirewallAndTrafficShapingL7FirewallRule>[]>;
        /**
         * How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
         */
        settings?: pulumi.Input<string>;
        /**
         * An array of traffic shaping rules. Rules are applied in the order that
         * they are specified in. An empty list (or null) means no rules. Note that
         * you are allowed a maximum of 8 rules.
         */
        trafficShapingRules?: pulumi.Input<pulumi.Input<inputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule>[]>;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingL3FirewallRule {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingL7FirewallRule {
        /**
         * The policy applied to matching traffic. Must be 'deny'.
         */
        policy?: pulumi.Input<string>;
        /**
         * Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
         */
        type?: pulumi.Input<string>;
        /**
         * The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
         */
        value?: pulumi.Input<string>;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions?: pulumi.Input<pulumi.Input<inputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition>[]>;
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue?: pulumi.Input<number>;
        /**
         * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
         * null means 'Do not set PCP tag'.
         */
        pcpTagValue?: pulumi.Input<number>;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits?: pulumi.Input<inputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits>;
        /**
         * A string, indicating the priority level for packets bound to your rule.
         * Can be 'low', 'normal' or 'high'.
         */
        priority?: pulumi.Input<string>;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type?: pulumi.Input<string>;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         * custom ports.
         *  If "type" is 'application' or 'applicationCategory', then "value" must be an object
         * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         * endpoint).
         */
        value?: pulumi.Input<string>;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits?: pulumi.Input<inputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits>;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown?: pulumi.Input<number>;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface GroupPoliciesScheduling {
        /**
         * Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The schedule object for Friday.
         */
        friday?: pulumi.Input<inputs.networks.GroupPoliciesSchedulingFriday>;
        /**
         * The schedule object for Monday.
         */
        monday?: pulumi.Input<inputs.networks.GroupPoliciesSchedulingMonday>;
        /**
         * The schedule object for Saturday.
         */
        saturday?: pulumi.Input<inputs.networks.GroupPoliciesSchedulingSaturday>;
        /**
         * The schedule object for Sunday.
         */
        sunday?: pulumi.Input<inputs.networks.GroupPoliciesSchedulingSunday>;
        /**
         * The schedule object for Thursday.
         */
        thursday?: pulumi.Input<inputs.networks.GroupPoliciesSchedulingThursday>;
        /**
         * The schedule object for Tuesday.
         */
        tuesday?: pulumi.Input<inputs.networks.GroupPoliciesSchedulingTuesday>;
        /**
         * The schedule object for Wednesday.
         */
        wednesday?: pulumi.Input<inputs.networks.GroupPoliciesSchedulingWednesday>;
    }

    export interface GroupPoliciesSchedulingFriday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface GroupPoliciesSchedulingMonday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface GroupPoliciesSchedulingSaturday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface GroupPoliciesSchedulingSunday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface GroupPoliciesSchedulingThursday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface GroupPoliciesSchedulingTuesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface GroupPoliciesSchedulingWednesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface GroupPoliciesVlanTagging {
        /**
         * How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
         */
        settings?: pulumi.Input<string>;
        /**
         * The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
         */
        vlanId?: pulumi.Input<string>;
    }

    export interface MerakiAuthUsersAuthorization {
        /**
         * User is authorized by the account email address
         */
        authorizedByEmail?: pulumi.Input<string>;
        /**
         * User is authorized by the account name
         */
        authorizedByName?: pulumi.Input<string>;
        /**
         * Authorized zone of the user
         */
        authorizedZone?: pulumi.Input<string>;
        /**
         * Authorization expiration time
         */
        expiresAt?: pulumi.Input<string>;
        /**
         * SSID number
         */
        ssidNumber?: pulumi.Input<number>;
    }

    export interface MqttBrokersItem {
        /**
         * Authentication settings of the MQTT broker
         */
        authentication?: pulumi.Input<inputs.networks.MqttBrokersItemAuthentication>;
        /**
         * Host name/IP address where the MQTT broker runs.
         */
        host?: pulumi.Input<string>;
        /**
         * ID of the MQTT Broker.
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the MQTT Broker.
         */
        name?: pulumi.Input<string>;
        /**
         * Host port though which the MQTT broker can be reached.
         */
        port?: pulumi.Input<number>;
        /**
         * Security settings of the MQTT broker.
         */
        security?: pulumi.Input<inputs.networks.MqttBrokersItemSecurity>;
    }

    export interface MqttBrokersItemAuthentication {
        /**
         * Username for the MQTT broker.
         */
        username?: pulumi.Input<string>;
    }

    export interface MqttBrokersItemSecurity {
        /**
         * Security protocol of the MQTT broker.
         */
        mode?: pulumi.Input<string>;
        /**
         * TLS settings of the MQTT broker.
         */
        tls?: pulumi.Input<inputs.networks.MqttBrokersItemSecurityTls>;
    }

    export interface MqttBrokersItemSecurityTls {
        /**
         * Indicates whether the CA certificate is set
         */
        hasCaCertificate?: pulumi.Input<boolean>;
        /**
         * Whether the TLS hostname verification is enabled for the MQTT broker.
         */
        verifyHostnames?: pulumi.Input<boolean>;
    }

    export interface MqttBrokersParameters {
        /**
         * Authentication settings of the MQTT broker
         */
        authentication?: pulumi.Input<inputs.networks.MqttBrokersParametersAuthentication>;
        /**
         * Host name/IP address where the MQTT broker runs.
         */
        host?: pulumi.Input<string>;
        /**
         * Name of the MQTT broker.
         */
        name?: pulumi.Input<string>;
        /**
         * Host port though which the MQTT broker can be reached.
         */
        port?: pulumi.Input<number>;
        /**
         * Security settings of the MQTT broker.
         */
        security?: pulumi.Input<inputs.networks.MqttBrokersParametersSecurity>;
    }

    export interface MqttBrokersParametersAuthentication {
        /**
         * Password for the MQTT broker.
         */
        password?: pulumi.Input<string>;
        /**
         * Username for the MQTT broker.
         */
        username?: pulumi.Input<string>;
    }

    export interface MqttBrokersParametersSecurity {
        /**
         * Security protocol of the MQTT broker.
         */
        mode?: pulumi.Input<string>;
        /**
         * TLS settings of the MQTT broker.
         */
        tls?: pulumi.Input<inputs.networks.MqttBrokersParametersSecurityTls>;
    }

    export interface MqttBrokersParametersSecurityTls {
        /**
         * CA Certificate of the MQTT broker.
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * Whether the TLS hostname verification is enabled for the MQTT broker.
         */
        verifyHostnames?: pulumi.Input<boolean>;
    }

    export interface SensorAlertsProfilesCondition {
        /**
         * If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
         */
        direction?: pulumi.Input<string>;
        /**
         * Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
         */
        duration?: pulumi.Input<number>;
        /**
         * The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
         */
        metric?: pulumi.Input<string>;
        /**
         * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
         */
        threshold?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThreshold>;
    }

    export interface SensorAlertsProfilesConditionThreshold {
        /**
         * Apparent power threshold. 'draw' must be provided.
         */
        apparentPower?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdApparentPower>;
        /**
         * Electrical current threshold. 'level' must be provided.
         */
        current?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdCurrent>;
        /**
         * Door open threshold. 'open' must be provided and set to true.
         */
        door?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdDoor>;
        /**
         * Electrical frequency threshold. 'level' must be provided.
         */
        frequency?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdFrequency>;
        /**
         * Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
         */
        humidity?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdHumidity>;
        /**
         * Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
         */
        indoorAirQuality?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdIndoorAirQuality>;
        /**
         * Noise threshold. 'ambient' must be provided.
         */
        noise?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdNoise>;
        /**
         * PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        pm25?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdPm25>;
        /**
         * Power factor threshold. 'percentage' must be provided.
         */
        powerFactor?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdPowerFactor>;
        /**
         * Real power threshold. 'draw' must be provided.
         */
        realPower?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdRealPower>;
        /**
         * Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
         */
        temperature?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdTemperature>;
        /**
         * TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        tvoc?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdTvoc>;
        /**
         * Upstream power threshold. 'outageDetected' must be provided and set to true.
         */
        upstreamPower?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdUpstreamPower>;
        /**
         * Voltage threshold. 'level' must be provided.
         */
        voltage?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdVoltage>;
        /**
         * Water detection threshold. 'present' must be provided and set to true.
         */
        water?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdWater>;
    }

    export interface SensorAlertsProfilesConditionThresholdApparentPower {
        /**
         * Alerting threshold in volt-amps. Must be between 0 and 3750.
         */
        draw?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdCurrent {
        /**
         * Alerting threshold in amps. Must be between 0 and 15.
         */
        draw?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdDoor {
        /**
         * Alerting threshold for a door open event. Must be set to true.
         */
        open?: pulumi.Input<boolean>;
    }

    export interface SensorAlertsProfilesConditionThresholdFrequency {
        /**
         * Alerting threshold in hertz. Must be between 0 and 60.
         */
        level?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdHumidity {
        /**
         * Alerting threshold as a qualitative humidity level.
         */
        quality?: pulumi.Input<string>;
        /**
         * Alerting threshold in %RH.
         */
        relativePercentage?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdIndoorAirQuality {
        /**
         * Alerting threshold as a qualitative indoor air quality level.
         */
        quality?: pulumi.Input<string>;
        /**
         * Alerting threshold as indoor air quality score.
         */
        score?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdNoise {
        /**
         * Ambient noise threshold. One of 'level' or 'quality' must be provided.
         */
        ambient?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionThresholdNoiseAmbient>;
    }

    export interface SensorAlertsProfilesConditionThresholdNoiseAmbient {
        /**
         * Alerting threshold as adjusted decibels.
         */
        level?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative ambient noise level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionThresholdPm25 {
        /**
         * Alerting threshold as PM2.5 parts per million.
         */
        concentration?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative PM2.5 level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionThresholdPowerFactor {
        /**
         * Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdRealPower {
        /**
         * Alerting threshold in watts. Must be between 0 and 3750.
         */
        draw?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdTemperature {
        /**
         * Alerting threshold in degrees Celsius.
         */
        celsius?: pulumi.Input<number>;
        /**
         * Alerting threshold in degrees Fahrenheit.
         */
        fahrenheit?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative temperature level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionThresholdTvoc {
        /**
         * Alerting threshold as TVOC micrograms per cubic meter.
         */
        concentration?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative TVOC level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionThresholdUpstreamPower {
        /**
         * Alerting threshold for an upstream power event. Must be set to true.
         */
        outageDetected?: pulumi.Input<boolean>;
    }

    export interface SensorAlertsProfilesConditionThresholdVoltage {
        /**
         * Alerting threshold in volts. Must be between 0 and 250.
         */
        level?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionThresholdWater {
        /**
         * Alerting threshold for a water detection event. Must be set to true.
         */
        present?: pulumi.Input<boolean>;
    }

    export interface SensorAlertsProfilesConditionsResponse {
        /**
         * If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
         */
        direction?: pulumi.Input<string>;
        /**
         * Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
         */
        duration?: pulumi.Input<number>;
        /**
         * The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
         */
        metric?: pulumi.Input<string>;
        /**
         * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
         */
        threshold?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThreshold>;
    }

    export interface SensorAlertsProfilesConditionsResponseThreshold {
        /**
         * Apparent power threshold. 'draw' must be provided.
         */
        apparentPower?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdApparentPower>;
        /**
         * Electrical current threshold. 'level' must be provided.
         */
        current?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdCurrent>;
        /**
         * Door open threshold. 'open' must be provided and set to true.
         */
        door?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdDoor>;
        /**
         * Electrical frequency threshold. 'level' must be provided.
         */
        frequency?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdFrequency>;
        /**
         * Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
         */
        humidity?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdHumidity>;
        /**
         * Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
         */
        indoorAirQuality?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality>;
        /**
         * Noise threshold. 'ambient' must be provided.
         */
        noise?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdNoise>;
        /**
         * PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        pm25?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdPm25>;
        /**
         * Power factor threshold. 'percentage' must be provided.
         */
        powerFactor?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdPowerFactor>;
        /**
         * Real power threshold. 'draw' must be provided.
         */
        realPower?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdRealPower>;
        /**
         * Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
         */
        temperature?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdTemperature>;
        /**
         * TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        tvoc?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdTvoc>;
        /**
         * Upstream power threshold. 'outageDetected' must be provided and set to true.
         */
        upstreamPower?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdUpstreamPower>;
        /**
         * Voltage threshold. 'level' must be provided.
         */
        voltage?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdVoltage>;
        /**
         * Water detection threshold. 'present' must be provided and set to true.
         */
        water?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdWater>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdApparentPower {
        /**
         * Alerting threshold in volt-amps. Must be between 0 and 3750.
         */
        draw?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdCurrent {
        /**
         * Alerting threshold in amps. Must be between 0 and 15.
         */
        draw?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdDoor {
        /**
         * Alerting threshold for a door open event. Must be set to true.
         */
        open?: pulumi.Input<boolean>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdFrequency {
        /**
         * Alerting threshold in hertz. Must be between 0 and 60.
         */
        level?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdHumidity {
        /**
         * Alerting threshold as a qualitative humidity level.
         */
        quality?: pulumi.Input<string>;
        /**
         * Alerting threshold in %RH.
         */
        relativePercentage?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality {
        /**
         * Alerting threshold as a qualitative indoor air quality level.
         */
        quality?: pulumi.Input<string>;
        /**
         * Alerting threshold as indoor air quality score.
         */
        score?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdNoise {
        /**
         * Ambient noise threshold. One of 'level' or 'quality' must be provided.
         */
        ambient?: pulumi.Input<inputs.networks.SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient {
        /**
         * Alerting threshold as adjusted decibels.
         */
        level?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative ambient noise level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdPm25 {
        /**
         * Alerting threshold as PM2.5 parts per million.
         */
        concentration?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative PM2.5 level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdPowerFactor {
        /**
         * Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
         */
        percentage?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdRealPower {
        /**
         * Alerting threshold in watts. Must be between 0 and 3750.
         */
        draw?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdTemperature {
        /**
         * Alerting threshold in degrees Celsius.
         */
        celsius?: pulumi.Input<number>;
        /**
         * Alerting threshold in degrees Fahrenheit.
         */
        fahrenheit?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative temperature level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdTvoc {
        /**
         * Alerting threshold as TVOC micrograms per cubic meter.
         */
        concentration?: pulumi.Input<number>;
        /**
         * Alerting threshold as a qualitative TVOC level.
         */
        quality?: pulumi.Input<string>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdUpstreamPower {
        /**
         * Alerting threshold for an upstream power event. Must be set to true.
         */
        outageDetected?: pulumi.Input<boolean>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdVoltage {
        /**
         * Alerting threshold in volts. Must be between 0 and 250.
         */
        level?: pulumi.Input<number>;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdWater {
        /**
         * Alerting threshold for a water detection event. Must be set to true.
         */
        present?: pulumi.Input<boolean>;
    }

    export interface SensorAlertsProfilesRecipients {
        /**
         * A list of emails that will receive information about the alert.
         */
        emails?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of webhook endpoint IDs that will receive information about the alert.
         */
        httpServerIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list of SMS numbers that will receive information about the alert.
         */
        smsNumbers?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SensorAlertsProfilesSchedule {
        /**
         * ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the sensor schedule to use with the alert profile.
         */
        name?: pulumi.Input<string>;
    }

    export interface SettingsFips {
        /**
         * Enables / disables FIPS on the network.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingsLocalStatusPage {
        /**
         * A hash of Local Status page(s)' authentication options applied to the Network.
         */
        authentication?: pulumi.Input<inputs.networks.SettingsLocalStatusPageAuthentication>;
    }

    export interface SettingsLocalStatusPageAuthentication {
        /**
         * Enables / disables the authentication on Local Status page(s).
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * The password used for Local Status Page(s). Set this to null to clear the password.
         */
        password?: pulumi.Input<string>;
        /**
         * The username used for Local Status Page(s).
         */
        username?: pulumi.Input<string>;
    }

    export interface SettingsNamedVlans {
        /**
         * Enables / disables Named VLANs on the Network.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SettingsSecurePort {
        /**
         * Enables / disables SecureConnect on the network. Optional.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SmBypassActivationLockAttemptsData {
        status2090938209?: pulumi.Input<inputs.networks.SmBypassActivationLockAttemptsDataStatus2090938209>;
        status38290139892?: pulumi.Input<inputs.networks.SmBypassActivationLockAttemptsDataStatus38290139892>;
    }

    export interface SmBypassActivationLockAttemptsDataStatus2090938209 {
        errors?: pulumi.Input<pulumi.Input<string>[]>;
        success?: pulumi.Input<boolean>;
    }

    export interface SmBypassActivationLockAttemptsDataStatus38290139892 {
        success?: pulumi.Input<boolean>;
    }

    export interface SmDevicesCheckinItem {
        /**
         * The Meraki Ids of the set of devices.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesCheckinParameters {
        /**
         * The ids of the devices to be checked-in.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices to be checked-in.
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The wifiMacs of the devices to be checked-in.
         */
        wifiMacs?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesFieldsItem {
        /**
         * The Meraki Id of the device record.
         */
        id?: pulumi.Input<string>;
        /**
         * The name of the device.
         */
        name?: pulumi.Input<string>;
        /**
         * Notes associated with the device.
         */
        notes?: pulumi.Input<string>;
        /**
         * The device serial.
         */
        serial?: pulumi.Input<string>;
        /**
         * The MAC of the device.
         */
        wifiMac?: pulumi.Input<string>;
    }

    export interface SmDevicesFieldsParameters {
        /**
         * The new fields of the device. Each field of this object is optional.
         */
        deviceFields?: pulumi.Input<inputs.networks.SmDevicesFieldsParametersDeviceFields>;
        /**
         * The id of the device to be modified.
         */
        id?: pulumi.Input<string>;
        /**
         * The serial of the device to be modified.
         */
        serial?: pulumi.Input<string>;
        /**
         * The wifiMac of the device to be modified.
         */
        wifiMac?: pulumi.Input<string>;
    }

    export interface SmDevicesFieldsParametersDeviceFields {
        /**
         * New name for the device
         */
        name?: pulumi.Input<string>;
        /**
         * New notes for the device
         */
        notes?: pulumi.Input<string>;
    }

    export interface SmDevicesInstallAppsParameters {
        /**
         * ids of applications to be installed
         */
        appIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * By default, installation of an app which is believed to already be present on the device will be skipped. If you'd like to force the installation of the app, set this parameter to true.
         */
        force?: pulumi.Input<boolean>;
    }

    export interface SmDevicesLockItem {
        /**
         * The Meraki Ids of the set of devices.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesLockParameters {
        /**
         * The ids of the devices to be locked.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
         */
        pin?: pulumi.Input<number>;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices to be locked.
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The wifiMacs of the devices to be locked.
         */
        wifiMacs?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesModifyTagsItem {
        /**
         * The Meraki Id of the device record.
         */
        id?: pulumi.Input<string>;
        /**
         * The device serial.
         */
        serial?: pulumi.Input<string>;
        /**
         * An array of tags associated with the device.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The MAC of the device.
         */
        wifiMac?: pulumi.Input<string>;
    }

    export interface SmDevicesModifyTagsParameters {
        /**
         * The ids of the devices to be modified.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices to be modified.
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The tags to be added, deleted, or updated.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * One of add, delete, or update. Only devices that have been modified will be returned.
         */
        updateAction?: pulumi.Input<string>;
        /**
         * The wifiMacs of the devices to be modified.
         */
        wifiMacs?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesMoveItem {
        /**
         * The Meraki Ids of the set of devices.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The network to which the devices was moved.
         */
        newNetwork?: pulumi.Input<string>;
    }

    export interface SmDevicesMoveParameters {
        /**
         * The ids of the devices to be moved.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The new network to which the devices will be moved.
         */
        newNetwork?: pulumi.Input<string>;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices to be moved.
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The wifiMacs of the devices to be moved.
         */
        wifiMacs?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesRebootItem {
        /**
         * The Meraki Ids of the set of endpoints.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesRebootParameters {
        /**
         * The ids of the endpoints to be rebooted.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The KextPaths of the endpoints to be rebooted. Available for macOS 11+
         */
        kextPaths?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Whether or not to notify the user before rebooting the endpoint. Available for macOS 11.3+
         */
        notifyUser?: pulumi.Input<boolean>;
        /**
         * Whether or not to rebuild the kernel cache when rebooting the endpoint. Available for macOS 11+
         */
        rebuildKernelCache?: pulumi.Input<boolean>;
        /**
         * Whether or not the request requires network tethering. Available for macOS and supervised iOS or tvOS
         */
        requestRequiresNetworkTether?: pulumi.Input<boolean>;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be rebooted.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the endpoints to be rebooted.
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The wifiMacs of the endpoints to be rebooted.
         */
        wifiMacs?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesShutdownItem {
        /**
         * The Meraki Ids of the set of endpoints.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesShutdownParameters {
        /**
         * The ids of the endpoints to be shutdown.
         */
        ids?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be shutdown.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the endpoints to be shutdown.
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The wifiMacs of the endpoints to be shutdown.
         */
        wifiMacs?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesUnenrollItem {
        /**
         * Boolean indicating whether the operation was completed successfully.
         */
        success?: pulumi.Input<boolean>;
    }

    export interface SmDevicesUninstallAppsParameters {
        /**
         * ids of applications to be uninstalled
         */
        appIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmDevicesWipeItem {
        /**
         * The Meraki Id of the devices.
         */
        id?: pulumi.Input<string>;
    }

    export interface SmDevicesWipeParameters {
        /**
         * The id of the device to be wiped.
         */
        id?: pulumi.Input<string>;
        /**
         * The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
         */
        pin?: pulumi.Input<number>;
        /**
         * The serial of the device to be wiped.
         */
        serial?: pulumi.Input<string>;
        /**
         * The wifiMac of the device to be wiped.
         */
        wifiMac?: pulumi.Input<string>;
    }

    export interface SnmpUser {
        /**
         * The passphrase for the SNMP user.
         */
        passphrase?: pulumi.Input<string>;
        /**
         * The username for the SNMP user.
         */
        username?: pulumi.Input<string>;
    }

    export interface SplitItem {
        /**
         * Networks after the split
         */
        resultingNetworks?: pulumi.Input<pulumi.Input<inputs.networks.SplitItemResultingNetwork>[]>;
    }

    export interface SplitItemResultingNetwork {
        /**
         * Enrollment string for the network
         */
        enrollmentString?: pulumi.Input<string>;
        /**
         * Network ID
         */
        id?: pulumi.Input<string>;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate?: pulumi.Input<boolean>;
        /**
         * Network name
         */
        name?: pulumi.Input<string>;
        /**
         * Notes for the network
         */
        notes?: pulumi.Input<string>;
        /**
         * Organization ID
         */
        organizationId?: pulumi.Input<string>;
        /**
         * List of the product types that the network supports
         */
        productTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network tags
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Timezone of the network
         */
        timeZone?: pulumi.Input<string>;
        /**
         * URL to the network Dashboard UI
         */
        url?: pulumi.Input<string>;
    }

    export interface SwitchAccessControlListsRule {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Destination IP address (in IP or CIDR notation)
         */
        dstCidr?: pulumi.Input<string>;
        /**
         * Destination port
         */
        dstPort?: pulumi.Input<string>;
        /**
         * IP address version
         */
        ipVersion?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol
         */
        protocol?: pulumi.Input<string>;
        /**
         * Source IP address (in IP or CIDR notation)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Source port
         */
        srcPort?: pulumi.Input<string>;
        /**
         * ncoming traffic VLAN
         */
        vlan?: pulumi.Input<string>;
    }

    export interface SwitchAccessControlListsRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Destination IP address (in IP or CIDR notation)
         */
        dstCidr?: pulumi.Input<string>;
        /**
         * Destination port
         */
        dstPort?: pulumi.Input<string>;
        /**
         * IP address version
         */
        ipVersion?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol
         */
        protocol?: pulumi.Input<string>;
        /**
         * Source IP address (in IP or CIDR notation)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Source port
         */
        srcPort?: pulumi.Input<string>;
        /**
         * ncoming traffic VLAN
         */
        vlan?: pulumi.Input<string>;
    }

    export interface SwitchAccessPoliciesCounts {
        /**
         * Counts associated with ports
         */
        ports?: pulumi.Input<inputs.networks.SwitchAccessPoliciesCountsPorts>;
    }

    export interface SwitchAccessPoliciesCountsPorts {
        /**
         * Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
         */
        withThisPolicy?: pulumi.Input<number>;
    }

    export interface SwitchAccessPoliciesDot1x {
        /**
         * Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
         */
        controlDirection?: pulumi.Input<string>;
    }

    export interface SwitchAccessPoliciesRadius {
        /**
         * Critical auth settings for when authentication is rejected by the RADIUS server
         */
        criticalAuth?: pulumi.Input<inputs.networks.SwitchAccessPoliciesRadiusCriticalAuth>;
        /**
         * VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        failedAuthVlanId?: pulumi.Input<number>;
        /**
         * Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
         */
        reAuthenticationInterval?: pulumi.Input<number>;
    }

    export interface SwitchAccessPoliciesRadiusAccountingServer {
        /**
         * Public IP address of the RADIUS accounting server
         */
        host?: pulumi.Input<string>;
        /**
         * UDP port that the RADIUS Accounting server listens on for access requests
         */
        port?: pulumi.Input<number>;
        /**
         * RADIUS client shared secret
         */
        secret?: pulumi.Input<string>;
    }

    export interface SwitchAccessPoliciesRadiusAccountingServersResponse {
        /**
         * Public IP address of the RADIUS accounting server
         */
        host?: pulumi.Input<string>;
        /**
         * UDP port that the RADIUS Accounting server listens on for access requests
         */
        port?: pulumi.Input<number>;
        /**
         * RADIUS client shared secret
         */
        secret?: pulumi.Input<string>;
    }

    export interface SwitchAccessPoliciesRadiusCriticalAuth {
        /**
         * VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        dataVlanId?: pulumi.Input<number>;
        /**
         * Enable to suspend port bounce when RADIUS servers are unreachable
         */
        suspendPortBounce?: pulumi.Input<boolean>;
        /**
         * VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        voiceVlanId?: pulumi.Input<number>;
    }

    export interface SwitchAccessPoliciesRadiusServer {
        /**
         * Public IP address of the RADIUS server
         */
        host?: pulumi.Input<string>;
        /**
         * UDP port that the RADIUS server listens on for access requests
         */
        port?: pulumi.Input<number>;
        /**
         * RADIUS client shared secret
         */
        secret?: pulumi.Input<string>;
    }

    export interface SwitchAccessPoliciesRadiusServersResponse {
        /**
         * Public IP address of the RADIUS server
         */
        host?: pulumi.Input<string>;
        /**
         * UDP port that the RADIUS server listens on for access requests
         */
        port?: pulumi.Input<number>;
        /**
         * RADIUS client shared secret
         */
        secret?: pulumi.Input<string>;
    }

    export interface SwitchAlternateManagementInterfaceSwitch {
        /**
         * Switch alternative management IP. To remove a prior IP setting, provide an empty string
         */
        alternateManagementIp?: pulumi.Input<string>;
        /**
         * Switch gateway must be in IP format. Only and must be specified for Polaris switches
         */
        gateway?: pulumi.Input<string>;
        /**
         * Switch serial number
         */
        serial?: pulumi.Input<string>;
        /**
         * Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
         */
        subnetMask?: pulumi.Input<string>;
    }

    export interface SwitchDhcpServerPolicyAlerts {
        /**
         * Alert settings for DHCP servers
         */
        email?: pulumi.Input<inputs.networks.SwitchDhcpServerPolicyAlertsEmail>;
    }

    export interface SwitchDhcpServerPolicyAlertsEmail {
        /**
         * When enabled, send an email if a new DHCP server is seen. Default value is false.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SwitchDhcpServerPolicyArpInspection {
        /**
         * Enable or disable Dynamic ARP Inspection on the network. Default value is false.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * List of switch models that does not support dynamic ARP inspection
         */
        unsupportedModels?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4 {
        /**
         * IPv4 address of the trusted server.
         */
        address?: pulumi.Input<string>;
    }

    export interface SwitchDscpToCosMappingsMapping {
        /**
         * The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
         */
        cos?: pulumi.Input<number>;
        /**
         * The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
         */
        dscp?: pulumi.Input<number>;
        /**
         * Label for the mapping (optional).
         */
        title?: pulumi.Input<string>;
    }

    export interface SwitchLinkAggregationsSwitchPort {
        /**
         * Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
         */
        portId?: pulumi.Input<string>;
        /**
         * Serial number of the switch.
         */
        serial?: pulumi.Input<string>;
    }

    export interface SwitchLinkAggregationsSwitchProfilePort {
        /**
         * Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
         */
        portId?: pulumi.Input<string>;
        /**
         * Profile identifier.
         */
        profile?: pulumi.Input<string>;
    }

    export interface SwitchMtuOverride {
        /**
         * MTU size for the switches or switch templates.
         */
        mtuSize?: pulumi.Input<number>;
        /**
         * List of switch template IDs. Applicable only for template network.
         */
        switchProfiles?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of switch serials. Applicable only for switch network.
         */
        switches?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchPortSchedulesPortSchedule {
        /**
         * The schedule object for Friday.
         */
        friday?: pulumi.Input<inputs.networks.SwitchPortSchedulesPortScheduleFriday>;
        /**
         * The schedule object for Monday.
         */
        monday?: pulumi.Input<inputs.networks.SwitchPortSchedulesPortScheduleMonday>;
        /**
         * The schedule object for Saturday.
         */
        saturday?: pulumi.Input<inputs.networks.SwitchPortSchedulesPortScheduleSaturday>;
        /**
         * The schedule object for Sunday.
         */
        sunday?: pulumi.Input<inputs.networks.SwitchPortSchedulesPortScheduleSunday>;
        /**
         * The schedule object for Thursday.
         */
        thursday?: pulumi.Input<inputs.networks.SwitchPortSchedulesPortScheduleThursday>;
        /**
         * The schedule object for Tuesday.
         */
        tuesday?: pulumi.Input<inputs.networks.SwitchPortSchedulesPortScheduleTuesday>;
        /**
         * The schedule object for Wednesday.
         */
        wednesday?: pulumi.Input<inputs.networks.SwitchPortSchedulesPortScheduleWednesday>;
    }

    export interface SwitchPortSchedulesPortScheduleFriday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface SwitchPortSchedulesPortScheduleMonday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface SwitchPortSchedulesPortScheduleSaturday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface SwitchPortSchedulesPortScheduleSunday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface SwitchPortSchedulesPortScheduleThursday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface SwitchPortSchedulesPortScheduleTuesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface SwitchPortSchedulesPortScheduleWednesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active?: pulumi.Input<boolean>;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from?: pulumi.Input<string>;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to?: pulumi.Input<string>;
    }

    export interface SwitchRoutingMulticastDefaultSettings {
        /**
         * Flood unknown multicast traffic enabled for the entire network
         */
        floodUnknownMulticastTrafficEnabled?: pulumi.Input<boolean>;
        /**
         * IGMP snooping enabled for the entire network
         */
        igmpSnoopingEnabled?: pulumi.Input<boolean>;
    }

    export interface SwitchRoutingMulticastOverride {
        /**
         * Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
         */
        floodUnknownMulticastTrafficEnabled?: pulumi.Input<boolean>;
        /**
         * IGMP snooping enabled for switches, switch stacks or switch templates
         */
        igmpSnoopingEnabled?: pulumi.Input<boolean>;
        /**
         * (optional) List of switch stack ids for non-template network
         */
        stacks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (optional) List of switch templates ids for template network
         */
        switchProfiles?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * (optional) List of switch serials for non-template network
         */
        switches?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchRoutingOspfArea {
        /**
         * OSPF area ID
         */
        areaId?: pulumi.Input<string>;
        /**
         * Name of the OSPF area
         */
        areaName?: pulumi.Input<string>;
        /**
         * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
         */
        areaType?: pulumi.Input<string>;
    }

    export interface SwitchRoutingOspfMd5AuthenticationKey {
        /**
         * MD5 authentication key index. Key index must be between 1 to 255
         */
        id?: pulumi.Input<number>;
        /**
         * MD5 authentication passphrase
         */
        passphrase?: pulumi.Input<string>;
    }

    export interface SwitchRoutingOspfV3 {
        /**
         * OSPF v3 areas
         */
        areas?: pulumi.Input<pulumi.Input<inputs.networks.SwitchRoutingOspfV3Area>[]>;
        /**
         * Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
         */
        deadTimerInSeconds?: pulumi.Input<number>;
        /**
         * Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
         */
        helloTimerInSeconds?: pulumi.Input<number>;
    }

    export interface SwitchRoutingOspfV3Area {
        /**
         * OSPF area ID
         */
        areaId?: pulumi.Input<string>;
        /**
         * Name of the OSPF area
         */
        areaName?: pulumi.Input<string>;
        /**
         * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
         */
        areaType?: pulumi.Input<string>;
    }

    export interface SwitchSettingsMacBlocklist {
        /**
         * Enable MAC blocklist for switches in the network
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SwitchSettingsPowerException {
        /**
         * Per switch exception (combined, redundant, useNetworkSetting)
         */
        powerType?: pulumi.Input<string>;
        /**
         * Serial number of the switch
         */
        serial?: pulumi.Input<string>;
    }

    export interface SwitchSettingsUplinkClientSampling {
        /**
         * Enable client sampling on uplink
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface SwitchStacksAddItem {
        /**
         * ID of the Switch stack
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the Switch stack
         */
        name?: pulumi.Input<string>;
        /**
         * Serials of the switches in the switch stack
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchStacksAddParameters {
        /**
         * The serial of the switch to be added
         */
        serial?: pulumi.Input<string>;
    }

    export interface SwitchStacksRemoveItem {
        /**
         * ID of the Switch stack
         */
        id?: pulumi.Input<string>;
        /**
         * Name of the Switch stack
         */
        name?: pulumi.Input<string>;
        /**
         * Serials of the switches in the switch stack
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchStacksRemoveParameters {
        /**
         * The serial of the switch to be removed
         */
        serial?: pulumi.Input<string>;
    }

    export interface SwitchStacksRoutingInterfacesDhcpDhcpOption {
        /**
         * The code for DHCP option which should be from 2 to 254
         */
        code?: pulumi.Input<string>;
        /**
         * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
         */
        type?: pulumi.Input<string>;
        /**
         * The value of the DHCP option
         */
        value?: pulumi.Input<string>;
    }

    export interface SwitchStacksRoutingInterfacesDhcpFixedIpAssignment {
        /**
         * The IP address of the client which has fixed IP address assigned to it
         */
        ip?: pulumi.Input<string>;
        /**
         * The MAC address of the client which has fixed IP address
         */
        mac?: pulumi.Input<string>;
        /**
         * The name of the client which has fixed IP address
         */
        name?: pulumi.Input<string>;
    }

    export interface SwitchStacksRoutingInterfacesDhcpReservedIpRange {
        /**
         * The comment for the reserved IP range
         */
        comment?: pulumi.Input<string>;
        /**
         * The ending IP address of the reserved IP range
         */
        end?: pulumi.Input<string>;
        /**
         * The starting IP address of the reserved IP range
         */
        start?: pulumi.Input<string>;
    }

    export interface SwitchStacksRoutingInterfacesIpv6 {
        /**
         * IPv6 address
         */
        address?: pulumi.Input<string>;
        /**
         * Assignment mode
         */
        assignmentMode?: pulumi.Input<string>;
        /**
         * IPv6 gateway
         */
        gateway?: pulumi.Input<string>;
        /**
         * IPv6 subnet
         */
        prefix?: pulumi.Input<string>;
    }

    export interface SwitchStacksRoutingInterfacesOspfSettings {
        /**
         * Area id
         */
        area?: pulumi.Input<string>;
        /**
         * OSPF Cost
         */
        cost?: pulumi.Input<number>;
        /**
         * Disable sending Hello packets on this interface's IPv4 area
         */
        isPassiveEnabled?: pulumi.Input<boolean>;
    }

    export interface SwitchStacksRoutingInterfacesOspfV3 {
        /**
         * Area id
         */
        area?: pulumi.Input<string>;
        /**
         * OSPF Cost
         */
        cost?: pulumi.Input<number>;
        /**
         * Disable sending Hello packets on this interface's IPv6 area
         */
        isPassiveEnabled?: pulumi.Input<boolean>;
    }

    export interface SwitchStpStpBridgePriority {
        /**
         * List of stack IDs
         */
        stacks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * STP priority for switch, stacks, or switch profiles
         */
        stpPriority?: pulumi.Input<number>;
        /**
         * List of switch profile IDs
         */
        switchProfiles?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of switch serial numbers
         */
        switches?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchStpStpBridgePriorityResponse {
        /**
         * List of stack IDs
         */
        stacks?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * STP priority for switch, stacks, or switch templates
         */
        stpPriority?: pulumi.Input<number>;
        /**
         * List of switch template IDs
         */
        switchProfiles?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of switch serial numbers
         */
        switches?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SyslogServersServer {
        /**
         * The IP address of the syslog server
         */
        host?: pulumi.Input<string>;
        /**
         * The port of the syslog server
         */
        port?: pulumi.Input<number>;
        /**
         * A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
         */
        roles?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TrafficAnalysisCustomPieChartItem {
        /**
         * The name of the custom pie chart item.
         */
        name?: pulumi.Input<string>;
        /**
         * The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
         */
        type?: pulumi.Input<string>;
        /**
         * The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
         * (see sample request/response for more details).
         */
        value?: pulumi.Input<string>;
    }

    export interface UnbindItem {
        /**
         * Enrollment string for the network
         */
        enrollmentString?: pulumi.Input<string>;
        /**
         * Network ID
         */
        id?: pulumi.Input<string>;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate?: pulumi.Input<boolean>;
        /**
         * Network name
         */
        name?: pulumi.Input<string>;
        /**
         * Notes for the network
         */
        notes?: pulumi.Input<string>;
        /**
         * Organization ID
         */
        organizationId?: pulumi.Input<string>;
        /**
         * List of the product types that the network supports
         */
        productTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network tags
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Timezone of the network
         */
        timeZone?: pulumi.Input<string>;
        /**
         * URL to the network Dashboard UI
         */
        url?: pulumi.Input<string>;
    }

    export interface UnbindParameters {
        /**
         * Optional boolean to retain all the current configs given by the template.
         */
        retainConfigs?: pulumi.Input<boolean>;
    }

    export interface VlanProfilesAssignmentsReassignItem {
        /**
         * Array of Device Serials
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Array of Switch Stack IDs
         */
        stackIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The VLAN Profile
         */
        vlanProfile?: pulumi.Input<inputs.networks.VlanProfilesAssignmentsReassignItemVlanProfile>;
    }

    export interface VlanProfilesAssignmentsReassignItemVlanProfile {
        /**
         * IName of the VLAN Profile
         */
        iname?: pulumi.Input<string>;
        /**
         * Name of the VLAN Profile
         */
        name?: pulumi.Input<string>;
    }

    export interface VlanProfilesAssignmentsReassignParameters {
        /**
         * Array of Device Serials
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Array of Switch Stack IDs
         */
        stackIds?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The VLAN Profile
         */
        vlanProfile?: pulumi.Input<inputs.networks.VlanProfilesAssignmentsReassignParametersVlanProfile>;
    }

    export interface VlanProfilesAssignmentsReassignParametersVlanProfile {
        /**
         * IName of the VLAN Profile
         */
        iname?: pulumi.Input<string>;
    }

    export interface VlanProfilesVlanGroup {
        /**
         * Name of the VLAN, string length must be from 1 to 32 characters
         */
        name?: pulumi.Input<string>;
        /**
         * Comma-separated VLAN IDs or ID ranges
         */
        vlanIds?: pulumi.Input<string>;
    }

    export interface VlanProfilesVlanName {
        /**
         * Adaptive Policy Group assigned to Vlan ID
         */
        adaptivePolicyGroup?: pulumi.Input<inputs.networks.VlanProfilesVlanNameAdaptivePolicyGroup>;
        /**
         * Name of the VLAN, string length must be from 1 to 32 characters
         */
        name?: pulumi.Input<string>;
        /**
         * VLAN ID
         */
        vlanId?: pulumi.Input<string>;
    }

    export interface VlanProfilesVlanNameAdaptivePolicyGroup {
        /**
         * Adaptive Policy Group ID
         */
        id?: pulumi.Input<string>;
        /**
         * Adaptive Policy Group name
         */
        name?: pulumi.Input<string>;
    }

    export interface WebhooksHttpServersPayloadTemplate {
        /**
         * The name of the payload template.
         */
        name?: pulumi.Input<string>;
        /**
         * The ID of the payload template.
         */
        payloadTemplateId?: pulumi.Input<string>;
    }

    export interface WebhooksPayloadTemplatesHeader {
        /**
         * The name of the header attribute
         */
        name?: pulumi.Input<string>;
        /**
         * The value returned in the header attribute, in liquid template
         */
        template?: pulumi.Input<string>;
    }

    export interface WebhooksPayloadTemplatesSharing {
        /**
         * Information on network access to the template
         */
        byNetwork?: pulumi.Input<inputs.networks.WebhooksPayloadTemplatesSharingByNetwork>;
    }

    export interface WebhooksPayloadTemplatesSharingByNetwork {
        /**
         * Indicates whether network admins may modify this template
         */
        adminsCanModify?: pulumi.Input<boolean>;
    }

    export interface WirelessAlternateManagementInterfaceAccessPoint {
        /**
         * Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
         */
        alternateManagementIp?: pulumi.Input<string>;
        /**
         * Primary DNS must be in IP format
         */
        dns1?: pulumi.Input<string>;
        /**
         * Optional secondary DNS must be in IP format
         */
        dns2?: pulumi.Input<string>;
        /**
         * Gateway must be in IP format
         */
        gateway?: pulumi.Input<string>;
        /**
         * Serial number of access point to be configured with alternate management IP
         */
        serial?: pulumi.Input<string>;
        /**
         * Subnet mask must be in IP format
         */
        subnetMask?: pulumi.Input<string>;
    }

    export interface WirelessBillingPlan {
        /**
         * The uplink bandwidth settings for the pricing plan.
         */
        bandwidthLimits?: pulumi.Input<inputs.networks.WirelessBillingPlanBandwidthLimits>;
        /**
         * The id of the pricing plan to update.
         */
        id?: pulumi.Input<string>;
        /**
         * The price of the billing plan.
         */
        price?: pulumi.Input<number>;
        /**
         * The time limit of the pricing plan in minutes.
         */
        timeLimit?: pulumi.Input<string>;
    }

    export interface WirelessBillingPlanBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown?: pulumi.Input<number>;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface WirelessEthernetPortsProfilesAssignItem {
        /**
         * AP profile ID
         */
        profileId?: pulumi.Input<string>;
        /**
         * List of updated AP serials
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessEthernetPortsProfilesAssignParameters {
        /**
         * AP profile ID
         */
        profileId?: pulumi.Input<string>;
        /**
         * List of AP serials
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessEthernetPortsProfilesPort {
        /**
         * Enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Name
         */
        name?: pulumi.Input<string>;
        /**
         * Number
         */
        number?: pulumi.Input<number>;
        /**
         * PSK Group number
         */
        pskGroupId?: pulumi.Input<string>;
        /**
         * Ssid number
         */
        ssid?: pulumi.Input<number>;
    }

    export interface WirelessEthernetPortsProfilesSetDefaultItem {
        /**
         * AP profile ID
         */
        profileId?: pulumi.Input<string>;
    }

    export interface WirelessEthernetPortsProfilesSetDefaultParameters {
        /**
         * AP profile ID
         */
        profileId?: pulumi.Input<string>;
    }

    export interface WirelessEthernetPortsProfilesUsbPort {
        /**
         * Enabled
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Name
         */
        name?: pulumi.Input<string>;
        /**
         * Ssid number
         */
        ssid?: pulumi.Input<number>;
    }

    export interface WirelessRfProfilesApBandSettings {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band. Can be either true or false. Defaults to true.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesApBandSettingsBands>;
    }

    export interface WirelessRfProfilesApBandSettingsBands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesFiveGhzSettings {
        /**
         * Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
         */
        channelWidth?: pulumi.Input<string>;
        /**
         * Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower?: pulumi.Input<number>;
        /**
         * Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
         */
        minPower?: pulumi.Input<number>;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop?: pulumi.Input<number>;
        /**
         * Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
         */
        validAutoChannels?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface WirelessRfProfilesFlexRadios {
        /**
         * Flex radios by model.
         */
        byModels?: pulumi.Input<pulumi.Input<inputs.networks.WirelessRfProfilesFlexRadiosByModel>[]>;
    }

    export interface WirelessRfProfilesFlexRadiosByModel {
        /**
         * Band to use for each flex radio. For example, ['6'] will set the AP's first flex radio to 6 GHz
         */
        bands?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Model of the AP
         */
        model?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettings {
        /**
         * Settings for SSID 0
         */
        status0?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus0>;
        /**
         * Settings for SSID 1
         */
        status1?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus1>;
        /**
         * Settings for SSID 10
         */
        status10?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus10>;
        /**
         * Settings for SSID 11
         */
        status11?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus11>;
        /**
         * Settings for SSID 12
         */
        status12?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus12>;
        /**
         * Settings for SSID 13
         */
        status13?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus13>;
        /**
         * Settings for SSID 14
         */
        status14?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus14>;
        /**
         * Settings for SSID 2
         */
        status2?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus2>;
        /**
         * Settings for SSID 3
         */
        status3?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus3>;
        /**
         * Settings for SSID 4
         */
        status4?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus4>;
        /**
         * Settings for SSID 5
         */
        status5?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus5>;
        /**
         * Settings for SSID 6
         */
        status6?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus6>;
        /**
         * Settings for SSID 7
         */
        status7?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus7>;
        /**
         * Settings for SSID 8
         */
        status8?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus8>;
        /**
         * Settings for SSID 9
         */
        status9?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus9>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus0 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus0Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus0Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus1 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus1Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus10 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus10Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus10Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus11 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus11Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus11Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus12 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus12Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus12Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus13 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus13Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus13Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus14 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus14Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus14Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus1Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus2 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus2Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus2Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus3 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus3Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus3Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus4 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus4Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus4Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus5 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus5Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus5Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus6 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus6Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus6Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus7 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus7Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus7Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus8 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus8Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus8Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus9 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode?: pulumi.Input<string>;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled?: pulumi.Input<boolean>;
        /**
         * Settings related to all bands
         */
        bands?: pulumi.Input<inputs.networks.WirelessRfProfilesPerSsidSettingsStatus9Bands>;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Name of SSID
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus9Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessRfProfilesSixGhzSettings {
        /**
         * Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
         */
        channelWidth?: pulumi.Input<string>;
        /**
         * Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower?: pulumi.Input<number>;
        /**
         * Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
         */
        minPower?: pulumi.Input<number>;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop?: pulumi.Input<number>;
        /**
         * Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
         */
        validAutoChannels?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface WirelessRfProfilesTransmission {
        /**
         * Toggle for radio transmission. When false, radios will not transmit at all.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessRfProfilesTwoFourGhzSettings {
        /**
         * Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
         */
        axEnabled?: pulumi.Input<boolean>;
        /**
         * Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower?: pulumi.Input<number>;
        /**
         * Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
         */
        minBitrate?: pulumi.Input<number>;
        /**
         * Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
         */
        minPower?: pulumi.Input<number>;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop?: pulumi.Input<number>;
        /**
         * Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
         */
        validAutoChannels?: pulumi.Input<pulumi.Input<number>[]>;
    }

    export interface WirelessSettingsNamedVlans {
        /**
         * Named VLAN Pool DHCP Monitoring settings.
         */
        poolDhcpMonitoring?: pulumi.Input<inputs.networks.WirelessSettingsNamedVlansPoolDhcpMonitoring>;
    }

    export interface WirelessSettingsNamedVlansPoolDhcpMonitoring {
        /**
         * The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
         */
        duration?: pulumi.Input<number>;
        /**
         * Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSettingsRegulatoryDomain {
        /**
         * The country code of the regulatory domain.
         */
        countryCode?: pulumi.Input<string>;
        /**
         * The name of the regulatory domain for this network.
         */
        name?: pulumi.Input<string>;
        /**
         * Whether or not the regulatory domain for this network permits Wifi 6E.
         */
        permits6e?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsActiveDirectory {
        /**
         * (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
         */
        credentials?: pulumi.Input<inputs.networks.WirelessSsidsActiveDirectoryCredentials>;
        /**
         * The Active Directory servers to be used for authentication.
         */
        servers?: pulumi.Input<pulumi.Input<inputs.networks.WirelessSsidsActiveDirectoryServer>[]>;
    }

    export interface WirelessSsidsActiveDirectoryCredentials {
        /**
         * The logon name of the Active Directory account.
         */
        logonName?: pulumi.Input<string>;
        /**
         * The password to the Active Directory user account.
         */
        password?: pulumi.Input<string>;
    }

    export interface WirelessSsidsActiveDirectoryServer {
        /**
         * IP address (or FQDN) of your Active Directory server.
         */
        host?: pulumi.Input<string>;
        /**
         * (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
         */
        port?: pulumi.Input<number>;
    }

    export interface WirelessSsidsApTagsAndVlanId {
        /**
         * Array of AP tags
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Numerical identifier that is assigned to the VLAN
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface WirelessSsidsBonjourForwardingException {
        /**
         * If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsBonjourForwardingRule {
        /**
         * Desctiption of the bonjour forwarding rule
         */
        description?: pulumi.Input<string>;
        /**
         * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
         */
        services?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ID of the service VLAN. Required
         */
        vlanId?: pulumi.Input<string>;
    }

    export interface WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicy {
        /**
         * The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
         */
        devicePolicy?: pulumi.Input<string>;
        /**
         * The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
         */
        deviceType?: pulumi.Input<string>;
        /**
         * ID of the group policy object.
         */
        groupPolicyId?: pulumi.Input<number>;
    }

    export interface WirelessSsidsDnsRewrite {
        /**
         * User specified DNS servers (up to two servers)
         */
        dnsCustomNameservers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsDot11r {
        /**
         * (Optional) Whether 802.11r is adaptive or not.
         */
        adaptive?: pulumi.Input<boolean>;
        /**
         * Whether 802.11r is enabled or not.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsDot11w {
        /**
         * Whether 802.11w is enabled or not.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Optional) Whether 802.11w is required or not.
         */
        required?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsEapOverrideEapolKey {
        /**
         * Maximum number of EAPOL key retries.
         */
        retries?: pulumi.Input<number>;
        /**
         * EAPOL Key timeout in milliseconds.
         */
        timeoutInMs?: pulumi.Input<number>;
    }

    export interface WirelessSsidsEapOverrideIdentity {
        /**
         * Maximum number of EAP retries.
         */
        retries?: pulumi.Input<number>;
        /**
         * EAP timeout in seconds.
         */
        timeout?: pulumi.Input<number>;
    }

    export interface WirelessSsidsFirewallL3FirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * Ip Ver
         */
        ipVer?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
    }

    export interface WirelessSsidsFirewallL3FirewallRulesRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * Ip Version
         */
        ipVer?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
    }

    export interface WirelessSsidsFirewallL7FirewallRulesRule {
        /**
         * 'Deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
         */
        type?: pulumi.Input<string>;
        /**
         * The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
         */
        value?: pulumi.Input<string>;
        /**
         * The 'value_list' of what you want to block. Send a list in request
         */
        valueLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The 'value_obj' of what you want to block. Send a dict in request
         */
        valueObj?: pulumi.Input<inputs.networks.WirelessSsidsFirewallL7FirewallRulesRuleValueObj>;
    }

    export interface WirelessSsidsFirewallL7FirewallRulesRuleValueObj {
        id?: pulumi.Input<string>;
        name?: pulumi.Input<string>;
    }

    export interface WirelessSsidsGre {
        /**
         * The EoGRE concentrator's settings
         */
        concentrator?: pulumi.Input<inputs.networks.WirelessSsidsGreConcentrator>;
        /**
         * Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
         */
        key?: pulumi.Input<number>;
    }

    export interface WirelessSsidsGreConcentrator {
        /**
         * The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
         */
        host?: pulumi.Input<string>;
    }

    export interface WirelessSsidsHotspot20MccMnc {
        /**
         * MCC value
         */
        mcc?: pulumi.Input<string>;
        /**
         * MNC value
         */
        mnc?: pulumi.Input<string>;
    }

    export interface WirelessSsidsHotspot20NaiRealm {
        /**
         * The format for the realm ('1' or '0')
         */
        format?: pulumi.Input<string>;
        /**
         * An array of EAP methods for the realm.
         */
        methods?: pulumi.Input<pulumi.Input<inputs.networks.WirelessSsidsHotspot20NaiRealmMethod>[]>;
        name?: pulumi.Input<string>;
        /**
         * The name of the realm
         */
        realm?: pulumi.Input<string>;
    }

    export interface WirelessSsidsHotspot20NaiRealmMethod {
        /**
         * The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
         */
        authenticationTypes?: pulumi.Input<inputs.networks.WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes>;
        /**
         * ID of method
         */
        id?: pulumi.Input<string>;
    }

    export interface WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes {
        credentials?: pulumi.Input<pulumi.Input<string>[]>;
        eapinnerAuthentications?: pulumi.Input<pulumi.Input<string>[]>;
        nonEapinnerAuthentications?: pulumi.Input<pulumi.Input<string>[]>;
        tunneledEapMethodCredentials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessSsidsHotspot20Operator {
        /**
         * Operator name
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessSsidsHotspot20Venue {
        /**
         * Venue name
         */
        name?: pulumi.Input<string>;
        /**
         * Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
         */
        type?: pulumi.Input<string>;
    }

    export interface WirelessSsidsLdap {
        /**
         * The base distinguished name of users on the LDAP server.
         */
        baseDistinguishedName?: pulumi.Input<string>;
        /**
         * (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
         */
        credentials?: pulumi.Input<inputs.networks.WirelessSsidsLdapCredentials>;
        /**
         * The CA certificate used to sign the LDAP server's key.
         */
        serverCaCertificate?: pulumi.Input<inputs.networks.WirelessSsidsLdapServerCaCertificate>;
        /**
         * The LDAP servers to be used for authentication.
         */
        servers?: pulumi.Input<pulumi.Input<inputs.networks.WirelessSsidsLdapServer>[]>;
    }

    export interface WirelessSsidsLdapCredentials {
        /**
         * The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
         */
        distinguishedName?: pulumi.Input<string>;
        /**
         * The password of the LDAP user account.
         */
        password?: pulumi.Input<string>;
    }

    export interface WirelessSsidsLdapServer {
        /**
         * IP address (or FQDN) of your LDAP server.
         */
        host?: pulumi.Input<string>;
        /**
         * UDP port the LDAP server listens on.
         */
        port?: pulumi.Input<number>;
    }

    export interface WirelessSsidsLdapServerCaCertificate {
        /**
         * The contents of the CA certificate. Must be in PEM or DER format.
         */
        contents?: pulumi.Input<string>;
    }

    export interface WirelessSsidsLocalRadius {
        /**
         * The duration (in seconds) for which LDAP and OCSP lookups are cached.
         */
        cacheTimeout?: pulumi.Input<number>;
        /**
         * The current setting for certificate verification.
         */
        certificateAuthentication?: pulumi.Input<inputs.networks.WirelessSsidsLocalRadiusCertificateAuthentication>;
        /**
         * The current setting for password-based authentication.
         */
        passwordAuthentication?: pulumi.Input<inputs.networks.WirelessSsidsLocalRadiusPasswordAuthentication>;
    }

    export interface WirelessSsidsLocalRadiusCertificateAuthentication {
        /**
         * The Client CA Certificate used to sign the client certificate.
         */
        clientRootCaCertificate?: pulumi.Input<inputs.networks.WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate>;
        /**
         * Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * (Optional) The URL of the OCSP responder to verify client certificate status.
         */
        ocspResponderUrl?: pulumi.Input<string>;
        /**
         * Whether or not to verify the certificate with LDAP.
         */
        useLdap?: pulumi.Input<boolean>;
        /**
         * Whether or not to verify the certificate with OCSP.
         */
        useOcsp?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate {
        /**
         * The contents of the Client CA Certificate. Must be in PEM or DER format.
         */
        contents?: pulumi.Input<string>;
    }

    export interface WirelessSsidsLocalRadiusPasswordAuthentication {
        /**
         * Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsNamedVlans {
        /**
         * RADIUS settings. This param is only valid when authMode is 'open-with-radius' and ipAssignmentMode is not 'NAT mode'.
         */
        radius?: pulumi.Input<inputs.networks.WirelessSsidsNamedVlansRadius>;
        /**
         * VLAN tagging settings. This param is only valid when ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'.
         */
        tagging?: pulumi.Input<inputs.networks.WirelessSsidsNamedVlansTagging>;
    }

    export interface WirelessSsidsNamedVlansRadius {
        /**
         * Guest VLAN settings. Used to direct traffic to a guest VLAN when none of the RADIUS servers are reachable or a client receives access-reject from the RADIUS server.
         */
        guestVlan?: pulumi.Input<inputs.networks.WirelessSsidsNamedVlansRadiusGuestVlan>;
    }

    export interface WirelessSsidsNamedVlansRadiusGuestVlan {
        /**
         * Whether or not RADIUS guest named VLAN is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * RADIUS guest VLAN name.
         */
        name?: pulumi.Input<string>;
    }

    export interface WirelessSsidsNamedVlansTagging {
        /**
         * The list of AP tags and VLAN names used for named VLAN tagging. If an AP has a tag matching one in the list, then traffic on this SSID will be directed to use the VLAN name associated to the tag.
         */
        byApTags?: pulumi.Input<pulumi.Input<inputs.networks.WirelessSsidsNamedVlansTaggingByApTag>[]>;
        /**
         * The default VLAN name used to tag traffic in the absence of a matching AP tag.
         */
        defaultVlanName?: pulumi.Input<string>;
        /**
         * Whether or not traffic should be directed to use specific VLAN names.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsNamedVlansTaggingByApTag {
        /**
         * List of AP tags.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * VLAN name that will be used to tag traffic.
         */
        vlanName?: pulumi.Input<string>;
    }

    export interface WirelessSsidsOauth {
        /**
         * (Optional) The list of domains allowed access to the network.
         */
        allowedDomains?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface WirelessSsidsRadiusAccountingServer {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * IP address (or FQDN) to which the APs will send RADIUS accounting messages
         */
        host?: pulumi.Input<string>;
        /**
         * The ID of the Openroaming Certificate attached to radius server
         */
        openRoamingCertificateId?: pulumi.Input<number>;
        /**
         * Port on the RADIUS server that is listening for accounting messages
         */
        port?: pulumi.Input<number>;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
         */
        radsecEnabled?: pulumi.Input<boolean>;
        /**
         * Shared key used to authenticate messages between the APs and RADIUS server
         */
        secret?: pulumi.Input<string>;
    }

    export interface WirelessSsidsRadiusAccountingServersResponse {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * IP address (or FQDN) to which the APs will send RADIUS accounting messages
         */
        host?: pulumi.Input<string>;
        /**
         * The ID of the Openroaming Certificate attached to radius server
         */
        openRoamingCertificateId?: pulumi.Input<number>;
        /**
         * Port on the RADIUS server that is listening for accounting messages
         */
        port?: pulumi.Input<number>;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
         */
        radsecEnabled?: pulumi.Input<boolean>;
        /**
         * Shared key used to authenticate messages between the APs and RADIUS server
         */
        secret?: pulumi.Input<string>;
    }

    export interface WirelessSsidsRadiusServer {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * IP address of your RADIUS server
         */
        host?: pulumi.Input<string>;
        /**
         * The ID of the Openroaming Certificate attached to radius server.
         */
        openRoamingCertificateId?: pulumi.Input<number>;
        /**
         * UDP port the RADIUS server listens on for Access-requests
         */
        port?: pulumi.Input<number>;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
         */
        radsecEnabled?: pulumi.Input<boolean>;
        /**
         * RADIUS client shared secret
         */
        secret?: pulumi.Input<string>;
    }

    export interface WirelessSsidsRadiusServersResponse {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate?: pulumi.Input<string>;
        /**
         * IP address of your RADIUS server
         */
        host?: pulumi.Input<string>;
        /**
         * The ID of the Openroaming Certificate attached to radius server.
         */
        openRoamingCertificateId?: pulumi.Input<number>;
        /**
         * UDP port the RADIUS server listens on for Access-requests
         */
        port?: pulumi.Input<number>;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
         */
        radsecEnabled?: pulumi.Input<boolean>;
        /**
         * RADIUS client shared secret
         */
        secret?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSchedulesRange {
        /**
         * Day of when the outage ends. Can be either full day name, or three letter abbreviation
         */
        endDay?: pulumi.Input<string>;
        /**
         * 24 hour time when the outage ends.
         */
        endTime?: pulumi.Input<string>;
        /**
         * Day of when the outage starts. Can be either full day name, or three letter abbreviation.
         */
        startDay?: pulumi.Input<string>;
        /**
         * 24 hour time when the outage starts.
         */
        startTime?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSchedulesRangesInSecond {
        /**
         * Seconds since Sunday at midnight when that outage range ends.
         */
        end?: pulumi.Input<number>;
        /**
         * Seconds since Sunday at midnight when the outage range starts.
         */
        start?: pulumi.Input<number>;
    }

    export interface WirelessSsidsSpeedBurst {
        /**
         * Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsSplashSettingsBilling {
        /**
         * Details associated with a free access plan with limits
         */
        freeAccess?: pulumi.Input<inputs.networks.WirelessSsidsSplashSettingsBillingFreeAccess>;
        /**
         * Whether or not billing uses the fast login prepaid access option.
         */
        prepaidAccessFastLoginEnabled?: pulumi.Input<boolean>;
        /**
         * The email address that reeceives replies from clients
         */
        replyToEmailAddress?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSplashSettingsBillingFreeAccess {
        /**
         * How long a device can use a network for free.
         */
        durationInMinutes?: pulumi.Input<number>;
        /**
         * Whether or not free access is enabled.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsSplashSettingsGuestSponsorship {
        /**
         * Duration in minutes of sponsored guest authorization.
         */
        durationInMinutes?: pulumi.Input<number>;
        /**
         * Whether or not guests can specify how much time they are requesting.
         */
        guestCanRequestTimeframe?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsSplashSettingsSelfRegistration {
        /**
         * How created user accounts should be authorized.
         */
        authorizationType?: pulumi.Input<string>;
        /**
         * Whether or not to allow users to create their own account on the network.
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface WirelessSsidsSplashSettingsSentryEnrollment {
        /**
         * The system types that the Sentry enforces.
         */
        enforcedSystems?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The strength of the enforcement of selected system types.
         */
        strength?: pulumi.Input<string>;
        /**
         * Systems Manager network targeted for sentry enrollment.
         */
        systemsManagerNetwork?: pulumi.Input<inputs.networks.WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork>;
    }

    export interface WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork {
        /**
         * The network ID of the Systems Manager network.
         */
        id?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSplashSettingsSplashImage {
        /**
         * The extension of the image file.
         */
        extension?: pulumi.Input<string>;
        /**
         * Properties for setting a new image.
         */
        image?: pulumi.Input<inputs.networks.WirelessSsidsSplashSettingsSplashImageImage>;
        /**
         * The MD5 value of the image file.
         */
        md5?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSplashSettingsSplashImageImage {
        /**
         * The file contents (a base 64 encoded string) of your new image.
         */
        contents?: pulumi.Input<string>;
        /**
         * The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
         */
        format?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSplashSettingsSplashLogo {
        /**
         * The extension of the logo file.
         */
        extension?: pulumi.Input<string>;
        /**
         * Properties for setting a new image.
         */
        image?: pulumi.Input<inputs.networks.WirelessSsidsSplashSettingsSplashLogoImage>;
        /**
         * The MD5 value of the logo file.
         */
        md5?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSplashSettingsSplashLogoImage {
        /**
         * The file contents (a base 64 encoded string) of your new logo.
         */
        contents?: pulumi.Input<string>;
        /**
         * The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
         */
        format?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSplashSettingsSplashPrepaidFront {
        /**
         * The extension of the prepaid front image file.
         */
        extension?: pulumi.Input<string>;
        /**
         * Properties for setting a new image.
         */
        image?: pulumi.Input<inputs.networks.WirelessSsidsSplashSettingsSplashPrepaidFrontImage>;
        /**
         * The MD5 value of the prepaid front image file.
         */
        md5?: pulumi.Input<string>;
    }

    export interface WirelessSsidsSplashSettingsSplashPrepaidFrontImage {
        /**
         * The file contents (a base 64 encoded string) of your new prepaid front.
         */
        contents?: pulumi.Input<string>;
        /**
         * The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
         */
        format?: pulumi.Input<string>;
    }

    export interface WirelessSsidsTrafficShapingRulesRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions?: pulumi.Input<pulumi.Input<inputs.networks.WirelessSsidsTrafficShapingRulesRuleDefinition>[]>;
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue?: pulumi.Input<number>;
        /**
         * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
         * null means 'Do not set PCP tag'.
         */
        pcpTagValue?: pulumi.Input<number>;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits?: pulumi.Input<inputs.networks.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits>;
    }

    export interface WirelessSsidsTrafficShapingRulesRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type?: pulumi.Input<string>;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         * custom ports.
         *  If "type" is 'application' or 'applicationCategory', then "value" must be an object
         * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         * endpoint).
         */
        value?: pulumi.Input<string>;
    }

    export interface WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits?: pulumi.Input<inputs.networks.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits>;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings?: pulumi.Input<string>;
    }

    export interface WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown?: pulumi.Input<number>;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp?: pulumi.Input<number>;
    }

    export interface WirelessSsidsVpnConcentrator {
        name?: pulumi.Input<string>;
        /**
         * The NAT ID of the concentrator that should be set.
         */
        networkId?: pulumi.Input<string>;
        /**
         * The VLAN that should be tagged for the concentrator.
         */
        vlanId?: pulumi.Input<number>;
    }

    export interface WirelessSsidsVpnFailover {
        /**
         * Idle timer interval in seconds.
         */
        heartbeatInterval?: pulumi.Input<number>;
        /**
         * Idle timer timeout in seconds.
         */
        idleTimeout?: pulumi.Input<number>;
        /**
         * IP addressed reserved on DHCP server where SSID will terminate.
         */
        requestIp?: pulumi.Input<string>;
    }

    export interface WirelessSsidsVpnSplitTunnel {
        /**
         * If true, VPN split tunnel is enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * List of VPN split tunnel rules.
         */
        rules?: pulumi.Input<pulumi.Input<inputs.networks.WirelessSsidsVpnSplitTunnelRule>[]>;
    }

    export interface WirelessSsidsVpnSplitTunnelRule {
        /**
         * Description for this split tunnel rule (optional).
         */
        comment?: pulumi.Input<string>;
        /**
         * Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
         */
        destPort?: pulumi.Input<string>;
        /**
         * Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
         */
        policy?: pulumi.Input<string>;
        /**
         * Protocol for this split tunnel rule.
         */
        protocol?: pulumi.Input<string>;
    }
}

export namespace organizations {
    export interface ActionBatchesAction {
        /**
         * Data provided in the body of the Action. Contents depend on the Action type
         */
        body?: pulumi.Input<string>;
        /**
         * The operation to be used by this action
         */
        operation?: pulumi.Input<string>;
        /**
         * Unique identifier for the resource to be acted on
         */
        resource?: pulumi.Input<string>;
    }

    export interface ActionBatchesCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer?: pulumi.Input<inputs.organizations.ActionBatchesCallbackHttpServer>;
        /**
         * The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
         */
        id?: pulumi.Input<string>;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate?: pulumi.Input<inputs.organizations.ActionBatchesCallbackPayloadTemplate>;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret?: pulumi.Input<string>;
        /**
         * The status of the callback
         */
        status?: pulumi.Input<string>;
        /**
         * The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
         */
        url?: pulumi.Input<string>;
    }

    export interface ActionBatchesCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id?: pulumi.Input<string>;
    }

    export interface ActionBatchesCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id?: pulumi.Input<string>;
    }

    export interface ActionBatchesStatus {
        /**
         * Flag describing whether all actions in the action batch have completed
         */
        completed?: pulumi.Input<boolean>;
        /**
         * Resources created as a result of this action batch
         */
        createdResources?: pulumi.Input<pulumi.Input<inputs.organizations.ActionBatchesStatusCreatedResource>[]>;
        /**
         * List of errors encountered when running actions in the action batch
         */
        errors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Flag describing whether any actions in the action batch failed
         */
        failed?: pulumi.Input<boolean>;
    }

    export interface ActionBatchesStatusCreatedResource {
        /**
         * ID of the created resource
         */
        id?: pulumi.Input<string>;
        /**
         * URI, not including base, of the created resource
         */
        uri?: pulumi.Input<string>;
    }

    export interface AdaptivePolicyAclsRule {
        /**
         * Destination port
         */
        dstPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol
         */
        protocol?: pulumi.Input<string>;
        /**
         * Source port
         */
        srcPort?: pulumi.Input<string>;
    }

    export interface AdaptivePolicyGroupsPolicyObject {
        /**
         * The ID of the policy object
         */
        id?: pulumi.Input<string>;
        /**
         * The name of the policy object
         */
        name?: pulumi.Input<string>;
    }

    export interface AdaptivePolicyPoliciesAcl {
        /**
         * The ID of the adaptive policy ACL
         */
        id?: pulumi.Input<string>;
        /**
         * The name of the adaptive policy ACL
         */
        name?: pulumi.Input<string>;
    }

    export interface AdaptivePolicyPoliciesDestinationGroup {
        /**
         * The ID of the destination adaptive policy group
         */
        id?: pulumi.Input<string>;
        /**
         * The name of the destination adaptive policy group
         */
        name?: pulumi.Input<string>;
        /**
         * The SGT of the destination adaptive policy group
         */
        sgt?: pulumi.Input<number>;
    }

    export interface AdaptivePolicyPoliciesSourceGroup {
        /**
         * The ID of the source adaptive policy group
         */
        id?: pulumi.Input<string>;
        /**
         * The name of the source adaptive policy group
         */
        name?: pulumi.Input<string>;
        /**
         * The SGT of the source adaptive policy group
         */
        sgt?: pulumi.Input<number>;
    }

    export interface AdminsNetwork {
        /**
         * Admin's level of access to the network
         */
        access?: pulumi.Input<string>;
        /**
         * Network ID
         */
        id?: pulumi.Input<string>;
    }

    export interface AdminsTag {
        /**
         * Access level for the tag
         */
        access?: pulumi.Input<string>;
        /**
         * Tag value
         */
        tag?: pulumi.Input<string>;
    }

    export interface AlertsProfilesAlertCondition {
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
         */
        bitRateBps?: pulumi.Input<number>;
        /**
         * The total duration in seconds that the threshold should be crossed before alerting
         */
        duration?: pulumi.Input<number>;
        /**
         * The uplink observed for the alert
         */
        interface?: pulumi.Input<string>;
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts.
         */
        jitterMs?: pulumi.Input<number>;
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts.
         */
        latencyMs?: pulumi.Input<number>;
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts.
         */
        lossRatio?: pulumi.Input<number>;
        /**
         * The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts.
         */
        mos?: pulumi.Input<number>;
        /**
         * The look back period in seconds for sensing the alert
         */
        window?: pulumi.Input<number>;
    }

    export interface AlertsProfilesRecipients {
        /**
         * A list of emails that will receive information about the alert
         */
        emails?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * A list base64 encoded urls of webhook endpoints that will receive information about the alert
         */
        httpServerIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplianceSecurityIntrusionAllowedRule {
        /**
         * Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET
         */
        message?: pulumi.Input<string>;
        /**
         * A rule identifier of the format meraki:intrusion/snort/GID/\n\n/SID/\n\n. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents
         */
        ruleId?: pulumi.Input<string>;
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeer {
        /**
         * [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
         */
        ikeVersion?: pulumi.Input<string>;
        /**
         * Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
         */
        ipsecPolicies?: pulumi.Input<inputs.organizations.ApplianceVpnThirdPartyVpnpeersPeerIpsecPolicies>;
        /**
         * One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
         */
        ipsecPoliciesPreset?: pulumi.Input<string>;
        /**
         * [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
         */
        localId?: pulumi.Input<string>;
        /**
         * The name of the VPN peer
         */
        name?: pulumi.Input<string>;
        /**
         * A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
         */
        networkTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of the private subnets of the VPN peer
         */
        privateSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * [optional] The public IP of the VPN peer
         */
        publicIp?: pulumi.Input<string>;
        /**
         * [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
         */
        remoteId?: pulumi.Input<string>;
        /**
         * The shared secret with the VPN peer
         */
        secret?: pulumi.Input<string>;
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeerIpsecPolicies {
        /**
         * This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        childAuthAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
         */
        childCipherAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The lifetime of the Phase 2 SA in seconds.
         */
        childLifetime?: pulumi.Input<number>;
        /**
         * This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
         */
        childPfsGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        ikeAuthAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
         */
        ikeCipherAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
         */
        ikeDiffieHellmanGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The lifetime of the Phase 1 SA in seconds.
         */
        ikeLifetime?: pulumi.Input<number>;
        /**
         * [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
         */
        ikePrfAlgos?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeersResponse {
        /**
         * [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
         */
        ikeVersion?: pulumi.Input<string>;
        /**
         * Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
         */
        ipsecPolicies?: pulumi.Input<inputs.organizations.ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPolicies>;
        /**
         * One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
         */
        ipsecPoliciesPreset?: pulumi.Input<string>;
        /**
         * [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
         */
        localId?: pulumi.Input<string>;
        /**
         * The name of the VPN peer
         */
        name?: pulumi.Input<string>;
        /**
         * A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
         */
        networkTags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The list of the private subnets of the VPN peer
         */
        privateSubnets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * [optional] The public IP of the VPN peer
         */
        publicIp?: pulumi.Input<string>;
        /**
         * [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
         */
        remoteId?: pulumi.Input<string>;
        /**
         * The shared secret with the VPN peer
         */
        secret?: pulumi.Input<string>;
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPolicies {
        /**
         * This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        childAuthAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
         */
        childCipherAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The lifetime of the Phase 2 SA in seconds.
         */
        childLifetime?: pulumi.Input<number>;
        /**
         * This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
         */
        childPfsGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        ikeAuthAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
         */
        ikeCipherAlgos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
         */
        ikeDiffieHellmanGroups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The lifetime of the Phase 1 SA in seconds.
         */
        ikeLifetime?: pulumi.Input<number>;
        /**
         * [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
         */
        ikePrfAlgos?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ApplianceVpnVpnFirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: pulumi.Input<string>;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: pulumi.Input<string>;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: pulumi.Input<string>;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: pulumi.Input<string>;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: pulumi.Input<string>;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: pulumi.Input<boolean>;
    }

    export interface BaseApi {
        /**
         * Enable API access
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface BaseCloud {
        /**
         * Region info
         */
        region?: pulumi.Input<inputs.organizations.BaseCloudRegion>;
    }

    export interface BaseCloudRegion {
        /**
         * Name of region
         */
        name?: pulumi.Input<string>;
    }

    export interface BaseLicensing {
        /**
         * Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
         */
        model?: pulumi.Input<string>;
    }

    export interface BaseManagement {
        /**
         * Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
         */
        details?: pulumi.Input<pulumi.Input<inputs.organizations.BaseManagementDetail>[]>;
    }

    export interface BaseManagementDetail {
        /**
         * Name of management data
         */
        name?: pulumi.Input<string>;
        /**
         * Value of management data
         */
        value?: pulumi.Input<string>;
    }

    export interface BrandingPoliciesAdminSettings {
        /**
         * Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
         */
        appliesTo?: pulumi.Input<string>;
        /**
         * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
         *   entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
         *   networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
         *   specify an array of tag names.
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface BrandingPoliciesCustomLogo {
        /**
         * Whether or not there is a custom logo enabled.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Properties of the image.
         */
        image?: pulumi.Input<inputs.organizations.BrandingPoliciesCustomLogoImage>;
    }

    export interface BrandingPoliciesCustomLogoImage {
        /**
         * The file contents (a base 64 encoded string) of your new logo.
         */
        contents?: pulumi.Input<string>;
        /**
         * The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'.
         */
        format?: pulumi.Input<string>;
        /**
         * Preview of the image
         */
        preview?: pulumi.Input<inputs.organizations.BrandingPoliciesCustomLogoImagePreview>;
    }

    export interface BrandingPoliciesCustomLogoImagePreview {
        /**
         * Timestamp of the preview image
         */
        expiresAt?: pulumi.Input<string>;
        /**
         * Url of the preview image
         */
        url?: pulumi.Input<string>;
    }

    export interface BrandingPoliciesHelpSettings {
        /**
         * The 'Help > API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
         *   'default or inherit', 'hide' or 'show'.
         */
        apiDocsSubtab?: pulumi.Input<string>;
        /**
         * The 'Help > Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
         *   of 'default or inherit', 'hide' or 'show'.
         */
        casesSubtab?: pulumi.Input<string>;
        /**
         * The 'Product Manuals' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        ciscoMerakiProductDocumentation?: pulumi.Input<string>;
        /**
         * The 'Help > Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        communitySubtab?: pulumi.Input<string>;
        /**
         * The 'Help > Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
         *   be audited. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        dataProtectionRequestsSubtab?: pulumi.Input<string>;
        /**
         * The 'Help > Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
         *   listed. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        firewallInfoSubtab?: pulumi.Input<string>;
        /**
         * The 'Help > Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
         *   that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
         *   and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        getHelpSubtab?: pulumi.Input<string>;
        /**
         * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        getHelpSubtabKnowledgeBaseSearch?: pulumi.Input<string>;
        /**
         * The 'Help > Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
         *   'default or inherit', 'hide' or 'show'.
         */
        hardwareReplacementsSubtab?: pulumi.Input<string>;
        /**
         * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
         *   customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        helpTab?: pulumi.Input<string>;
        /**
         * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
         *   and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        helpWidget?: pulumi.Input<string>;
        /**
         * The 'Help > New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        newFeaturesSubtab?: pulumi.Input<string>;
        /**
         * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
         *   organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        smForums?: pulumi.Input<string>;
        /**
         * The 'Contact Meraki Support' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        supportContactInfo?: pulumi.Input<string>;
        /**
         * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
         *   whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        universalSearchKnowledgeBaseSearch?: pulumi.Input<string>;
    }

    export interface CameraCustomAnalyticsArtifactsStatus {
        /**
         * Status message
         */
        message?: pulumi.Input<string>;
        /**
         * Status type
         */
        type?: pulumi.Input<string>;
    }

    export interface CameraRolesAppliedOnDevice {
        /**
         * Device id.
         */
        id?: pulumi.Input<string>;
        /**
         * Network id scope
         */
        inNetworksWithId?: pulumi.Input<string>;
        /**
         * Network tag scope
         */
        inNetworksWithTag?: pulumi.Input<string>;
        permissionLevel?: pulumi.Input<string>;
        permissionScope?: pulumi.Input<string>;
        /**
         * Permission scope id
         */
        permissionScopeId?: pulumi.Input<string>;
        /**
         * Device tag.
         */
        tag?: pulumi.Input<string>;
    }

    export interface CameraRolesAppliedOnNetwork {
        /**
         * Network id.
         */
        id?: pulumi.Input<string>;
        permissionLevel?: pulumi.Input<string>;
        permissionScope?: pulumi.Input<string>;
        /**
         * Permission scope id
         */
        permissionScopeId?: pulumi.Input<string>;
        /**
         * Network tag
         */
        tag?: pulumi.Input<string>;
    }

    export interface CameraRolesAppliedOrgWide {
        permissionLevel?: pulumi.Input<string>;
        permissionScope?: pulumi.Input<string>;
        /**
         * Permission scope id
         */
        permissionScopeId?: pulumi.Input<string>;
        tag?: pulumi.Input<string>;
    }

    export interface ClaimItem {
        /**
         * The licenses claimed
         */
        licenses?: pulumi.Input<pulumi.Input<inputs.organizations.ClaimItemLicense>[]>;
        /**
         * The numbers of the orders claimed
         */
        orders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices claimed
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClaimItemLicense {
        /**
         * The key of the license
         */
        key?: pulumi.Input<string>;
        /**
         * The mode of the license
         */
        mode?: pulumi.Input<string>;
    }

    export interface ClaimParameters {
        /**
         * The licenses that should be claimed
         */
        licenses?: pulumi.Input<pulumi.Input<inputs.organizations.ClaimParametersLicense>[]>;
        /**
         * The numbers of the orders that should be claimed
         */
        orders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices that should be claimed
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface ClaimParametersLicense {
        /**
         * The key of the license
         */
        key?: pulumi.Input<string>;
        /**
         * Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
         */
        mode?: pulumi.Input<string>;
    }

    export interface CloneItem {
        /**
         * API related settings
         */
        api?: pulumi.Input<inputs.organizations.CloneItemApi>;
        /**
         * Data for this organization
         */
        cloud?: pulumi.Input<inputs.organizations.CloneItemCloud>;
        /**
         * Organization ID
         */
        id?: pulumi.Input<string>;
        /**
         * Licensing related settings
         */
        licensing?: pulumi.Input<inputs.organizations.CloneItemLicensing>;
        /**
         * Information about the organization's management system
         */
        management?: pulumi.Input<inputs.organizations.CloneItemManagement>;
        /**
         * Organization name
         */
        name?: pulumi.Input<string>;
        /**
         * Organization URL
         */
        url?: pulumi.Input<string>;
    }

    export interface CloneItemApi {
        /**
         * Enable API access
         */
        enabled?: pulumi.Input<boolean>;
    }

    export interface CloneItemCloud {
        /**
         * Region info
         */
        region?: pulumi.Input<inputs.organizations.CloneItemCloudRegion>;
    }

    export interface CloneItemCloudRegion {
        /**
         * Name of region
         */
        name?: pulumi.Input<string>;
    }

    export interface CloneItemLicensing {
        /**
         * Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
         */
        model?: pulumi.Input<string>;
    }

    export interface CloneItemManagement {
        /**
         * Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
         */
        details?: pulumi.Input<pulumi.Input<inputs.organizations.CloneItemManagementDetail>[]>;
    }

    export interface CloneItemManagementDetail {
        /**
         * Name of management data
         */
        name?: pulumi.Input<string>;
        /**
         * Value of management data
         */
        value?: pulumi.Input<string>;
    }

    export interface CloneParameters {
        /**
         * The name of the new organization
         */
        name?: pulumi.Input<string>;
    }

    export interface ConfigTemplatesSwitchProfilesPortsMirror {
        /**
         * The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
         */
        mode?: pulumi.Input<string>;
    }

    export interface ConfigTemplatesSwitchProfilesPortsModule {
        /**
         * The model of the expansion module.
         */
        model?: pulumi.Input<string>;
    }

    export interface ConfigTemplatesSwitchProfilesPortsProfile {
        /**
         * When enabled, override this port's configuration with a port profile.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * When enabled, the ID of the port profile used to override the port's configuration.
         */
        id?: pulumi.Input<string>;
        /**
         * When enabled, the IName of the profile.
         */
        iname?: pulumi.Input<string>;
    }

    export interface InventoryClaimItem {
        /**
         * The licenses claimed
         */
        licenses?: pulumi.Input<pulumi.Input<inputs.organizations.InventoryClaimItemLicense>[]>;
        /**
         * The numbers of the orders claimed
         */
        orders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices claimed
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InventoryClaimItemLicense {
        /**
         * The key of the license
         */
        key?: pulumi.Input<string>;
        /**
         * The mode of the license
         */
        mode?: pulumi.Input<string>;
    }

    export interface InventoryClaimParameters {
        /**
         * The licenses that should be claimed
         */
        licenses?: pulumi.Input<pulumi.Input<inputs.organizations.InventoryClaimParametersLicense>[]>;
        /**
         * The numbers of the orders that should be claimed
         */
        orders?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The serials of the devices that should be claimed
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InventoryClaimParametersLicense {
        /**
         * The key of the license
         */
        key?: pulumi.Input<string>;
        /**
         * Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model.
         */
        mode?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringExportEventsParameters {
        /**
         * The type of log event this is recording, e.g. download or opening a banner
         */
        logEvent?: pulumi.Input<string>;
        /**
         * Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used
         */
        request?: pulumi.Input<string>;
        /**
         * The name of the onboarding distro being downloaded
         */
        targetOs?: pulumi.Input<string>;
        /**
         * A JavaScript UTC datetime stamp for when the even occurred
         */
        timestamp?: pulumi.Input<number>;
    }

    export interface InventoryOnboardingCloudMonitoringImportsParameters {
        /**
         * A set of device imports to commit
         */
        devices?: pulumi.Input<pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringImportsParametersDevice>[]>;
        items?: pulumi.Input<pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringImportsParametersItem>[]>;
    }

    export interface InventoryOnboardingCloudMonitoringImportsParametersDevice {
        /**
         * Import ID from the Import operation
         */
        deviceId?: pulumi.Input<string>;
        /**
         * Network Id
         */
        networkId?: pulumi.Input<string>;
        /**
         * Device UDI certificate
         */
        udi?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringImportsParametersItem {
        /**
         * Array of ResponseOrganizationsCreateOrganizationInventoryOnboardingCloudMonitoringImport
         */
        items?: pulumi.Input<pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringImportsParametersItemItem>[]>;
    }

    export interface InventoryOnboardingCloudMonitoringImportsParametersItemItem {
        /**
         * Unique id associated with the import of the device
         */
        importId?: pulumi.Input<string>;
        /**
         * Response method
         */
        message?: pulumi.Input<string>;
        /**
         * Cloud monitor import status
         */
        status?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItem {
        /**
         * Params used in order to connect to the device
         */
        configParams?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParams>;
        /**
         * Import ID from the Import operation
         */
        deviceId?: pulumi.Input<string>;
        /**
         * Message related to whether or not the device was found and can be imported.
         */
        message?: pulumi.Input<string>;
        /**
         * The import status of the device
         */
        status?: pulumi.Input<string>;
        /**
         * Device UDI certificate
         */
        udi?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParams {
        /**
         * Static IP Address used to connect to the device
         */
        cloudStaticIp?: pulumi.Input<string>;
        /**
         * Configuration options used to connect to the device
         */
        tunnel?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnel>;
        /**
         * User credentials used to connect to the device
         */
        user?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUser>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnel {
        /**
         * SSH tunnel URL used to connect to the device
         */
        host?: pulumi.Input<string>;
        mode?: pulumi.Input<string>;
        /**
         * The name of the tunnel we are attempting to connect to
         */
        name?: pulumi.Input<string>;
        /**
         * The port used for the ssh tunnel.
         */
        port?: pulumi.Input<string>;
        /**
         * Root certificate information
         */
        rootCertificate?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificate>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificate {
        /**
         * Public certificate value
         */
        content?: pulumi.Input<string>;
        /**
         * The name of the server protected by the certificate
         */
        name?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUser {
        /**
         * The public key for the registered user
         */
        publicKey?: pulumi.Input<string>;
        /**
         * Stores the user secret hash
         */
        secret?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecret>;
        /**
         * The username added to Catalyst device
         */
        username?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecret {
        /**
         * The hashed secret
         */
        hash?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParameters {
        /**
         * A set of devices to import (or update)
         */
        devices?: pulumi.Input<pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDevice>[]>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDevice {
        /**
         * Device SUDI certificate
         */
        sudi?: pulumi.Input<string>;
        /**
         * TLS Related Parameters
         */
        tunnel?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnel>;
        /**
         * User parameters
         */
        user?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceUser>;
        /**
         * VTY Related Parameters
         */
        vty?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVty>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnel {
        /**
         * Name of the configured TLS certificate
         */
        certificateName?: pulumi.Input<string>;
        /**
         * Number of the vlan expected to be used to connect to the cloud
         */
        localInterface?: pulumi.Input<number>;
        /**
         * Number of the configured Loopback Interface used for TLS overlay
         */
        loopbackNumber?: pulumi.Input<number>;
        /**
         * Name of the configured TLS tunnel
         */
        name?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceUser {
        /**
         * The name of the device user for Meraki monitoring
         */
        username?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVty {
        /**
         * AccessList details
         */
        accessList?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessList>;
        /**
         * VTY AAA authentication
         */
        authentication?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthentication>;
        /**
         * VTY AAA authorization
         */
        authorization?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorization>;
        /**
         * Ending line VTY number
         */
        endLineNumber?: pulumi.Input<number>;
        /**
         * SSH rotary number
         */
        rotaryNumber?: pulumi.Input<number>;
        /**
         * Starting line VTY number
         */
        startLineNumber?: pulumi.Input<number>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessList {
        /**
         * VTY in ACL
         */
        vtyIn?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyIn>;
        /**
         * VTY out ACL
         */
        vtyOut?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOut>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyIn {
        /**
         * Name
         */
        name?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOut {
        /**
         * Name
         */
        name?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthentication {
        /**
         * Group Details
         */
        group?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroup>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroup {
        /**
         * Group Name
         */
        name?: pulumi.Input<string>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorization {
        /**
         * Group Details
         */
        group?: pulumi.Input<inputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroup>;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroup {
        /**
         * Group Name
         */
        name?: pulumi.Input<string>;
    }

    export interface InventoryReleaseItem {
        /**
         * Serials of the devices that were released
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface InventoryReleaseParameters {
        /**
         * Serials of the devices that should be released
         */
        serials?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LicensesAssignSeatsItem {
        /**
         * Resulting licenses from the move
         */
        resultingLicenses?: pulumi.Input<pulumi.Input<inputs.organizations.LicensesAssignSeatsItemResultingLicense>[]>;
    }

    export interface LicensesAssignSeatsItemResultingLicense {
        /**
         * The date the license started burning
         */
        activationDate?: pulumi.Input<string>;
        /**
         * The date the license was claimed into the organization
         */
        claimDate?: pulumi.Input<string>;
        /**
         * Serial number of the device the license is assigned to
         */
        deviceSerial?: pulumi.Input<string>;
        /**
         * The duration of the individual license
         */
        durationInDays?: pulumi.Input<number>;
        /**
         * The date the license will expire
         */
        expirationDate?: pulumi.Input<string>;
        /**
         * The id of the head license this license is queued behind. If there is no head license, it returns nil.
         */
        headLicenseId?: pulumi.Input<string>;
        /**
         * License ID
         */
        id?: pulumi.Input<string>;
        /**
         * License key
         */
        licenseKey?: pulumi.Input<string>;
        /**
         * License type
         */
        licenseType?: pulumi.Input<string>;
        /**
         * ID of the network the license is assigned to
         */
        networkId?: pulumi.Input<string>;
        /**
         * Order number
         */
        orderNumber?: pulumi.Input<string>;
        /**
         * DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
         */
        permanentlyQueuedLicenses?: pulumi.Input<pulumi.Input<inputs.organizations.LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicense>[]>;
        /**
         * The number of seats of the license. Only applicable to SM licenses.
         */
        seatCount?: pulumi.Input<number>;
        /**
         * The state of the license. All queued licenses have a status of *recentlyQueued*.
         */
        state?: pulumi.Input<string>;
        /**
         * The duration of the license plus all permanently queued licenses associated with it
         */
        totalDurationInDays?: pulumi.Input<number>;
    }

    export interface LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicense {
        /**
         * The duration of the individual license
         */
        durationInDays?: pulumi.Input<number>;
        /**
         * Permanently queued license ID
         */
        id?: pulumi.Input<string>;
        /**
         * License key
         */
        licenseKey?: pulumi.Input<string>;
        /**
         * License type
         */
        licenseType?: pulumi.Input<string>;
        /**
         * Order number
         */
        orderNumber?: pulumi.Input<string>;
    }

    export interface LicensesAssignSeatsParameters {
        /**
         * The ID of the SM license to assign seats from
         */
        licenseId?: pulumi.Input<string>;
        /**
         * The ID of the SM network to assign the seats to
         */
        networkId?: pulumi.Input<string>;
        /**
         * The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
         */
        seatCount?: pulumi.Input<number>;
    }

    export interface LicensesMoveItem {
        /**
         * The ID of the organization to move the licenses to
         */
        destOrganizationId?: pulumi.Input<string>;
        /**
         * A list of IDs of licenses to move to the new organization
         */
        licenseIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LicensesMoveParameters {
        /**
         * The ID of the organization to move the licenses to
         */
        destOrganizationId?: pulumi.Input<string>;
        /**
         * A list of IDs of licenses to move to the new organization
         */
        licenseIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface LicensesMoveSeatsItem {
        /**
         * The ID of the organization to move the SM seats to
         */
        destOrganizationId?: pulumi.Input<string>;
        /**
         * The ID of the SM license to move the seats from
         */
        licenseId?: pulumi.Input<string>;
        /**
         * The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
         */
        seatCount?: pulumi.Input<number>;
    }

    export interface LicensesMoveSeatsParameters {
        /**
         * The ID of the organization to move the SM seats to
         */
        destOrganizationId?: pulumi.Input<string>;
        /**
         * The ID of the SM license to move the seats from
         */
        licenseId?: pulumi.Input<string>;
        /**
         * The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
         */
        seatCount?: pulumi.Input<number>;
    }

    export interface LicensesPermanentlyQueuedLicense {
        /**
         * The duration of the individual license
         */
        durationInDays?: pulumi.Input<number>;
        /**
         * Permanently queued license ID
         */
        id?: pulumi.Input<string>;
        /**
         * License key
         */
        licenseKey?: pulumi.Input<string>;
        /**
         * License type
         */
        licenseType?: pulumi.Input<string>;
        /**
         * Order number
         */
        orderNumber?: pulumi.Input<string>;
    }

    export interface LicensesRenewSeatsItem {
        /**
         * Resulting licenses from the move
         */
        resultingLicenses?: pulumi.Input<pulumi.Input<inputs.organizations.LicensesRenewSeatsItemResultingLicense>[]>;
    }

    export interface LicensesRenewSeatsItemResultingLicense {
        /**
         * The date the license started burning
         */
        activationDate?: pulumi.Input<string>;
        /**
         * The date the license was claimed into the organization
         */
        claimDate?: pulumi.Input<string>;
        /**
         * Serial number of the device the license is assigned to
         */
        deviceSerial?: pulumi.Input<string>;
        /**
         * The duration of the individual license
         */
        durationInDays?: pulumi.Input<number>;
        /**
         * The date the license will expire
         */
        expirationDate?: pulumi.Input<string>;
        /**
         * The id of the head license this license is queued behind. If there is no head license, it returns nil.
         */
        headLicenseId?: pulumi.Input<string>;
        /**
         * License ID
         */
        id?: pulumi.Input<string>;
        /**
         * License key
         */
        licenseKey?: pulumi.Input<string>;
        /**
         * License type
         */
        licenseType?: pulumi.Input<string>;
        /**
         * ID of the network the license is assigned to
         */
        networkId?: pulumi.Input<string>;
        /**
         * Order number
         */
        orderNumber?: pulumi.Input<string>;
        /**
         * DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
         */
        permanentlyQueuedLicenses?: pulumi.Input<pulumi.Input<inputs.organizations.LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicense>[]>;
        /**
         * The number of seats of the license. Only applicable to SM licenses.
         */
        seatCount?: pulumi.Input<number>;
        /**
         * The state of the license. All queued licenses have a status of *recentlyQueued*.
         */
        state?: pulumi.Input<string>;
        /**
         * The duration of the license plus all permanently queued licenses associated with it
         */
        totalDurationInDays?: pulumi.Input<number>;
    }

    export interface LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicense {
        /**
         * The duration of the individual license
         */
        durationInDays?: pulumi.Input<number>;
        /**
         * Permanently queued license ID
         */
        id?: pulumi.Input<string>;
        /**
         * License key
         */
        licenseKey?: pulumi.Input<string>;
        /**
         * License type
         */
        licenseType?: pulumi.Input<string>;
        /**
         * Order number
         */
        orderNumber?: pulumi.Input<string>;
    }

    export interface LicensesRenewSeatsParameters {
        /**
         * The ID of the SM license to renew. This license must already be assigned to an SM network
         */
        licenseIdToRenew?: pulumi.Input<string>;
        /**
         * The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
         */
        unusedLicenseId?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveItem {
        /**
         * Newly moved licenses created in the destination organization of the license move operation
         */
        movedLicenses?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveItemMovedLicense>[]>;
        /**
         * Remainder licenses created in the source organization as a result of moving a subset of the counts of a license
         */
        remainderLicenses?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveItemRemainderLicense>[]>;
    }

    export interface LicensingCotermLicensesMoveItemMovedLicense {
        /**
         * When the license was claimed into the organization
         */
        claimedAt?: pulumi.Input<string>;
        /**
         * The counts of the license by model type
         */
        counts?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveItemMovedLicenseCount>[]>;
        /**
         * The duration (term length) of the license, measured in days
         */
        duration?: pulumi.Input<number>;
        /**
         * The editions of the license for each relevant product type
         */
        editions?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveItemMovedLicenseEdition>[]>;
        /**
         * Flag to indicate if the license is expired
         */
        expired?: pulumi.Input<boolean>;
        /**
         * Flag to indicated that the license is invalidated
         */
        invalidated?: pulumi.Input<boolean>;
        /**
         * When the license was invalidated. Will be null for active licenses
         */
        invalidatedAt?: pulumi.Input<string>;
        /**
         * The key of the license
         */
        key?: pulumi.Input<string>;
        /**
         * The operation mode of the license when it was claimed
         */
        mode?: pulumi.Input<string>;
        /**
         * The ID of the organization that the license is claimed in
         */
        organizationId?: pulumi.Input<string>;
        /**
         * When the license's term began (approximately the date when the license was created)
         */
        startedAt?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveItemMovedLicenseCount {
        /**
         * The number of counts the license contains of this model
         */
        count?: pulumi.Input<number>;
        /**
         * The license model type
         */
        model?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveItemMovedLicenseEdition {
        /**
         * The name of the license edition
         */
        edition?: pulumi.Input<string>;
        /**
         * The product type of the license edition
         */
        productType?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveItemRemainderLicense {
        /**
         * When the license was claimed into the organization
         */
        claimedAt?: pulumi.Input<string>;
        /**
         * The counts of the license by model type
         */
        counts?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveItemRemainderLicenseCount>[]>;
        /**
         * The duration (term length) of the license, measured in days
         */
        duration?: pulumi.Input<number>;
        /**
         * The editions of the license for each relevant product type
         */
        editions?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveItemRemainderLicenseEdition>[]>;
        /**
         * Flag to indicate if the license is expired
         */
        expired?: pulumi.Input<boolean>;
        /**
         * Flag to indicated that the license is invalidated
         */
        invalidated?: pulumi.Input<boolean>;
        /**
         * When the license was invalidated. Will be null for active licenses
         */
        invalidatedAt?: pulumi.Input<string>;
        /**
         * The key of the license
         */
        key?: pulumi.Input<string>;
        /**
         * The operation mode of the license when it was claimed
         */
        mode?: pulumi.Input<string>;
        /**
         * The ID of the organization that the license is claimed in
         */
        organizationId?: pulumi.Input<string>;
        /**
         * When the license's term began (approximately the date when the license was created)
         */
        startedAt?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveItemRemainderLicenseCount {
        /**
         * The number of counts the license contains of this model
         */
        count?: pulumi.Input<number>;
        /**
         * The license model type
         */
        model?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveItemRemainderLicenseEdition {
        /**
         * The name of the license edition
         */
        edition?: pulumi.Input<string>;
        /**
         * The product type of the license edition
         */
        productType?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveParameters {
        /**
         * Destination data for the license move
         */
        destination?: pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveParametersDestination>;
        /**
         * The list of licenses to move
         */
        licenses?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveParametersLicense>[]>;
    }

    export interface LicensingCotermLicensesMoveParametersDestination {
        /**
         * The claim mode of the moved license
         */
        mode?: pulumi.Input<string>;
        /**
         * The organization to move the license to
         */
        organizationId?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveParametersLicense {
        /**
         * The counts to move from the license by model type
         */
        counts?: pulumi.Input<pulumi.Input<inputs.organizations.LicensingCotermLicensesMoveParametersLicenseCount>[]>;
        /**
         * The license key to move counts from
         */
        key?: pulumi.Input<string>;
    }

    export interface LicensingCotermLicensesMoveParametersLicenseCount {
        /**
         * The number of counts to move
         */
        count?: pulumi.Input<number>;
        /**
         * The license model type to move counts of
         */
        model?: pulumi.Input<string>;
    }

    export interface LoginSecurityApiAuthentication {
        /**
         * Details for API-only IP restrictions.
         */
        ipRestrictionsForKeys?: pulumi.Input<inputs.organizations.LoginSecurityApiAuthenticationIpRestrictionsForKeys>;
    }

    export interface LoginSecurityApiAuthenticationIpRestrictionsForKeys {
        /**
         * Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
         */
        ranges?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface NetworksCombineItem {
        /**
         * Network after the combination
         */
        resultingNetwork?: pulumi.Input<inputs.organizations.NetworksCombineItemResultingNetwork>;
    }

    export interface NetworksCombineItemResultingNetwork {
        /**
         * Enrollment string for the network
         */
        enrollmentString?: pulumi.Input<string>;
        /**
         * Network ID
         */
        id?: pulumi.Input<string>;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate?: pulumi.Input<boolean>;
        /**
         * Network name
         */
        name?: pulumi.Input<string>;
        /**
         * Notes for the network
         */
        notes?: pulumi.Input<string>;
        /**
         * Organization ID
         */
        organizationId?: pulumi.Input<string>;
        /**
         * List of the product types that the network supports
         */
        productTypes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Network tags
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Timezone of the network
         */
        timeZone?: pulumi.Input<string>;
        /**
         * URL to the network Dashboard UI
         */
        url?: pulumi.Input<string>;
    }

    export interface NetworksCombineParameters {
        /**
         * A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.
         */
        enrollmentString?: pulumi.Input<string>;
        /**
         * The name of the combined network
         */
        name?: pulumi.Input<string>;
        /**
         * A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
         */
        networkIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SamlRolesCamera {
        /**
         * Camera access ability
         */
        access?: pulumi.Input<string>;
        /**
         * Whether or not SAML administrator has org-wide access
         */
        orgWide?: pulumi.Input<boolean>;
    }

    export interface SamlRolesNetwork {
        /**
         * The privilege of the SAML administrator on the network
         */
        access?: pulumi.Input<string>;
        /**
         * The network ID
         */
        id?: pulumi.Input<string>;
    }

    export interface SamlRolesTag {
        /**
         * The privilege of the SAML administrator on the tag
         */
        access?: pulumi.Input<string>;
        /**
         * The name of the tag
         */
        tag?: pulumi.Input<string>;
    }

    export interface SmSentryPoliciesAssignmentsItem {
        /**
         * Sentry Group Policies for the Organization keyed by Network Id
         */
        items?: pulumi.Input<pulumi.Input<inputs.organizations.SmSentryPoliciesAssignmentsItemItem>[]>;
    }

    export interface SmSentryPoliciesAssignmentsItemItem {
        /**
         * The Id of the Network
         */
        networkId?: pulumi.Input<string>;
        /**
         * Array of Sentry Group Policies for the Network
         */
        policies?: pulumi.Input<pulumi.Input<inputs.organizations.SmSentryPoliciesAssignmentsItemItemPolicy>[]>;
    }

    export interface SmSentryPoliciesAssignmentsItemItemPolicy {
        /**
         * The creation time of the Sentry Policy
         */
        createdAt?: pulumi.Input<string>;
        /**
         * The number of the Group Policy
         */
        groupNumber?: pulumi.Input<string>;
        /**
         * The Id of the Group Policy. This is associated with the network specified by the networkId.
         */
        groupPolicyId?: pulumi.Input<string>;
        /**
         * The last update time of the Sentry Policy
         */
        lastUpdatedAt?: pulumi.Input<string>;
        /**
         * The Id of the Network the Sentry Policy is associated with. In a locale, this should be the Wireless Group if present, otherwise the Wired Group.
         */
        networkId?: pulumi.Input<string>;
        /**
         * The Id of the Sentry Policy
         */
        policyId?: pulumi.Input<string>;
        /**
         * The priority of the Sentry Policy
         */
        priority?: pulumi.Input<string>;
        /**
         * The scope of the Sentry Policy
         */
        scope?: pulumi.Input<string>;
        /**
         * The Id of the Systems Manager Network the Sentry Policy is assigned to
         */
        smNetworkId?: pulumi.Input<string>;
        /**
         * The tags of the Sentry Policy
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SmSentryPoliciesAssignmentsParameters {
        /**
         * Sentry Group Policies for the Organization keyed by Network Id
         */
        items?: pulumi.Input<pulumi.Input<inputs.organizations.SmSentryPoliciesAssignmentsParametersItem>[]>;
    }

    export interface SmSentryPoliciesAssignmentsParametersItem {
        /**
         * The Id of the Network
         */
        networkId?: pulumi.Input<string>;
        /**
         * Array of Sentry Group Policies for the Network
         */
        policies?: pulumi.Input<pulumi.Input<inputs.organizations.SmSentryPoliciesAssignmentsParametersItemPolicy>[]>;
    }

    export interface SmSentryPoliciesAssignmentsParametersItemPolicy {
        /**
         * The Group Policy Id
         */
        groupPolicyId?: pulumi.Input<string>;
        /**
         * The Sentry Policy Id, if updating an existing Sentry Policy
         */
        policyId?: pulumi.Input<string>;
        /**
         * The scope of the Sentry Policy
         */
        scope?: pulumi.Input<string>;
        /**
         * The Id of the Systems Manager Network
         */
        smNetworkId?: pulumi.Input<string>;
        /**
         * The tags for the Sentry Policy
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SwitchDevicesCloneParameters {
        /**
         * Serial number of the source switch (must be on a network not bound to a template)
         */
        sourceSerial?: pulumi.Input<string>;
        /**
         * Array of serial numbers of one or more target switches (must be on a network not bound to a template)
         */
        targetSerials?: pulumi.Input<pulumi.Input<string>[]>;
    }
}
