// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface GetDevicesItem {
    /**
     * Physical address of the device
     */
    address: string;
    /**
     * Additional device information
     */
    details: outputs.GetDevicesItemDetail[];
    /**
     * Firmware version of the device
     */
    firmware: string;
    /**
     * IMEI of the device, if applicable
     */
    imei: number;
    /**
     * LAN IP address of the device
     */
    lanIp: string;
    /**
     * Latitude of the device
     */
    lat: number;
    /**
     * Longitude of the device
     */
    lng: number;
    /**
     * MAC address of the device
     */
    mac: string;
    /**
     * Model of the device
     */
    model: string;
    /**
     * Name of the device
     */
    name: string;
    /**
     * ID of the network the device belongs to
     */
    networkId: string;
    /**
     * Notes for the device, limited to 255 characters
     */
    notes: string;
    /**
     * Product type of the device
     */
    productType: string;
    /**
     * Serial number of the device
     */
    serial: string;
    /**
     * List of tags assigned to the device
     */
    tags: string[];
}

export interface GetDevicesItemDetail {
    /**
     * Additional property name
     */
    name: string;
    /**
     * Additional property value
     */
    value: string;
}

export interface GetNetworksItem {
    /**
     * Enrollment string for the network
     */
    enrollmentString: string;
    /**
     * Network ID
     */
    id: string;
    /**
     * If the network is bound to a config template
     */
    isBoundToConfigTemplate: boolean;
    /**
     * Network name
     */
    name: string;
    /**
     * Notes for the network
     */
    notes: string;
    /**
     * Organization ID
     */
    organizationId: string;
    /**
     * List of the product types that the network supports
     */
    productTypes: string[];
    /**
     * Network tags
     */
    tags: string[];
    /**
     * Timezone of the network
     */
    timeZone: string;
    /**
     * URL to the network Dashboard UI
     */
    url: string;
}

export interface GetOrganizationsItem {
    /**
     * API related settings
     */
    api: outputs.GetOrganizationsItemApi;
    /**
     * Data for this organization
     */
    cloud: outputs.GetOrganizationsItemCloud;
    /**
     * Organization ID
     */
    id: string;
    /**
     * Licensing related settings
     */
    licensing: outputs.GetOrganizationsItemLicensing;
    /**
     * Information about the organization's management system
     */
    management: outputs.GetOrganizationsItemManagement;
    /**
     * Organization name
     */
    name: string;
    /**
     * Organization URL
     */
    url: string;
}

export interface GetOrganizationsItemApi {
    /**
     * Enable API access
     */
    enabled: boolean;
}

export interface GetOrganizationsItemCloud {
    /**
     * Region info
     */
    region: outputs.GetOrganizationsItemCloudRegion;
}

export interface GetOrganizationsItemCloudRegion {
    /**
     * Name of region
     */
    name: string;
}

export interface GetOrganizationsItemLicensing {
    /**
     * Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
     */
    model: string;
}

export interface GetOrganizationsItemManagement {
    /**
     * Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
     */
    details: outputs.GetOrganizationsItemManagementDetail[];
}

export interface GetOrganizationsItemManagementDetail {
    /**
     * Name of management data
     */
    name: string;
    /**
     * Value of management data
     */
    value: string;
}

export namespace administered {
    export interface GetIdentitiesMeItem {
        /**
         * Authentication info
         */
        authentication: outputs.administered.GetIdentitiesMeItemAuthentication;
        /**
         * User email
         */
        email: string;
        /**
         * Last seen active on Dashboard UI
         */
        lastUsedDashboardAt: string;
        /**
         * Username
         */
        name: string;
    }

    export interface GetIdentitiesMeItemAuthentication {
        /**
         * API authentication
         */
        api: outputs.administered.GetIdentitiesMeItemAuthenticationApi;
        /**
         * Authentication mode
         */
        mode: string;
        /**
         * SAML authentication
         */
        saml: outputs.administered.GetIdentitiesMeItemAuthenticationSaml;
        /**
         * TwoFactor authentication
         */
        twoFactor: outputs.administered.GetIdentitiesMeItemAuthenticationTwoFactor;
    }

    export interface GetIdentitiesMeItemAuthenticationApi {
        /**
         * API key
         */
        key: outputs.administered.GetIdentitiesMeItemAuthenticationApiKey;
    }

    export interface GetIdentitiesMeItemAuthenticationApiKey {
        /**
         * If API key is created for this user
         */
        created: boolean;
    }

    export interface GetIdentitiesMeItemAuthenticationSaml {
        /**
         * If SAML authentication is enabled for this user
         */
        enabled: boolean;
    }

    export interface GetIdentitiesMeItemAuthenticationTwoFactor {
        /**
         * If twoFactor authentication is enabled for this user
         */
        enabled: boolean;
    }

    export interface GetLicensingSubscriptionEntitlementsItem {
        /**
         * The feature tier associated with the entitlement (null for add-ons)
         */
        featureTier: string;
        /**
         * Whether or not the entitlement is an add-on
         */
        isAddOn: boolean;
        /**
         * The user-facing name of the entitlement
         */
        name: string;
        /**
         * The product class associated with the entitlement
         */
        productClass: string;
        /**
         * The product type of the entitlement
         */
        productType: string;
        /**
         * The SKU identifier of the entitlement
         */
        sku: string;
    }

    export interface GetLicensingSubscriptionSubscriptionsComplianceStatusesItem {
        /**
         * Subscription details
         */
        subscription: outputs.administered.GetLicensingSubscriptionSubscriptionsComplianceStatusesItemSubscription;
        /**
         * Violations
         */
        violations: outputs.administered.GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolations;
    }

    export interface GetLicensingSubscriptionSubscriptionsComplianceStatusesItemSubscription {
        /**
         * Subscription's ID
         */
        id: string;
        /**
         * Friendly name to identify the subscription
         */
        name: string;
        /**
         * One of the following: "inactive" | "active" | "out*of*compliance" | "expired" | "canceled"
         */
        status: string;
    }

    export interface GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolations {
        /**
         * List of violations by product class that are not compliance
         */
        byProductClasses: outputs.administered.GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolationsByProductClass[];
    }

    export interface GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolationsByProductClass {
        /**
         * End date of the grace period in ISO 8601 format
         */
        gracePeriodEndsAt: string;
        /**
         * Missing entitlements details
         */
        missing: outputs.administered.GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolationsByProductClassMissing;
        /**
         * Name of the product class
         */
        productClass: string;
    }

    export interface GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolationsByProductClassMissing {
        /**
         * List of missing entitlements
         */
        entitlements: outputs.administered.GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolationsByProductClassMissingEntitlement[];
    }

    export interface GetLicensingSubscriptionSubscriptionsComplianceStatusesItemViolationsByProductClassMissingEntitlement {
        /**
         * Number required
         */
        quantity: number;
        /**
         * SKU of the required product
         */
        sku: string;
    }

    export interface GetLicensingSubscriptionSubscriptionsItem {
        /**
         * Numeric breakdown of network and entitlement counts
         */
        counts: outputs.administered.GetLicensingSubscriptionSubscriptionsItemCounts;
        /**
         * Subscription description
         */
        description: string;
        /**
         * Subscription expiration date
         */
        endDate: string;
        /**
         * Entitlement info
         */
        entitlements: outputs.administered.GetLicensingSubscriptionSubscriptionsItemEntitlement[];
        /**
         * Subscription name
         */
        name: string;
        /**
         * Products the subscription has entitlements for
         */
        productTypes: string[];
        /**
         * Subscription start date
         */
        startDate: string;
        /**
         * Subscription status
         */
        status: string;
        /**
         * Subscription's ID
         */
        subscriptionId: string;
        /**
         * Web order id
         */
        webOrderId: string;
    }

    export interface GetLicensingSubscriptionSubscriptionsItemCounts {
        /**
         * Number of networks bound to this subscription
         */
        networks: number;
        /**
         * Seat distribution
         */
        seats: outputs.administered.GetLicensingSubscriptionSubscriptionsItemCountsSeats;
    }

    export interface GetLicensingSubscriptionSubscriptionsItemCountsSeats {
        /**
         * Number of seats in use
         */
        assigned: number;
        /**
         * Number of seats available for use
         */
        available: number;
        /**
         * Total number of seats provided by this subscription
         */
        limit: number;
    }

    export interface GetLicensingSubscriptionSubscriptionsItemEntitlement {
        /**
         * Seat distribution
         */
        seats: outputs.administered.GetLicensingSubscriptionSubscriptionsItemEntitlementSeats;
        /**
         * SKU of the required product
         */
        sku: string;
    }

    export interface GetLicensingSubscriptionSubscriptionsItemEntitlementSeats {
        /**
         * Number of seats in use
         */
        assigned: number;
        /**
         * Number of seats available for use
         */
        available: number;
        /**
         * Total number of seats provided by this subscription for this sku
         */
        limit: number;
    }

    export interface LicensingSubscriptionSubscriptionsBindItem {
        /**
         * Array of errors if failed
         */
        errors: string[];
        /**
         * A list of entitlements required to successfully bind the networks to the subscription
         */
        insufficientEntitlements: outputs.administered.LicensingSubscriptionSubscriptionsBindItemInsufficientEntitlement[];
        /**
         * Unbound networks
         */
        networks: outputs.administered.LicensingSubscriptionSubscriptionsBindItemNetwork[];
        /**
         * Subscription ID
         */
        subscriptionId: string;
    }

    export interface LicensingSubscriptionSubscriptionsBindItemInsufficientEntitlement {
        /**
         * Number required
         */
        quantity: number;
        /**
         * SKU of the required product
         */
        sku: string;
    }

    export interface LicensingSubscriptionSubscriptionsBindItemNetwork {
        /**
         * Network ID
         */
        id: string;
        /**
         * Network name
         */
        name: string;
    }

    export interface LicensingSubscriptionSubscriptionsBindParameters {
        /**
         * List of network ids to bind to the subscription
         */
        networkIds: string[];
    }

    export interface LicensingSubscriptionSubscriptionsClaimItem {
        /**
         * Numeric breakdown of network and entitlement counts
         */
        counts: outputs.administered.LicensingSubscriptionSubscriptionsClaimItemCounts;
        /**
         * Subscription description
         */
        description: string;
        /**
         * Subscription expiration date
         */
        endDate: string;
        /**
         * Entitlement info
         */
        entitlements: outputs.administered.LicensingSubscriptionSubscriptionsClaimItemEntitlement[];
        /**
         * Subscription name
         */
        name: string;
        /**
         * Products the subscription has entitlements for
         */
        productTypes: string[];
        /**
         * Subscription start date
         */
        startDate: string;
        /**
         * Subscription status
         */
        status: string;
        /**
         * Subscription's ID
         */
        subscriptionId: string;
        /**
         * Web order id
         */
        webOrderId: string;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemCounts {
        /**
         * Number of networks bound to this subscription
         */
        networks: number;
        /**
         * Seat distribution
         */
        seats: outputs.administered.LicensingSubscriptionSubscriptionsClaimItemCountsSeats;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemCountsSeats {
        /**
         * Number of seats in use
         */
        assigned: number;
        /**
         * Number of seats available for use
         */
        available: number;
        /**
         * Total number of seats provided by this subscription
         */
        limit: number;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemEntitlement {
        /**
         * Seat distribution
         */
        seats: outputs.administered.LicensingSubscriptionSubscriptionsClaimItemEntitlementSeats;
        /**
         * SKU of the required product
         */
        sku: string;
    }

    export interface LicensingSubscriptionSubscriptionsClaimItemEntitlementSeats {
        /**
         * Number of seats in use
         */
        assigned: number;
        /**
         * Number of seats available for use
         */
        available: number;
        /**
         * Total number of seats provided by this subscription for this sku
         */
        limit: number;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItem {
        /**
         * Numeric breakdown of network and entitlement counts
         */
        counts: outputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemCounts;
        /**
         * Subscription description
         */
        description: string;
        /**
         * Subscription expiration date
         */
        endDate: string;
        /**
         * Entitlement info
         */
        entitlements: outputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlement[];
        /**
         * Subscription name
         */
        name: string;
        /**
         * Products the subscription has entitlements for
         */
        productTypes: string[];
        /**
         * Subscription start date
         */
        startDate: string;
        /**
         * Subscription status
         */
        status: string;
        /**
         * Subscription's ID
         */
        subscriptionId: string;
        /**
         * Web order id
         */
        webOrderId: string;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemCounts {
        /**
         * Number of networks bound to this subscription
         */
        networks: number;
        /**
         * Seat distribution
         */
        seats: outputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemCountsSeats;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemCountsSeats {
        /**
         * Number of seats in use
         */
        assigned: number;
        /**
         * Number of seats available for use
         */
        available: number;
        /**
         * Total number of seats provided by this subscription
         */
        limit: number;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlement {
        /**
         * Seat distribution
         */
        seats: outputs.administered.LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlementSeats;
        /**
         * SKU of the required product
         */
        sku: string;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateItemEntitlementSeats {
        /**
         * Number of seats in use
         */
        assigned: number;
        /**
         * Number of seats available for use
         */
        available: number;
        /**
         * Total number of seats provided by this subscription for this sku
         */
        limit: number;
    }

    export interface LicensingSubscriptionSubscriptionsClaimKeyValidateParameters {
        /**
         * The subscription's claim key
         */
        claimKey: string;
    }

    export interface LicensingSubscriptionSubscriptionsClaimParameters {
        /**
         * The subscription's claim key
         */
        claimKey: string;
        /**
         * Extra details or notes about the subscription
         */
        description: string;
        /**
         * Friendly name to identify the subscription
         */
        name: string;
        /**
         * The id of the organization claiming the subscription
         */
        organizationId: string;
    }

}

export namespace devices {
    export interface ApplianceRadioSettingsFiveGhzSettings {
        /**
         * Manual channel for 5 GHz
         */
        channel: number;
        /**
         * Manual channel width for 5 GHz
         */
        channelWidth: number;
        /**
         * Manual target power for 5 GHz
         */
        targetPower: number;
    }

    export interface ApplianceRadioSettingsTwoFourGhzSettings {
        /**
         * Manual channel for 2.4 GHz
         */
        channel: number;
        /**
         * Manual target power for 2.4 GHz
         */
        targetPower: number;
    }

    export interface ApplianceUplinksSettingsInterfaces {
        /**
         * WAN 1 settings.
         */
        wan1: outputs.devices.ApplianceUplinksSettingsInterfacesWan1;
        /**
         * WAN 2 settings.
         */
        wan2: outputs.devices.ApplianceUplinksSettingsInterfacesWan2;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1 {
        /**
         * Enable or disable the interface.
         */
        enabled: boolean;
        /**
         * Configuration options for PPPoE.
         */
        pppoe: outputs.devices.ApplianceUplinksSettingsInterfacesWan1Pppoe;
        /**
         * SVI settings by protocol.
         */
        svis: outputs.devices.ApplianceUplinksSettingsInterfacesWan1Svis;
        /**
         * VLAN tagging settings.
         */
        vlanTagging: outputs.devices.ApplianceUplinksSettingsInterfacesWan1VlanTagging;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1Pppoe {
        /**
         * Settings for PPPoE Authentication.
         */
        authentication: outputs.devices.ApplianceUplinksSettingsInterfacesWan1PppoeAuthentication;
        /**
         * Whether PPPoE is enabled.
         */
        enabled: boolean;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1PppoeAuthentication {
        /**
         * Whether PPPoE authentication is enabled.
         */
        enabled: boolean;
        /**
         * Password for PPPoE authentication. This parameter is not returned.
         */
        password: string;
        /**
         * Username for PPPoE authentication.
         */
        username: string;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1Svis {
        /**
         * IPv4 settings for static/dynamic mode.
         */
        ipv4: outputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv4;
        /**
         * IPv6 settings for static/dynamic mode.
         */
        ipv6: outputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv6;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv4 {
        /**
         * IP address and subnet mask when in static mode.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Gateway IP address when in static mode.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv4Nameservers;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv4Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv6 {
        /**
         * Static address that will override the one(s) received by SLAAC.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Static gateway that will override the one received by autoconf.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.ApplianceUplinksSettingsInterfacesWan1SvisIpv6Nameservers;
    }

    export interface ApplianceUplinksSettingsInterfacesWan1SvisIpv6Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface ApplianceUplinksSettingsInterfacesWan1VlanTagging {
        /**
         * Whether VLAN tagging is enabled.
         */
        enabled: boolean;
        /**
         * The ID of the VLAN to use for VLAN tagging.
         */
        vlanId?: number;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2 {
        /**
         * Enable or disable the interface.
         */
        enabled: boolean;
        /**
         * Configuration options for PPPoE.
         */
        pppoe: outputs.devices.ApplianceUplinksSettingsInterfacesWan2Pppoe;
        /**
         * SVI settings by protocol.
         */
        svis: outputs.devices.ApplianceUplinksSettingsInterfacesWan2Svis;
        /**
         * VLAN tagging settings.
         */
        vlanTagging: outputs.devices.ApplianceUplinksSettingsInterfacesWan2VlanTagging;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2Pppoe {
        /**
         * Settings for PPPoE Authentication.
         */
        authentication: outputs.devices.ApplianceUplinksSettingsInterfacesWan2PppoeAuthentication;
        /**
         * Whether PPPoE is enabled.
         */
        enabled: boolean;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2PppoeAuthentication {
        /**
         * Whether PPPoE authentication is enabled.
         */
        enabled: boolean;
        /**
         * Password for PPPoE authentication. This parameter is not returned.
         */
        password: string;
        /**
         * Username for PPPoE authentication.
         */
        username: string;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2Svis {
        /**
         * IPv4 settings for static/dynamic mode.
         */
        ipv4: outputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv4;
        /**
         * IPv6 settings for static/dynamic mode.
         */
        ipv6: outputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv6;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv4 {
        /**
         * IP address and subnet mask when in static mode.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Gateway IP address when in static mode.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv4Nameservers;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv4Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv6 {
        /**
         * Static address that will override the one(s) received by SLAAC.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Static gateway that will override the one received by autoconf.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.ApplianceUplinksSettingsInterfacesWan2SvisIpv6Nameservers;
    }

    export interface ApplianceUplinksSettingsInterfacesWan2SvisIpv6Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface ApplianceUplinksSettingsInterfacesWan2VlanTagging {
        /**
         * Whether VLAN tagging is enabled.
         */
        enabled: boolean;
        /**
         * The ID of the VLAN to use for VLAN tagging.
         */
        vlanId?: number;
    }

    export interface ApplianceVmxAuthenticationTokenItem {
        /**
         * The expiration time for the token, in ISO 8601 format
         */
        expiresAt: string;
        /**
         * The newly generated authentication token for the vMX instance
         */
        token: string;
    }

    export interface BaseDetail {
        /**
         * Additional property name
         */
        name: string;
        /**
         * Additional property value
         */
        value: string;
    }

    export interface BlinkLedsItem {
        /**
         * The duration in seconds. Will be between 5 and 120. Default is 20 seconds
         */
        duration: number;
        /**
         * The duty cycle as the percent active. Will be between 10 and 90. Default is 50
         */
        duty: number;
        /**
         * The period in milliseconds. Will be between 100 and 1000. Default is 160 milliseconds
         */
        period: number;
    }

    export interface BlinkLedsParameters {
        /**
         * The duration in seconds. Must be between 5 and 120. Default is 20 seconds
         */
        duration: number;
        /**
         * The duty cycle as the percent active. Must be between 10 and 90. Default is 50.
         */
        duty: number;
        /**
         * The period in milliseconds. Must be between 100 and 1000. Default is 160 milliseconds
         */
        period: number;
    }

    export interface CameraCustomAnalyticsParameter {
        /**
         * Name of the parameter
         */
        name: string;
        /**
         * Value of the parameter
         */
        value: number;
    }

    export interface CameraGenerateSnapshotParameters {
        /**
         * [optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.
         */
        fullframe: boolean;
        /**
         * [optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.
         */
        timestamp: string;
    }

    export interface CameraSenseAudioDetection {
        /**
         * Boolean indicating if audio detection is enabled(true) or disabled(false) on the camera
         */
        enabled: boolean;
    }

    export interface CameraWirelessProfilesIds {
        /**
         * The id of the backup wireless profile
         */
        backup: string;
        /**
         * The id of the primary wireless profile
         */
        primary: string;
        /**
         * The id of the secondary wireless profile
         */
        secondary: string;
    }

    export interface CellularGatewayLanFixedIpAssignment {
        /**
         * The IP address you want to assign to a specific server or device
         */
        ip: string;
        /**
         * The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
         */
        mac: string;
        /**
         * A descriptive name of the assignment
         */
        name: string;
    }

    export interface CellularGatewayLanReservedIpRange {
        /**
         * Comment explaining the reserved IP range
         */
        comment: string;
        /**
         * Ending IP included in the reserved range of IPs
         */
        end: string;
        /**
         * Starting IP included in the reserved range of IPs
         */
        start: string;
    }

    export interface CellularGatewayPortForwardingRulesRule {
        /**
         * *any* or *restricted*. Specify the right to make inbound connections on the specified ports or port ranges. If *restricted*, a list of allowed IPs is mandatory.
         */
        access: string;
        /**
         * An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.
         */
        allowedIps: string[];
        /**
         * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
         */
        lanIp: string;
        /**
         * A port or port ranges that will receive the forwarded traffic from the WAN
         */
        localPort: string;
        /**
         * A descriptive name for the rule
         */
        name: string;
        /**
         * TCP or UDP
         */
        protocol: string;
        /**
         * A port or port ranges that will be forwarded to the host on the LAN
         */
        publicPort: string;
        uplink: string;
    }

    export interface CellularSimsSim {
        /**
         * APN configurations. If empty, the default APN will be used.
         */
        apns: outputs.devices.CellularSimsSimApn[];
        /**
         * If true, this SIM is used for boot. Must be true on single-sim devices.
         */
        isPrimary: boolean;
        /**
         * SIM slot being configured. Must be 'sim1' on single-sim devices.
         */
        slot: string;
    }

    export interface CellularSimsSimApn {
        /**
         * IP versions to support (permitted values include 'ipv4', 'ipv6').
         */
        allowedIpTypes: string[];
        /**
         * APN authentication configurations.
         */
        authentication: outputs.devices.CellularSimsSimApnAuthentication;
        /**
         * APN name.
         */
        name: string;
    }

    export interface CellularSimsSimApnAuthentication {
        /**
         * APN password, if type is set (if APN password is not supplied, the password is left unchanged).
         */
        password: string;
        /**
         * APN auth type.
         */
        type: string;
        /**
         * APN username, if type is set.
         */
        username: string;
    }

    export interface CellularSimsSimFailover {
        /**
         * Failover to secondary SIM (optional)
         */
        enabled: boolean;
        /**
         * Failover timeout in seconds (optional)
         */
        timeout: number;
    }

    export interface GetAppliancePerformanceItem {
        perfScore: number;
    }

    export interface GetApplianceRadioSettingsItem {
        /**
         * Manual radio settings for 5 GHz
         */
        fiveGhzSettings: outputs.devices.GetApplianceRadioSettingsItemFiveGhzSettings;
        /**
         * RF Profile ID
         */
        rfProfileId: string;
        /**
         * The device serial
         */
        serial: string;
        /**
         * Manual radio settings for 2.4 GHz
         */
        twoFourGhzSettings: outputs.devices.GetApplianceRadioSettingsItemTwoFourGhzSettings;
    }

    export interface GetApplianceRadioSettingsItemFiveGhzSettings {
        /**
         * Manual channel for 5 GHz
         */
        channel: number;
        /**
         * Manual channel width for 5 GHz
         */
        channelWidth: number;
        /**
         * Manual target power for 5 GHz
         */
        targetPower: number;
    }

    export interface GetApplianceRadioSettingsItemTwoFourGhzSettings {
        /**
         * Manual channel for 2.4 GHz
         */
        channel: number;
        /**
         * Manual target power for 2.4 GHz
         */
        targetPower: number;
    }

    export interface GetApplianceUplinksSettingsItem {
        /**
         * Interface settings.
         */
        interfaces: outputs.devices.GetApplianceUplinksSettingsItemInterfaces;
    }

    export interface GetApplianceUplinksSettingsItemInterfaces {
        /**
         * WAN 1 settings.
         */
        wan1: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1;
        /**
         * WAN 2 settings.
         */
        wan2: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1 {
        /**
         * Enable or disable the interface.
         */
        enabled: boolean;
        /**
         * Configuration options for PPPoE.
         */
        pppoe: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1Pppoe;
        /**
         * SVI settings by protocol.
         */
        svis: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1Svis;
        /**
         * VLAN tagging settings.
         */
        vlanTagging: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1VlanTagging;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1Pppoe {
        /**
         * Settings for PPPoE Authentication.
         */
        authentication: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1PppoeAuthentication;
        /**
         * Whether PPPoE is enabled.
         */
        enabled: boolean;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1PppoeAuthentication {
        /**
         * Whether PPPoE authentication is enabled.
         */
        enabled: boolean;
        /**
         * Username for PPPoE authentication.
         */
        username: string;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1Svis {
        /**
         * IPv4 settings for static/dynamic mode.
         */
        ipv4: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv4;
        /**
         * IPv6 settings for static/dynamic mode.
         */
        ipv6: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv6;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv4 {
        /**
         * IP address and subnet mask when in static mode.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Gateway IP address when in static mode.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv4Nameservers;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv4Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv6 {
        /**
         * Static address that will override the one(s) received by SLAAC.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Static gateway that will override the one received by autoconf.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv6Nameservers;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1SvisIpv6Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan1VlanTagging {
        /**
         * Whether VLAN tagging is enabled.
         */
        enabled: boolean;
        /**
         * The ID of the VLAN to use for VLAN tagging.
         */
        vlanId: number;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2 {
        /**
         * Enable or disable the interface.
         */
        enabled: boolean;
        /**
         * Configuration options for PPPoE.
         */
        pppoe: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2Pppoe;
        /**
         * SVI settings by protocol.
         */
        svis: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2Svis;
        /**
         * VLAN tagging settings.
         */
        vlanTagging: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2VlanTagging;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2Pppoe {
        /**
         * Settings for PPPoE Authentication.
         */
        authentication: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2PppoeAuthentication;
        /**
         * Whether PPPoE is enabled.
         */
        enabled: boolean;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2PppoeAuthentication {
        /**
         * Whether PPPoE authentication is enabled.
         */
        enabled: boolean;
        /**
         * Username for PPPoE authentication.
         */
        username: string;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2Svis {
        /**
         * IPv4 settings for static/dynamic mode.
         */
        ipv4: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv4;
        /**
         * IPv6 settings for static/dynamic mode.
         */
        ipv6: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv6;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv4 {
        /**
         * IP address and subnet mask when in static mode.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Gateway IP address when in static mode.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv4Nameservers;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv4Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv6 {
        /**
         * Static address that will override the one(s) received by SLAAC.
         */
        address: string;
        /**
         * The assignment mode for this SVI. Applies only when PPPoE is disabled.
         */
        assignmentMode: string;
        /**
         * Static gateway that will override the one received by autoconf.
         */
        gateway: string;
        /**
         * The nameserver settings for this SVI.
         */
        nameservers: outputs.devices.GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv6Nameservers;
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2SvisIpv6Nameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface GetApplianceUplinksSettingsItemInterfacesWan2VlanTagging {
        /**
         * Whether VLAN tagging is enabled.
         */
        enabled: boolean;
        /**
         * The ID of the VLAN to use for VLAN tagging.
         */
        vlanId: number;
    }

    export interface GetCameraAnalyticsLiveItem {
        ts: string;
        zones: outputs.devices.GetCameraAnalyticsLiveItemZones;
    }

    export interface GetCameraAnalyticsLiveItemZones {
        status0: outputs.devices.GetCameraAnalyticsLiveItemZonesStatus0;
    }

    export interface GetCameraAnalyticsLiveItemZonesStatus0 {
        person: number;
    }

    export interface GetCameraCustomAnalyticsItem {
        /**
         * Custom analytics artifact ID
         */
        artifactId: string;
        /**
         * Whether custom analytics is enabled
         */
        enabled: boolean;
        /**
         * Parameters for the custom analytics workload
         */
        parameters: outputs.devices.GetCameraCustomAnalyticsItemParameter[];
    }

    export interface GetCameraCustomAnalyticsItemParameter {
        /**
         * Name of the parameter
         */
        name: string;
        /**
         * Value of the parameter
         */
        value: number;
    }

    export interface GetCameraQualityAndRetentionItem {
        audioRecordingEnabled: boolean;
        motionBasedRetentionEnabled: boolean;
        motionDetectorVersion: number;
        profileId: string;
        quality: string;
        resolution: string;
        restrictedBandwidthModeEnabled: boolean;
    }

    export interface GetCameraSenseItem {
        audioDetection: outputs.devices.GetCameraSenseItemAudioDetection;
        mqttBrokerId: string;
        mqttTopics: string[];
        senseEnabled: boolean;
    }

    export interface GetCameraSenseItemAudioDetection {
        enabled: boolean;
    }

    export interface GetCameraVideoLinkItem {
        url: string;
        visionUrl: string;
    }

    export interface GetCameraVideoSettingsItem {
        /**
         * Boolean indicating if external rtsp stream is exposed
         */
        externalRtspEnabled: boolean;
        /**
         * External rstp url. Will only be returned if external rtsp stream is exposed
         */
        rtspUrl: string;
    }

    export interface GetCameraWirelessProfilesItem {
        ids: outputs.devices.GetCameraWirelessProfilesItemIds;
    }

    export interface GetCameraWirelessProfilesItemIds {
        backup: string;
        primary: string;
        secondary: string;
    }

    export interface GetCellularGatewayLanItem {
        /**
         * Lan IP of the MG
         */
        deviceLanIp: string;
        /**
         * Name of the MG.
         */
        deviceName: string;
        /**
         * Subnet configuration of the MG.
         */
        deviceSubnet: string;
        /**
         * list of all fixed IP assignments for a single MG
         */
        fixedIpAssignments: outputs.devices.GetCellularGatewayLanItemFixedIpAssignment[];
        /**
         * list of all reserved IP ranges for a single MG
         */
        reservedIpRanges: outputs.devices.GetCellularGatewayLanItemReservedIpRange[];
    }

    export interface GetCellularGatewayLanItemFixedIpAssignment {
        /**
         * The IP address you want to assign to a specific server or device
         */
        ip: string;
        /**
         * The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address
         */
        mac: string;
        /**
         * A descriptive name of the assignment
         */
        name: string;
    }

    export interface GetCellularGatewayLanItemReservedIpRange {
        /**
         * Comment explaining the reserved IP range
         */
        comment: string;
        /**
         * Ending IP included in the reserved range of IPs
         */
        end: string;
        /**
         * Starting IP included in the reserved range of IPs
         */
        start: string;
    }

    export interface GetCellularGatewayPortForwardingRulesItem {
        rules: outputs.devices.GetCellularGatewayPortForwardingRulesItemRule[];
    }

    export interface GetCellularGatewayPortForwardingRulesItemRule {
        access: string;
        lanIp: string;
        localPort: string;
        name: string;
        protocol: string;
        publicPort: string;
        uplink: string;
    }

    export interface GetCellularSimsItem {
        sims: outputs.devices.GetCellularSimsItemSim[];
    }

    export interface GetCellularSimsItemSim {
        apns: outputs.devices.GetCellularSimsItemSimApn[];
        isPrimary: boolean;
        slot: string;
    }

    export interface GetCellularSimsItemSimApn {
        allowedIpTypes: string[];
        authentication: outputs.devices.GetCellularSimsItemSimApnAuthentication;
        name: string;
    }

    export interface GetCellularSimsItemSimApnAuthentication {
        type: string;
        username: string;
    }

    export interface GetLiveToolsArpTableItem {
        /**
         * Id of the ARP table request. Used to check the status of the request.
         */
        arpTableId: string;
        /**
         * The ARP table entries
         */
        entries: outputs.devices.GetLiveToolsArpTableItemEntry[];
        /**
         * An error message for a failed execution
         */
        error: string;
        /**
         * ARP table request parameters
         */
        request: outputs.devices.GetLiveToolsArpTableItemRequest;
        /**
         * Status of the ARP table request.
         */
        status: string;
        /**
         * GET this url to check the status of your ARP table request.
         */
        url: string;
    }

    export interface GetLiveToolsArpTableItemEntry {
        /**
         * The IP address of the ARP table entry
         */
        ip: string;
        /**
         * Time of the last update of the ARP table entry
         */
        lastUpdatedAt: string;
        /**
         * The MAC address of the ARP table entry
         */
        mac: string;
        /**
         * The VLAN ID of the ARP table entry
         */
        vlanId: number;
    }

    export interface GetLiveToolsArpTableItemRequest {
        /**
         * Device serial number
         */
        serial: string;
    }

    export interface GetLiveToolsCableTestItem {
        /**
         * Id of the cable test request. Used to check the status of the request.
         */
        cableTestId: string;
        /**
         * An error message for a failed execution
         */
        error: string;
        /**
         * Cable test request parameters
         */
        request: outputs.devices.GetLiveToolsCableTestItemRequest;
        /**
         * Results of the cable test request, one for each requested port.
         */
        results: outputs.devices.GetLiveToolsCableTestItemResult[];
        /**
         * Status of the cable test request.
         */
        status: string;
        /**
         * GET this url to check the status of your cable test request.
         */
        url: string;
    }

    export interface GetLiveToolsCableTestItemRequest {
        /**
         * A list of ports for which to perform the cable test.
         */
        ports: string[];
        /**
         * Device serial number
         */
        serial: string;
    }

    export interface GetLiveToolsCableTestItemResult {
        /**
         * If an error occurred during the cable test, the error message will be populated here.
         */
        error: string;
        /**
         * Results for each twisted pair within the cable.
         */
        pairs: outputs.devices.GetLiveToolsCableTestItemResultPair[];
        /**
         * The port for which the test was performed.
         */
        port: string;
        /**
         * Speed in Mbps.  A speed of 0 indicates the port is down or the port speed is automatic.
         */
        speedMbps: number;
        /**
         * The current status of the port. If the cable test is still being performed on the port, "in-progress" is used. If an error occurred during the cable test, "error" is used and the error property will be populated.
         */
        status: string;
    }

    export interface GetLiveToolsCableTestItemResultPair {
        /**
         * The index of the twisted pair tested.
         */
        index: number;
        /**
         * The detected length of the twisted pair.
         */
        lengthMeters: number;
        /**
         * The test result of the twisted pair tested.
         */
        status: string;
    }

    export interface GetLiveToolsPingDeviceItem {
        /**
         * Information for callback used to send back results
         */
        callback: outputs.devices.GetLiveToolsPingDeviceItemCallback;
        /**
         * Id to check the status of your ping request.
         */
        pingId: string;
        /**
         * Ping request parameters
         */
        request: outputs.devices.GetLiveToolsPingDeviceItemRequest;
        /**
         * Results of the ping request.
         */
        results: outputs.devices.GetLiveToolsPingDeviceItemResults;
        /**
         * Status of the ping request.
         */
        status: string;
        /**
         * GET this url to check the status of your ping request.
         */
        url: string;
    }

    export interface GetLiveToolsPingDeviceItemCallback {
        /**
         * The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
         */
        id: string;
        /**
         * The status of the callback
         */
        status: string;
        /**
         * The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
         */
        url: string;
    }

    export interface GetLiveToolsPingDeviceItemRequest {
        /**
         * Number of pings to send
         */
        countR: number;
        /**
         * Device serial number
         */
        serial: string;
        /**
         * IP address or FQDN to ping
         */
        target: string;
    }

    export interface GetLiveToolsPingDeviceItemResults {
        /**
         * Packet latency stats
         */
        latencies: outputs.devices.GetLiveToolsPingDeviceItemResultsLatencies;
        /**
         * Lost packets
         */
        loss: outputs.devices.GetLiveToolsPingDeviceItemResultsLoss;
        /**
         * Number of packets received
         */
        received: number;
        /**
         * Received packets
         */
        replies: outputs.devices.GetLiveToolsPingDeviceItemResultsReply[];
        /**
         * Number of packets sent
         */
        sent: number;
    }

    export interface GetLiveToolsPingDeviceItemResultsLatencies {
        /**
         * Average latency
         */
        average: number;
        /**
         * Maximum latency
         */
        maximum: number;
        /**
         * Minimum latency
         */
        minimum: number;
    }

    export interface GetLiveToolsPingDeviceItemResultsLoss {
        /**
         * Percentage of packets lost
         */
        percentage: number;
    }

    export interface GetLiveToolsPingDeviceItemResultsReply {
        /**
         * Latency of the packet in milliseconds
         */
        latency: number;
        /**
         * Sequence ID of the packet
         */
        sequenceId: number;
        /**
         * Size of the packet in bytes
         */
        size: number;
    }

    export interface GetLiveToolsPingItem {
        /**
         * Id to check the status of your ping request.
         */
        pingId: string;
        /**
         * Ping request parameters
         */
        request: outputs.devices.GetLiveToolsPingItemRequest;
        /**
         * Results of the ping request.
         */
        results: outputs.devices.GetLiveToolsPingItemResults;
        /**
         * Status of the ping request.
         */
        status: string;
        /**
         * GET this url to check the status of your ping request.
         */
        url: string;
    }

    export interface GetLiveToolsPingItemRequest {
        /**
         * Number of pings to send
         */
        countR: number;
        /**
         * Device serial number
         */
        serial: string;
        /**
         * IP address or FQDN to ping
         */
        target: string;
    }

    export interface GetLiveToolsPingItemResults {
        /**
         * Packet latency stats
         */
        latencies: outputs.devices.GetLiveToolsPingItemResultsLatencies;
        /**
         * Lost packets
         */
        loss: outputs.devices.GetLiveToolsPingItemResultsLoss;
        /**
         * Number of packets received
         */
        received: number;
        /**
         * Received packets
         */
        replies: outputs.devices.GetLiveToolsPingItemResultsReply[];
        /**
         * Number of packets sent
         */
        sent: number;
    }

    export interface GetLiveToolsPingItemResultsLatencies {
        /**
         * Average latency
         */
        average: number;
        /**
         * Maximum latency
         */
        maximum: number;
        /**
         * Minimum latency
         */
        minimum: number;
    }

    export interface GetLiveToolsPingItemResultsLoss {
        /**
         * Percentage of packets lost
         */
        percentage: number;
    }

    export interface GetLiveToolsPingItemResultsReply {
        /**
         * Latency of the packet in milliseconds
         */
        latency: number;
        /**
         * Sequence ID of the packet
         */
        sequenceId: number;
        /**
         * Size of the packet in bytes
         */
        size: number;
    }

    export interface GetLiveToolsThroughputTestItem {
        /**
         * Description of the error.
         */
        error: string;
        /**
         * The parameters of the throughput test request
         */
        request: outputs.devices.GetLiveToolsThroughputTestItemRequest;
        /**
         * Result of the throughput test request
         */
        result: outputs.devices.GetLiveToolsThroughputTestItemResult;
        /**
         * Status of the throughput test request
         */
        status: string;
        /**
         * ID of throughput test job
         */
        throughputTestId: string;
        /**
         * GET this url to check the status of your throughput test request
         */
        url: string;
    }

    export interface GetLiveToolsThroughputTestItemRequest {
        /**
         * Device serial number
         */
        serial: string;
    }

    export interface GetLiveToolsThroughputTestItemResult {
        /**
         * Shows the speeds (Mbps)
         */
        speeds: outputs.devices.GetLiveToolsThroughputTestItemResultSpeeds;
    }

    export interface GetLiveToolsThroughputTestItemResultSpeeds {
        /**
         * Shows the download speed from shard (Mbps)
         */
        downstream: number;
    }

    export interface GetLiveToolsWakeOnLanItem {
        /**
         * An error message for a failed execution
         */
        error: string;
        /**
         * The parameters of the Wake-on-LAN request
         */
        request: outputs.devices.GetLiveToolsWakeOnLanItemRequest;
        /**
         * Status of the Wake-on-LAN request
         */
        status: string;
        /**
         * GET this url to check the status of your ping request
         */
        url: string;
        /**
         * ID of the Wake-on-LAN job
         */
        wakeOnLanId: string;
    }

    export interface GetLiveToolsWakeOnLanItemRequest {
        /**
         * The target's MAC address
         */
        mac: string;
        /**
         * Device serial number
         */
        serial: string;
        /**
         * The target's VLAN (1 to 4094)
         */
        vlanId: number;
    }

    export interface GetLldpCdpItem {
        ports: outputs.devices.GetLldpCdpItemPorts;
        /**
         * Source MAC address
         */
        sourceMac: string;
    }

    export interface GetLldpCdpItemPorts {
        status12: outputs.devices.GetLldpCdpItemPortsStatus12;
        status8: outputs.devices.GetLldpCdpItemPortsStatus8;
    }

    export interface GetLldpCdpItemPortsStatus12 {
        cdp: outputs.devices.GetLldpCdpItemPortsStatus12Cdp;
        lldp: outputs.devices.GetLldpCdpItemPortsStatus12Lldp;
    }

    export interface GetLldpCdpItemPortsStatus12Cdp {
        address: string;
        deviceId: string;
        portId: string;
        sourcePort: string;
    }

    export interface GetLldpCdpItemPortsStatus12Lldp {
        managementAddress: string;
        portId: string;
        sourcePort: string;
        systemName: string;
    }

    export interface GetLldpCdpItemPortsStatus8 {
        cdp: outputs.devices.GetLldpCdpItemPortsStatus8Cdp;
    }

    export interface GetLldpCdpItemPortsStatus8Cdp {
        address: string;
        deviceId: string;
        portId: string;
        sourcePort: string;
    }

    export interface GetManagementInterfaceItem {
        /**
         * Dynamic DNS hostnames.
         */
        ddnsHostnames: outputs.devices.GetManagementInterfaceItemDdnsHostnames;
        /**
         * WAN 1 settings
         */
        wan1: outputs.devices.GetManagementInterfaceItemWan1;
        /**
         * WAN 2 settings (only for MX devices)
         */
        wan2: outputs.devices.GetManagementInterfaceItemWan2;
    }

    export interface GetManagementInterfaceItemDdnsHostnames {
        /**
         * Active dynamic DNS hostname.
         */
        activeDdnsHostname: string;
        /**
         * WAN 1 dynamic DNS hostname.
         */
        ddnsHostnameWan1: string;
        /**
         * WAN 2 dynamic DNS hostname.
         */
        ddnsHostnameWan2: string;
    }

    export interface GetManagementInterfaceItemWan1 {
        /**
         * Up to two DNS IPs.
         */
        staticDns: string[];
        /**
         * The IP of the gateway on the WAN.
         */
        staticGatewayIp: string;
        /**
         * The IP the device should use on the WAN.
         */
        staticIp: string;
        /**
         * The subnet mask for the WAN.
         */
        staticSubnetMask: string;
        /**
         * Configure the interface to have static IP settings or use DHCP.
         */
        usingStaticIp: boolean;
        /**
         * The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
         */
        vlan: number;
        /**
         * Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
         */
        wanEnabled: string;
    }

    export interface GetManagementInterfaceItemWan2 {
        /**
         * Up to two DNS IPs.
         */
        staticDns: string[];
        /**
         * The IP of the gateway on the WAN.
         */
        staticGatewayIp: string;
        /**
         * The IP the device should use on the WAN.
         */
        staticIp: string;
        /**
         * The subnet mask for the WAN.
         */
        staticSubnetMask: string;
        /**
         * Configure the interface to have static IP settings or use DHCP.
         */
        usingStaticIp: boolean;
        /**
         * The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
         */
        vlan: number;
        /**
         * Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
         */
        wanEnabled: string;
    }

    export interface GetSensorRelationshipsItem {
        /**
         * A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
         */
        livestream: outputs.devices.GetSensorRelationshipsItemLivestream;
    }

    export interface GetSensorRelationshipsItemLivestream {
        /**
         * An array of the related devices for the role
         */
        relatedDevices: outputs.devices.GetSensorRelationshipsItemLivestreamRelatedDevice[];
    }

    export interface GetSensorRelationshipsItemLivestreamRelatedDevice {
        /**
         * The product type of the related device
         */
        productType: string;
        /**
         * The serial of the related device
         */
        serial: string;
    }

    export interface GetSwitchPortsItem {
        /**
         * The number of a custom access policy to configure on the switch port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
         */
        accessPolicyNumber: number;
        /**
         * The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
         */
        accessPolicyType: string;
        /**
         * The adaptive policy group ID that will be used to tag traffic through this switch port. This ID must pre-exist during the configuration, else needs to be created using adaptivePolicy/groups API. Cannot be applied to a port on a switch bound to profile.
         */
        adaptivePolicyGroupId: string;
        /**
         * The VLANs allowed on the switch port. Only applicable to trunk ports.
         */
        allowedVlans: string;
        /**
         * If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
         */
        daiTrusted: boolean;
        /**
         * The status of the switch port.
         */
        enabled: boolean;
        /**
         * For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
         */
        flexibleStackingEnabled: boolean;
        /**
         * The isolation status of the switch port.
         */
        isolationEnabled: boolean;
        /**
         * The link speed for the switch port.
         */
        linkNegotiation: string;
        /**
         * Available link speeds for the switch port.
         */
        linkNegotiationCapabilities: string[];
        /**
         * Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
         */
        macAllowLists: string[];
        /**
         * Port mirror
         */
        mirror: outputs.devices.GetSwitchPortsItemMirror;
        /**
         * Expansion module
         */
        module: outputs.devices.GetSwitchPortsItemModule;
        /**
         * The name of the switch port.
         */
        name: string;
        /**
         * If true, Peer SGT is enabled for traffic through this switch port. Applicable to trunk port only, not access port. Cannot be applied to a port on a switch bound to profile.
         */
        peerSgtCapable: boolean;
        /**
         * The PoE status of the switch port.
         */
        poeEnabled: boolean;
        /**
         * The identifier of the switch port.
         */
        portId: string;
        /**
         * The ID of the port schedule. A value of null will clear the port schedule.
         */
        portScheduleId: string;
        /**
         * Profile attributes
         */
        profile: outputs.devices.GetSwitchPortsItemProfile;
        /**
         * The rapid spanning tree protocol status.
         */
        rstpEnabled: boolean;
        /**
         * The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
         */
        stickyMacAllowListLimit: number;
        /**
         * The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
         */
        stickyMacAllowLists: string[];
        /**
         * The storm control status of the switch port.
         */
        stormControlEnabled: boolean;
        /**
         * The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
         */
        stpGuard: string;
        /**
         * The list of tags of the switch port.
         */
        tags: string[];
        /**
         * The type of the switch port ('trunk' or 'access').
         */
        type: string;
        /**
         * The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
         */
        udld: string;
        /**
         * The VLAN of the switch port. For a trunk port, this is the native VLAN. A null value will clear the value set for trunk ports.
         */
        vlan: number;
        /**
         * The voice VLAN of the switch port. Only applicable to access ports.
         */
        voiceVlan: number;
    }

    export interface GetSwitchPortsItemMirror {
        /**
         * The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
         */
        mode: string;
    }

    export interface GetSwitchPortsItemModule {
        /**
         * The model of the expansion module.
         */
        model: string;
    }

    export interface GetSwitchPortsItemProfile {
        /**
         * When enabled, override this port's configuration with a port profile.
         */
        enabled: boolean;
        /**
         * When enabled, the ID of the port profile used to override the port's configuration.
         */
        id: string;
        /**
         * When enabled, the IName of the profile.
         */
        iname: string;
    }

    export interface GetSwitchPortsStatusesItem {
        /**
         * The Cisco Discovery Protocol (CDP) information of the connected device.
         */
        cdp: outputs.devices.GetSwitchPortsStatusesItemCdp;
        /**
         * The number of clients connected through this port.
         */
        clientCount: number;
        /**
         * The current duplex of a connected port.
         */
        duplex: string;
        /**
         * Whether the port is configured to be enabled.
         */
        enabled: boolean;
        /**
         * All errors present on the port.
         */
        errors: string[];
        /**
         * Whether the port is the switch's uplink.
         */
        isUplink: boolean;
        /**
         * The Link Layer Discovery Protocol (LLDP) information of the connected device.
         */
        lldp: outputs.devices.GetSwitchPortsStatusesItemLldp;
        /**
         * The string identifier of this port on the switch. This is commonly just the port number but may contain additional identifying information such as the slot and module-type if the port is located on a port module.
         */
        portId: string;
        /**
         * How much power (in watt-hours) has been delivered by this port during the timespan.
         */
        powerUsageInWh: number;
        /**
         * The Secure Port status of the port.
         */
        securePort: outputs.devices.GetSwitchPortsStatusesItemSecurePort;
        /**
         * The Spanning Tree Protocol (STP) information of the connected device.
         */
        spanningTree: outputs.devices.GetSwitchPortsStatusesItemSpanningTree;
        /**
         * The current data transfer rate which the port is operating at.
         */
        speed: string;
        /**
         * The current connection status of the port.
         */
        status: string;
        /**
         * A breakdown of the average speed of data that has passed through this port during the timespan.
         */
        trafficInKbps: outputs.devices.GetSwitchPortsStatusesItemTrafficInKbps;
        /**
         * A breakdown of how many kilobytes have passed through this port during the timespan.
         */
        usageInKb: outputs.devices.GetSwitchPortsStatusesItemUsageInKb;
        /**
         * All warnings present on the port.
         */
        warnings: string[];
    }

    export interface GetSwitchPortsStatusesItemCdp {
        /**
         * Contains network addresses of both receiving and sending devices.
         */
        address: string;
        /**
         * Identifies the device type, which indicates the functional capabilities of the device.
         */
        capabilities: string;
        /**
         * Identifies the device name.
         */
        deviceId: string;
        /**
         * The device's management IP.
         */
        managementAddress: string;
        /**
         * Indicates, per interface, the assumed VLAN for untagged packets on the interface.
         */
        nativeVlan: number;
        /**
         * Identifies the hardware platform of the device.
         */
        platform: string;
        /**
         * Identifies the port from which the CDP packet was sent.
         */
        portId: string;
        /**
         * The system name.
         */
        systemName: string;
        /**
         * Contains the device software release information.
         */
        version: string;
        /**
         * Advertises the configured VLAN Trunking Protocl (VTP)-management-domain name of the system.
         */
        vtpManagementDomain: string;
    }

    export interface GetSwitchPortsStatusesItemLldp {
        /**
         * The device's chassis ID.
         */
        chassisId: string;
        /**
         * The device's management IP.
         */
        managementAddress: string;
        /**
         * The device's management VLAN.
         */
        managementVlan: number;
        /**
         * Description of the port from which the LLDP packet was sent.
         */
        portDescription: string;
        /**
         * Identifies the port from which the LLDP packet was sent
         */
        portId: string;
        /**
         * The port's VLAN.
         */
        portVlan: number;
        /**
         * Identifies the device type, which indicates the functional capabilities of the device.
         */
        systemCapabilities: string;
        /**
         * The device's system description.
         */
        systemDescription: string;
        /**
         * The device's system name.
         */
        systemName: string;
    }

    export interface GetSwitchPortsStatusesItemSecurePort {
        /**
         * Whether Secure Port is currently active for this port.
         */
        active: boolean;
        /**
         * The current Secure Port status.
         */
        authenticationStatus: string;
        /**
         * The configuration overrides applied to this port when Secure Port is active.
         */
        configOverrides: outputs.devices.GetSwitchPortsStatusesItemSecurePortConfigOverrides;
        /**
         * Whether Secure Port is turned on for this port.
         */
        enabled: boolean;
    }

    export interface GetSwitchPortsStatusesItemSecurePortConfigOverrides {
        /**
         * The VLANs allowed on the . Only applicable to trunk ports.
         */
        allowedVlans: string;
        /**
         * The type of the  ('trunk' or 'access').
         */
        type: string;
        /**
         * The VLAN of the . For a trunk port, this is the native VLAN. A null value will clear the value set for trunk ports.
         */
        vlan: number;
        /**
         * The voice VLAN of the . Only applicable to access ports.
         */
        voiceVlan: number;
    }

    export interface GetSwitchPortsStatusesItemSpanningTree {
        /**
         * The current Spanning Tree Protocol statuses of the port.
         */
        statuses: string[];
    }

    export interface GetSwitchPortsStatusesItemTrafficInKbps {
        /**
         * The average speed of the data received (in kilobits-per-second).
         */
        recv: number;
        /**
         * The average speed of the data sent (in kilobits-per-second).
         */
        sent: number;
        /**
         * The average speed of the data sent and received (in kilobits-per-second).
         */
        total: number;
    }

    export interface GetSwitchPortsStatusesItemUsageInKb {
        /**
         * The amount of data received (in kilobytes).
         */
        recv: number;
        /**
         * The amount of data sent (in kilobytes).
         */
        sent: number;
        /**
         * The total amount of data sent and received (in kilobytes).
         */
        total: number;
    }

    export interface GetSwitchRoutingInterfacesDhcpItem {
        /**
         * The PXE boot server file name for the DHCP server running on the switch stack interface
         */
        bootFileName: string;
        /**
         * The PXE boot server IP for the DHCP server running on the switch stack interface
         */
        bootNextServer: string;
        /**
         * Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface
         */
        bootOptionsEnabled: boolean;
        /**
         * The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
         */
        dhcpLeaseTime: string;
        /**
         * The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
         */
        dhcpMode: string;
        /**
         * Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface
         */
        dhcpOptions: outputs.devices.GetSwitchRoutingInterfacesDhcpItemDhcpOption[];
        /**
         * The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface
         */
        dhcpRelayServerIps: string[];
        /**
         * The DHCP name server IPs when DHCP name server option is 'custom'
         */
        dnsCustomNameservers: string[];
        /**
         * The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')
         */
        dnsNameserversOption: string;
        /**
         * Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
         */
        fixedIpAssignments: outputs.devices.GetSwitchRoutingInterfacesDhcpItemFixedIpAssignment[];
        /**
         * Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
         */
        reservedIpRanges: outputs.devices.GetSwitchRoutingInterfacesDhcpItemReservedIpRange[];
    }

    export interface GetSwitchRoutingInterfacesDhcpItemDhcpOption {
        /**
         * The code for DHCP option which should be from 2 to 254
         */
        code: string;
        /**
         * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
         */
        type: string;
        /**
         * The value of the DHCP option
         */
        value: string;
    }

    export interface GetSwitchRoutingInterfacesDhcpItemFixedIpAssignment {
        /**
         * The IP address of the client which has fixed IP address assigned to it
         */
        ip: string;
        /**
         * The MAC address of the client which has fixed IP address
         */
        mac: string;
        /**
         * The name of the client which has fixed IP address
         */
        name: string;
    }

    export interface GetSwitchRoutingInterfacesDhcpItemReservedIpRange {
        /**
         * The comment for the reserved IP range
         */
        comment: string;
        /**
         * The ending IP address of the reserved IP range
         */
        end: string;
        /**
         * The starting IP address of the reserved IP range
         */
        start: string;
    }

    export interface GetSwitchRoutingInterfacesItem {
        /**
         * IPv4 default gateway
         */
        defaultGateway: string;
        /**
         * The id
         */
        interfaceId: string;
        /**
         * IPv4 address
         */
        interfaceIp: string;
        /**
         * IPv6 addressing
         */
        ipv6: outputs.devices.GetSwitchRoutingInterfacesItemIpv6;
        /**
         * Multicast routing status
         */
        multicastRouting: string;
        /**
         * The name
         */
        name: string;
        /**
         * IPv4 OSPF Settings
         */
        ospfSettings: outputs.devices.GetSwitchRoutingInterfacesItemOspfSettings;
        /**
         * IPv6 OSPF Settings
         */
        ospfV3: outputs.devices.GetSwitchRoutingInterfacesItemOspfV3;
        /**
         * IPv4 subnet
         */
        subnet: string;
        /**
         * VLAN id
         */
        vlanId: number;
    }

    export interface GetSwitchRoutingInterfacesItemIpv6 {
        /**
         * IPv6 address
         */
        address: string;
        /**
         * Assignment mode
         */
        assignmentMode: string;
        /**
         * IPv6 gateway
         */
        gateway: string;
        /**
         * IPv6 subnet
         */
        prefix: string;
    }

    export interface GetSwitchRoutingInterfacesItemOspfSettings {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv4 area
         */
        isPassiveEnabled: boolean;
    }

    export interface GetSwitchRoutingInterfacesItemOspfV3 {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv6 area
         */
        isPassiveEnabled: boolean;
    }

    export interface GetSwitchRoutingStaticRoutesItem {
        /**
         * Option to advertise static routes via OSPF
         */
        advertiseViaOspfEnabled: boolean;
        /**
         * The name or description of the layer 3 static route
         */
        name: string;
        /**
         * The IP address of the router to which traffic for this destination network should be sent
         */
        nextHopIp: string;
        /**
         * Option to prefer static routes over OSPF routes
         */
        preferOverOspfRoutesEnabled: boolean;
        /**
         * The identifier of a layer 3 static route
         */
        staticRouteId: string;
        /**
         * The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)
         */
        subnet: string;
    }

    export interface GetSwitchWarmSpareItem {
        /**
         * Enable or disable warm spare for a switch
         */
        enabled: boolean;
        /**
         * Serial number of the primary switch
         */
        primarySerial: string;
        /**
         * Serial number of the warm spare switch
         */
        spareSerial: string;
    }

    export interface GetWirelessBluetoothSettingsItem {
        /**
         * Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
         */
        major: number;
        /**
         * Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
         */
        minor: number;
        /**
         * Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.
         */
        uuid: string;
    }

    export interface GetWirelessConnectionStatsItem {
        /**
         * The connection stats of the device
         */
        connectionStats: outputs.devices.GetWirelessConnectionStatsItemConnectionStats;
        /**
         * The serial number for the device
         */
        serial: string;
    }

    export interface GetWirelessConnectionStatsItemConnectionStats {
        /**
         * The number of failed association attempts
         */
        assoc: number;
        /**
         * The number of failed authentication attempts
         */
        auth: number;
        /**
         * The number of failed DHCP attempts
         */
        dhcp: number;
        /**
         * The number of failed DNS attempts
         */
        dns: number;
        /**
         * The number of successful connection attempts
         */
        success: number;
    }

    export interface GetWirelessLatencyStatsItem {
        latencyStats: outputs.devices.GetWirelessLatencyStatsItemLatencyStats;
        serial: string;
    }

    export interface GetWirelessLatencyStatsItemLatencyStats {
        backgroundTraffic: outputs.devices.GetWirelessLatencyStatsItemLatencyStatsBackgroundTraffic;
        bestEffortTraffic: string;
        videoTraffic: string;
        voiceTraffic: string;
    }

    export interface GetWirelessLatencyStatsItemLatencyStatsBackgroundTraffic {
        avg: number;
        rawDistribution: outputs.devices.GetWirelessLatencyStatsItemLatencyStatsBackgroundTrafficRawDistribution;
    }

    export interface GetWirelessLatencyStatsItemLatencyStatsBackgroundTrafficRawDistribution {
        status0: number;
        status1: number;
        status1024: number;
        status128: number;
        status16: number;
        status2: number;
        status2048: number;
        status256: number;
        status32: number;
        status4: number;
        status512: number;
        status64: number;
        status8: number;
    }

    export interface GetWirelessRadioSettingsItem {
        fiveGhzSettings: outputs.devices.GetWirelessRadioSettingsItemFiveGhzSettings;
        rfProfileId: string;
        serial: string;
        twoFourGhzSettings: outputs.devices.GetWirelessRadioSettingsItemTwoFourGhzSettings;
    }

    export interface GetWirelessRadioSettingsItemFiveGhzSettings {
        channel: number;
        channelWidth: string;
        targetPower: number;
    }

    export interface GetWirelessRadioSettingsItemTwoFourGhzSettings {
        channel: number;
        targetPower: number;
    }

    export interface GetWirelessStatusItem {
        /**
         * SSID status list
         */
        basicServiceSets: outputs.devices.GetWirelessStatusItemBasicServiceSet[];
    }

    export interface GetWirelessStatusItemBasicServiceSet {
        /**
         * Frequency range used by wireless network
         */
        band: string;
        /**
         * Whether the SSID is broadcasting based on an availability schedule
         */
        broadcasting: boolean;
        /**
         * Unique identifier of wireless access point
         */
        bssid: string;
        /**
         * Frequency channel used by wireless network
         */
        channel: number;
        /**
         * Width of frequency channel used by wireless network
         */
        channelWidth: string;
        /**
         * Status of wireless network
         */
        enabled: boolean;
        /**
         * Strength of wireless signal
         */
        power: string;
        /**
         * Name of wireless network
         */
        ssidName: string;
        /**
         * Unique identifier of wireless network
         */
        ssidNumber: number;
        /**
         * Whether the SSID is advertised or hidden
         */
        visible: boolean;
    }

    export interface LiveToolsArpTableCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer: outputs.devices.LiveToolsArpTableCallbackHttpServer;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.devices.LiveToolsArpTableCallbackPayloadTemplate;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret: string;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url: string;
    }

    export interface LiveToolsArpTableCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id: string;
    }

    export interface LiveToolsArpTableCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id: string;
    }

    export interface LiveToolsArpTableEntry {
        /**
         * The IP address of the ARP table entry
         */
        ip: string;
        /**
         * Time of the last update of the ARP table entry
         */
        lastUpdatedAt: string;
        /**
         * The MAC address of the ARP table entry
         */
        mac: string;
        /**
         * The VLAN ID of the ARP table entry
         */
        vlanId: number;
    }

    export interface LiveToolsArpTableRequest {
        /**
         * Device serial number
         */
        serial: string;
    }

    export interface LiveToolsCableCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer: outputs.devices.LiveToolsCableCallbackHttpServer;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.devices.LiveToolsCableCallbackPayloadTemplate;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret: string;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url: string;
    }

    export interface LiveToolsCableCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id: string;
    }

    export interface LiveToolsCableCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id: string;
    }

    export interface LiveToolsCableRequest {
        /**
         * A list of ports for which to perform the cable test.
         */
        ports: string[];
        /**
         * Device serial number
         */
        serial: string;
    }

    export interface LiveToolsCableResult {
        /**
         * If an error occurred during the cable test, the error message will be populated here.
         */
        error: string;
        /**
         * Results for each twisted pair within the cable.
         */
        pairs: outputs.devices.LiveToolsCableResultPair[];
        /**
         * The port for which the test was performed.
         */
        port: string;
        /**
         * Speed in Mbps.  A speed of 0 indicates the port is down or the port speed is automatic.
         */
        speedMbps: number;
        /**
         * The current status of the port. If the cable test is still being performed on the port, "in-progress" is used. If an error occurred during the cable test, "error" is used and the error property will be populated.
         */
        status: string;
    }

    export interface LiveToolsCableResultPair {
        /**
         * The index of the twisted pair tested.
         */
        index: number;
        /**
         * The detected length of the twisted pair.
         */
        lengthMeters: number;
        /**
         * The test result of the twisted pair tested.
         */
        status: string;
    }

    export interface LiveToolsPingDeviceItem {
        /**
         * Information for callback used to send back results
         */
        callback: outputs.devices.LiveToolsPingDeviceItemCallback;
        /**
         * Id to check the status of your ping request.
         */
        pingId: string;
        /**
         * Ping request parameters
         */
        request: outputs.devices.LiveToolsPingDeviceItemRequest;
        /**
         * Status of the ping request.
         */
        status: string;
        /**
         * GET this url to check the status of your ping request.
         */
        url: string;
    }

    export interface LiveToolsPingDeviceItemCallback {
        /**
         * The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
         */
        id: string;
        /**
         * The status of the callback
         */
        status: string;
        /**
         * The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
         */
        url: string;
    }

    export interface LiveToolsPingDeviceItemRequest {
        /**
         * Number of pings to send
         */
        count: number;
        /**
         * Device serial number
         */
        serial: string;
        /**
         * IP address or FQDN to ping
         */
        target: string;
    }

    export interface LiveToolsPingDeviceParameters {
        /**
         * Details for the callback. Please include either an httpServerId OR url and sharedSecret
         */
        callback: outputs.devices.LiveToolsPingDeviceParametersCallback;
        /**
         * Count parameter to pass to ping. [1..5], default 5
         */
        count: number;
    }

    export interface LiveToolsPingDeviceParametersCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer: outputs.devices.LiveToolsPingDeviceParametersCallbackHttpServer;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.devices.LiveToolsPingDeviceParametersCallbackPayloadTemplate;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret: string;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url: string;
    }

    export interface LiveToolsPingDeviceParametersCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id: string;
    }

    export interface LiveToolsPingDeviceParametersCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id: string;
    }

    export interface LiveToolsPingItem {
        /**
         * Information for callback used to send back results
         */
        callback: outputs.devices.LiveToolsPingItemCallback;
        /**
         * Id to check the status of your ping request.
         */
        pingId: string;
        /**
         * Ping request parameters
         */
        request: outputs.devices.LiveToolsPingItemRequest;
        /**
         * Status of the ping request.
         */
        status: string;
        /**
         * GET this url to check the status of your ping request.
         */
        url: string;
    }

    export interface LiveToolsPingItemCallback {
        /**
         * The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
         */
        id: string;
        /**
         * The status of the callback
         */
        status: string;
        /**
         * The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
         */
        url: string;
    }

    export interface LiveToolsPingItemRequest {
        /**
         * Number of pings to send
         */
        count: number;
        /**
         * Device serial number
         */
        serial: string;
        /**
         * IP address or FQDN to ping
         */
        target: string;
    }

    export interface LiveToolsPingParameters {
        /**
         * Details for the callback. Please include either an httpServerId OR url and sharedSecret
         */
        callback: outputs.devices.LiveToolsPingParametersCallback;
        /**
         * Count parameter to pass to ping. [1..5], default 5
         */
        count: number;
        /**
         * FQDN, IPv4 or IPv6 address
         */
        target: string;
    }

    export interface LiveToolsPingParametersCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer: outputs.devices.LiveToolsPingParametersCallbackHttpServer;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.devices.LiveToolsPingParametersCallbackPayloadTemplate;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret: string;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url: string;
    }

    export interface LiveToolsPingParametersCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id: string;
    }

    export interface LiveToolsPingParametersCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id: string;
    }

    export interface LiveToolsThroughputTestCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer: outputs.devices.LiveToolsThroughputTestCallbackHttpServer;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.devices.LiveToolsThroughputTestCallbackPayloadTemplate;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret: string;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url: string;
    }

    export interface LiveToolsThroughputTestCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id: string;
    }

    export interface LiveToolsThroughputTestCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id: string;
    }

    export interface LiveToolsThroughputTestRequest {
        /**
         * Device serial number
         */
        serial: string;
    }

    export interface LiveToolsThroughputTestResult {
        /**
         * Shows the speeds (Mbps)
         */
        speeds: outputs.devices.LiveToolsThroughputTestResultSpeeds;
    }

    export interface LiveToolsThroughputTestResultSpeeds {
        /**
         * Shows the download speed from shard (Mbps)
         */
        downstream: number;
    }

    export interface LiveToolsWakeOnLanCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer: outputs.devices.LiveToolsWakeOnLanCallbackHttpServer;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.devices.LiveToolsWakeOnLanCallbackPayloadTemplate;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret: string;
        /**
         * The callback URL for the webhook target. If using this field, please also specify a sharedSecret.
         */
        url: string;
    }

    export interface LiveToolsWakeOnLanCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id: string;
    }

    export interface LiveToolsWakeOnLanCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id: string;
    }

    export interface LiveToolsWakeOnLanRequest {
        /**
         * The target's MAC address
         */
        mac: string;
        /**
         * Device serial number
         */
        serial: string;
        /**
         * The target's VLAN (1 to 4094)
         */
        vlanId: number;
    }

    export interface ManagementInterfaceDdnsHostnames {
        /**
         * Active dynamic DNS hostname.
         */
        activeDdnsHostname: string;
        /**
         * WAN 1 dynamic DNS hostname.
         */
        ddnsHostnameWan1: string;
        /**
         * WAN 2 dynamic DNS hostname.
         */
        ddnsHostnameWan2: string;
    }

    export interface ManagementInterfaceWan1 {
        /**
         * Up to two DNS IPs.
         */
        staticDns: string[];
        /**
         * The IP of the gateway on the WAN.
         */
        staticGatewayIp: string;
        /**
         * The IP the device should use on the WAN.
         */
        staticIp: string;
        /**
         * The subnet mask for the WAN.
         */
        staticSubnetMask: string;
        /**
         * Configure the interface to have static IP settings or use DHCP.
         */
        usingStaticIp: boolean;
        /**
         * The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
         */
        vlan: number;
        /**
         * Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
         */
        wanEnabled: string;
    }

    export interface ManagementInterfaceWan2 {
        /**
         * Up to two DNS IPs.
         */
        staticDns: string[];
        /**
         * The IP of the gateway on the WAN.
         */
        staticGatewayIp: string;
        /**
         * The IP the device should use on the WAN.
         */
        staticIp: string;
        /**
         * The subnet mask for the WAN.
         */
        staticSubnetMask: string;
        /**
         * Configure the interface to have static IP settings or use DHCP.
         */
        usingStaticIp: boolean;
        /**
         * The VLAN that management traffic should be tagged with. Applies whether usingStaticIp is true or false.
         */
        vlan: number;
        /**
         * Enable or disable the interface (only for MX devices). Valid values are 'enabled', 'disabled', and 'not configured'.
         */
        wanEnabled: string;
    }

    export interface SensorRelationshipsLivestream {
        /**
         * An array of the related devices for the role
         */
        relatedDevices: outputs.devices.SensorRelationshipsLivestreamRelatedDevice[];
    }

    export interface SensorRelationshipsLivestreamRelatedDevice {
        /**
         * The product type of the related device
         */
        productType: string;
        /**
         * The serial of the related device
         */
        serial: string;
    }

    export interface SensorRelationshipsLivestreamRequest {
        /**
         * An array of the related devices for the role
         */
        relatedDevices: outputs.devices.SensorRelationshipsLivestreamRequestRelatedDevice[];
    }

    export interface SensorRelationshipsLivestreamRequestRelatedDevice {
        /**
         * The product type of the related device
         */
        productType: string;
        /**
         * The serial of the related device
         */
        serial: string;
    }

    export interface SwitchPortsCycleItem {
        /**
         * List of switch ports
         */
        ports: string[];
    }

    export interface SwitchPortsCycleParameters {
        /**
         * List of switch ports
         */
        ports: string[];
    }

    export interface SwitchPortsMirror {
        /**
         * The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
         */
        mode: string;
    }

    export interface SwitchPortsModule {
        /**
         * The model of the expansion module.
         */
        model: string;
    }

    export interface SwitchPortsProfile {
        /**
         * When enabled, override this port's configuration with a port profile.
         */
        enabled: boolean;
        /**
         * When enabled, the ID of the port profile used to override the port's configuration.
         */
        id: string;
        /**
         * When enabled, the IName of the profile.
         */
        iname: string;
    }

    export interface SwitchRoutingInterfacesDhcpDhcpOption {
        /**
         * The code for DHCP option which should be from 2 to 254
         */
        code: string;
        /**
         * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
         */
        type: string;
        /**
         * The value of the DHCP option
         */
        value: string;
    }

    export interface SwitchRoutingInterfacesDhcpFixedIpAssignment {
        /**
         * The IP address of the client which has fixed IP address assigned to it
         */
        ip: string;
        /**
         * The MAC address of the client which has fixed IP address
         */
        mac: string;
        /**
         * The name of the client which has fixed IP address
         */
        name: string;
    }

    export interface SwitchRoutingInterfacesDhcpReservedIpRange {
        /**
         * The comment for the reserved IP range
         */
        comment: string;
        /**
         * The ending IP address of the reserved IP range
         */
        end: string;
        /**
         * The starting IP address of the reserved IP range
         */
        start: string;
    }

    export interface SwitchRoutingInterfacesIpv6 {
        /**
         * IPv6 address
         */
        address: string;
        /**
         * Assignment mode
         */
        assignmentMode: string;
        /**
         * IPv6 gateway
         */
        gateway: string;
        /**
         * IPv6 subnet
         */
        prefix: string;
    }

    export interface SwitchRoutingInterfacesOspfSettings {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv4 area
         */
        isPassiveEnabled: boolean;
    }

    export interface SwitchRoutingInterfacesOspfV3 {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv6 area
         */
        isPassiveEnabled: boolean;
    }

    export interface WirelessAlternateManagementInterfaceIpv6Item {
        /**
         * configured alternate management interface addresses
         */
        addresses: outputs.devices.WirelessAlternateManagementInterfaceIpv6ItemAddress[];
    }

    export interface WirelessAlternateManagementInterfaceIpv6ItemAddress {
        /**
         * The IP address configured for the alternate management interface
         */
        address: string;
        /**
         * The type of address assignment. Either static or dynamic.
         */
        assignmentMode: string;
        /**
         * The gateway address configured for the alternate managment interface
         */
        gateway: string;
        /**
         * The DNS servers settings for this address.
         */
        nameservers: outputs.devices.WirelessAlternateManagementInterfaceIpv6ItemAddressNameservers;
        /**
         * The IPv6 prefix of the interface. Required if IPv6 object is included.
         */
        prefix: string;
        /**
         * The IP protocol used for the address
         */
        protocol: string;
    }

    export interface WirelessAlternateManagementInterfaceIpv6ItemAddressNameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface WirelessAlternateManagementInterfaceIpv6Parameters {
        /**
         * configured alternate management interface addresses
         */
        addresses: outputs.devices.WirelessAlternateManagementInterfaceIpv6ParametersAddress[];
    }

    export interface WirelessAlternateManagementInterfaceIpv6ParametersAddress {
        /**
         * The IP address configured for the alternate management interface
         */
        address: string;
        /**
         * The type of address assignment. Either static or dynamic.
         */
        assignmentMode: string;
        /**
         * The gateway address configured for the alternate managment interface
         */
        gateway: string;
        /**
         * The DNS servers settings for this address.
         */
        nameservers: outputs.devices.WirelessAlternateManagementInterfaceIpv6ParametersAddressNameservers;
        /**
         * The IPv6 prefix length of the IPv6 interface. Required if IPv6 object is included.
         */
        prefix: string;
        /**
         * The IP protocol used for the address
         */
        protocol: string;
    }

    export interface WirelessAlternateManagementInterfaceIpv6ParametersAddressNameservers {
        /**
         * Up to 2 nameserver addresses to use, ordered in priority from highest to lowest priority.
         */
        addresses: string[];
    }

    export interface WirelessRadioSettingsFiveGhzSettings {
        /**
         * Sets a manual channel for 5 GHz. Can be '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161', '165', '169', '173' or '177' or null for using auto channel.
         */
        channel: number;
        /**
         * Sets a manual channel for 5 GHz. Can be '0', '20', '40', '80' or '160' or null for using auto channel width.
         */
        channelWidth: string;
        /**
         * Set a manual target power for 5 GHz. Can be between '8' or '30' or null for using auto power range.
         */
        targetPower: number;
    }

    export interface WirelessRadioSettingsTwoFourGhzSettings {
        /**
         * Sets a manual channel for 2.4 GHz. Can be '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13' or '14' or null for using auto channel.
         */
        channel: number;
        /**
         * Set a manual target power for 2.4 GHz. Can be between '5' or '30' or null for using auto power range.
         */
        targetPower: number;
    }

}

export namespace networks {
    export interface AlertsSettingsAlert {
        /**
         * A hash of destinations for this specific alert
         */
        alertDestinations?: outputs.networks.AlertsSettingsAlertAlertDestinations;
        /**
         * A boolean depicting if the alert is turned on or off
         */
        enabled?: boolean;
        /**
         * A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
         */
        filters?: outputs.networks.AlertsSettingsAlertFilters;
        /**
         * The type of alert
         */
        type?: string;
    }

    export interface AlertsSettingsAlertAlertDestinations {
        /**
         * If true, then all network admins will receive emails for this alert
         */
        allAdmins?: boolean;
        /**
         * A list of emails that will receive information about the alert
         */
        emails?: string[];
        /**
         * A list of HTTP server IDs to send a Webhook to for this alert
         */
        httpServerIds?: string[];
        /**
         * If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
         */
        snmp?: boolean;
    }

    export interface AlertsSettingsAlertFilters {
        period?: number;
        threshold?: number;
        timeout?: number;
    }

    export interface AlertsSettingsAlertsResponse {
        /**
         * A hash of destinations for this specific alert
         */
        alertDestinations: outputs.networks.AlertsSettingsAlertsResponseAlertDestinations;
        /**
         * A boolean depicting if the alert is turned on or off
         */
        enabled: boolean;
        /**
         * A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.
         */
        filters: outputs.networks.AlertsSettingsAlertsResponseFilters;
        /**
         * The type of alert
         */
        type: string;
    }

    export interface AlertsSettingsAlertsResponseAlertDestinations {
        /**
         * If true, then all network admins will receive emails for this alert
         */
        allAdmins: boolean;
        /**
         * A list of emails that will receive information about the alert
         */
        emails: string[];
        /**
         * A list of HTTP server IDs to send a Webhook to for this alert
         */
        httpServerIds: string[];
        /**
         * If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network
         */
        snmp: boolean;
    }

    export interface AlertsSettingsAlertsResponseFilters {
        period: number;
        threshold: number;
        timeout: number;
    }

    export interface AlertsSettingsDefaultDestinations {
        /**
         * If true, then all network admins will receive emails.
         */
        allAdmins: boolean;
        /**
         * A list of emails that will receive the alert(s).
         */
        emails: string[];
        /**
         * A list of HTTP server IDs to send a Webhook to
         */
        httpServerIds: string[];
        /**
         * If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.
         */
        snmp: boolean;
    }

    export interface AlertsSettingsMuting {
        /**
         * by_port_schedules
         */
        byPortSchedules: outputs.networks.AlertsSettingsMutingByPortSchedules;
    }

    export interface AlertsSettingsMutingByPortSchedules {
        /**
         * enabled
         */
        enabled: boolean;
    }

    export interface ApplianceConnectivityMonitoringDestinationsDestination {
        /**
         * Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
         */
        default: boolean;
        /**
         * Description of the testing destination. Optional, defaults to null
         */
        description: string;
        /**
         * The IP address to test connectivity with
         */
        ip: string;
    }

    export interface ApplianceContentFilteringBlockedUrlCategoriesResponse {
        id: string;
        name: string;
    }

    export interface ApplianceFirewallCellularFirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled: boolean;
    }

    export interface ApplianceFirewallInboundFirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment?: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: boolean;
    }

    export interface ApplianceFirewallInboundFirewallRulesRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled: boolean;
    }

    export interface ApplianceFirewallL3FirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment?: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr?: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort?: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy?: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol?: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr?: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort?: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled?: boolean;
    }

    export interface ApplianceFirewallL3FirewallRulesRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled: boolean;
    }

    export interface ApplianceFirewallL7FirewallRulesRule {
        /**
         * 'Deny' traffic specified by this rule
         */
        policy?: string;
        /**
         * Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
         */
        type?: string;
        /**
         * The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. Send a string to request.
         */
        value?: string;
        /**
         * The 'value_list' of what you want to block. Send a lis of string in request.
         */
        valueLists?: string[];
        /**
         * The 'value_obj' of what you want to block. Send a dict in request.
         */
        valueObj?: outputs.networks.ApplianceFirewallL7FirewallRulesRuleValueObj;
    }

    export interface ApplianceFirewallL7FirewallRulesRuleValueObj {
        id?: string;
        name?: string;
    }

    export interface ApplianceFirewallL7FirewallRulesRulesResponse {
        /**
         * 'Deny' traffic specified by this rule
         */
        policy: string;
        /**
         * Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
         */
        type: string;
        /**
         * The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.
         */
        value: string;
        /**
         * The 'value_list' of what you want to block. Send a list in request
         */
        valueLists: string[];
        /**
         * The 'value_obj' of what you want to block. Send a dict in request
         */
        valueObj: outputs.networks.ApplianceFirewallL7FirewallRulesRulesResponseValueObj;
    }

    export interface ApplianceFirewallL7FirewallRulesRulesResponseValueObj {
        id: string;
        name: string;
    }

    export interface ApplianceFirewallOneToManyNatRulesRule {
        /**
         * An array of associated forwarding rules
         */
        portRules: outputs.networks.ApplianceFirewallOneToManyNatRulesRulePortRule[];
        /**
         * The IP address that will be used to access the internal resource from the WAN
         */
        publicIp: string;
        /**
         * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
         */
        uplink: string;
    }

    export interface ApplianceFirewallOneToManyNatRulesRulePortRule {
        /**
         * Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'
         */
        allowedIps: string[];
        /**
         * Local IP address to which traffic will be forwarded
         */
        localIp: string;
        /**
         * Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port
         */
        localPort: string;
        /**
         * A description of the rule
         */
        name: string;
        /**
         * 'tcp' or 'udp'
         */
        protocol: string;
        /**
         * Destination port of the traffic that is arriving on the WAN
         */
        publicPort: string;
    }

    export interface ApplianceFirewallOneToOneNatRulesRule {
        /**
         * The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource
         */
        allowedInbounds: outputs.networks.ApplianceFirewallOneToOneNatRulesRuleAllowedInbound[];
        /**
         * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
         */
        lanIp: string;
        /**
         * A descriptive name for the rule
         */
        name: string;
        /**
         * The IP address that will be used to access the internal resource from the WAN
         */
        publicIp: string;
        /**
         * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')
         */
        uplink: string;
    }

    export interface ApplianceFirewallOneToOneNatRulesRuleAllowedInbound {
        /**
         * An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'
         */
        allowedIps: string[];
        /**
         * An array of ports or port ranges that will be forwarded to the host on the LAN
         */
        destinationPorts: string[];
        /**
         * Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'
         */
        protocol: string;
    }

    export interface ApplianceFirewallPortForwardingRulesRule {
        /**
         * An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)
         */
        allowedIps: string[];
        /**
         * The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN
         */
        lanIp: string;
        /**
         * A port or port ranges that will receive the forwarded traffic from the WAN
         */
        localPort: string;
        /**
         * A descriptive name for the rule
         */
        name: string;
        /**
         * TCP or UDP
         */
        protocol: string;
        /**
         * A port or port ranges that will be forwarded to the host on the LAN
         */
        publicPort: string;
        /**
         * The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')
         */
        uplink: string;
    }

    export interface ApplianceFirewallSettingsSpoofingProtection {
        /**
         * IP source address spoofing settings
         */
        ipSourceGuard: outputs.networks.ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard;
    }

    export interface ApplianceFirewallSettingsSpoofingProtectionIpSourceGuard {
        /**
         * Mode of protection
         */
        mode: string;
    }

    export interface AppliancePrefixesDelegatedStaticsOrigin {
        /**
         * Uplink provided or independent
         */
        interfaces: string[];
        /**
         * Origin type
         */
        type: string;
    }

    export interface ApplianceRfProfilesFiveGhzSettings {
        /**
         * Whether ax radio on 5Ghz band is on or off.
         */
        axEnabled: boolean;
        /**
         * Min bitrate (Mbps) of 2.4Ghz band.
         */
        minBitrate: number;
    }

    export interface ApplianceRfProfilesPerSsidSettings {
        /**
         * Settings for SSID 1.
         */
        status1: outputs.networks.ApplianceRfProfilesPerSsidSettingsStatus1;
        /**
         * Settings for SSID 2.
         */
        status2: outputs.networks.ApplianceRfProfilesPerSsidSettingsStatus2;
        /**
         * Settings for SSID 3.
         */
        status3: outputs.networks.ApplianceRfProfilesPerSsidSettingsStatus3;
        /**
         * Settings for SSID 4.
         */
        status4: outputs.networks.ApplianceRfProfilesPerSsidSettingsStatus4;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus1 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus2 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus3 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface ApplianceRfProfilesPerSsidSettingsStatus4 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface ApplianceRfProfilesTwoFourGhzSettings {
        /**
         * Whether ax radio on 2.4Ghz band is on or off.
         */
        axEnabled: boolean;
        /**
         * Min bitrate (Mbps) of 2.4Ghz band.
         */
        minBitrate: number;
    }

    export interface ApplianceSecurityIntrusionProtectedNetworks {
        /**
         * List of IP addresses or subnets being excluded from protection
         */
        excludedCidrs: string[];
        /**
         * List of IP addresses or subnets being protected
         */
        includedCidrs: string[];
        /**
         * Whether special IPv4 addresses should be used (see: [https://tools.ietf.org/html/rfc5735](https://tools.ietf.org/html/rfc5735))
         */
        useDefault: boolean;
    }

    export interface ApplianceSecurityMalwareAllowedFile {
        /**
         * Comment about the allowed file
         */
        comment: string;
        /**
         * The sha256 digest of allowed file
         */
        sha256: string;
    }

    export interface ApplianceSecurityMalwareAllowedUrl {
        /**
         * Comment about the allowed URL
         */
        comment: string;
        /**
         * The allowed URL
         */
        url: string;
    }

    export interface ApplianceSettingsDynamicDns {
        /**
         * Dynamic DNS enabled
         */
        enabled: boolean;
        /**
         * Dynamic DNS url prefix. DDNS must be enabled to update
         */
        prefix: string;
        /**
         * Dynamic DNS url. DDNS must be enabled to update
         */
        url: string;
    }

    export interface ApplianceSingleLanIpv6 {
        /**
         * Enable IPv6 on single LAN
         */
        enabled: boolean;
        /**
         * Prefix assignments on the single LAN
         */
        prefixAssignments: outputs.networks.ApplianceSingleLanIpv6PrefixAssignment[];
    }

    export interface ApplianceSingleLanIpv6PrefixAssignment {
        /**
         * Auto assign a /64 prefix from the origin to the single LAN
         */
        autonomous: boolean;
        /**
         * The origin of the prefix
         */
        origin: outputs.networks.ApplianceSingleLanIpv6PrefixAssignmentOrigin;
        /**
         * Manual configuration of the IPv6 Appliance IP
         */
        staticApplianceIp6: string;
        /**
         * Manual configuration of a /64 prefix on the single LAN
         */
        staticPrefix: string;
    }

    export interface ApplianceSingleLanIpv6PrefixAssignmentOrigin {
        /**
         * Interfaces associated with the prefix
         */
        interfaces: string[];
        /**
         * Type of the origin
         */
        type: string;
    }

    export interface ApplianceSingleLanMandatoryDhcp {
        /**
         * Enable Mandatory DHCP on single LAN.
         */
        enabled: boolean;
    }

    export interface ApplianceSsidsDhcpEnforcedDeauthentication {
        /**
         * Enable DCHP Enforced Deauthentication on the SSID.
         */
        enabled: boolean;
    }

    export interface ApplianceSsidsDot11w {
        /**
         * Whether 802.11w is enabled or not.
         */
        enabled: boolean;
        /**
         * (Optional) Whether 802.11w is required or not.
         */
        required: boolean;
    }

    export interface ApplianceSsidsRadiusServer {
        /**
         * The IP address of your RADIUS server.
         */
        host: string;
        /**
         * The UDP port your RADIUS servers listens on for Access-requests.
         */
        port: number;
        /**
         * The RADIUS client shared secret.
         */
        secret: string;
    }

    export interface ApplianceSsidsRadiusServersResponse {
        /**
         * The IP address of your RADIUS server.
         */
        host: string;
        /**
         * The UDP port your RADIUS servers listens on for Access-requests.
         */
        port: number;
        /**
         * The RADIUS client shared secret.
         */
        secret: string;
    }

    export interface ApplianceTrafficShapingCustomPerformanceClassesParameters {
        /**
         * Maximum jitter in milliseconds
         */
        maxJitter: number;
        /**
         * Maximum latency in milliseconds
         */
        maxLatency: number;
        /**
         * Maximum percentage of packet loss
         */
        maxLossPercentage: number;
        /**
         * Name of the custom performance class
         */
        name: string;
    }

    export interface ApplianceTrafficShapingGlobalBandwidthLimits {
        /**
         * The download bandwidth limit in Kbps. (0 represents no limit.)
         */
        limitDown: number;
        /**
         * The upload bandwidth limit in Kbps. (0 represents no limit.)
         */
        limitUp: number;
    }

    export interface ApplianceTrafficShapingRulesRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions: outputs.networks.ApplianceTrafficShapingRulesRuleDefinition[];
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue: number;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits: outputs.networks.ApplianceTrafficShapingRulesRulePerClientBandwidthLimits;
        /**
         * A string, indicating the priority level for packets bound to your rule.
         * Can be 'low', 'normal' or 'high'.
         */
        priority: string;
    }

    export interface ApplianceTrafficShapingRulesRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type: string;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         * custom ports.
         * If "type" is 'application' or 'applicationCategory', then "value" must be an object
         * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         * endpoint).
         */
        value: string;
        /**
         * The 'value_list' of what you want to block. Send a list in request
         */
        valueLists: string[];
        /**
         * The 'value_obj' of what you want to block. Send a dict in request
         */
        valueObj: outputs.networks.ApplianceTrafficShapingRulesRuleDefinitionValueObj;
    }

    export interface ApplianceTrafficShapingRulesRuleDefinitionValueObj {
        id: string;
        name: string;
    }

    export interface ApplianceTrafficShapingRulesRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits: outputs.networks.ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface ApplianceTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp: number;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimits {
        /**
         * uplink cellular configured limits [optional]
         */
        cellular: outputs.networks.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular;
        /**
         * uplink wan1 configured limits [optional]
         */
        wan1: outputs.networks.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1;
        /**
         * uplink wan2 configured limits [optional]
         */
        wan2: outputs.networks.ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsCellular {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown: number;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp: number;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan1 {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown: number;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp: number;
    }

    export interface ApplianceTrafficShapingUplinkBandwidthBandwidthLimitsWan2 {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown: number;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp: number;
    }

    export interface ApplianceTrafficShapingUplinkSelectionFailoverAndFailback {
        /**
         * Immediate WAN failover and failback
         */
        immediate: outputs.networks.ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate;
    }

    export interface ApplianceTrafficShapingUplinkSelectionFailoverAndFailbackImmediate {
        /**
         * Whether immediate WAN failover and failback is enabled
         */
        enabled: boolean;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreference {
        /**
         * Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
         */
        failOverCriterion: string;
        /**
         * Performance class setting for uplink preference rule
         */
        performanceClass: outputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass;
        /**
         * Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
         */
        preferredUplink: string;
        /**
         * Traffic filters
         */
        trafficFilters: outputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter[];
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferencePerformanceClass {
        /**
         * Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
         */
        builtinPerformanceClassName: string;
        /**
         * ID of created custom performance class, must be present when performanceClass type is "custom"
         */
        customPerformanceClassId: string;
        /**
         * Type of this performance class. Must be one of: 'builtin' or 'custom'
         */
        type: string;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilter {
        /**
         * Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
         */
        type: string;
        /**
         * Value of traffic filter
         */
        value: outputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValue {
        /**
         * Destination of 'custom' type traffic filter
         */
        destination: outputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination;
        /**
         * ID of 'applicationCategory' or 'application' type traffic filter
         */
        id: string;
        /**
         * Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
         */
        protocol: string;
        /**
         * Source of 'custom' type traffic filter
         */
        source: outputs.networks.ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueDestination {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
         */
        cidr: string;
        /**
         * FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
         */
        fqdn: string;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host: number;
        /**
         * Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
         */
        network: string;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
         */
        vlan: number;
    }

    export interface ApplianceTrafficShapingUplinkSelectionVpnTrafficUplinkPreferenceTrafficFilterValueSource {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
         */
        cidr: string;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host: number;
        /**
         * Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
         */
        network: string;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
         */
        vlan: number;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreference {
        /**
         * Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
         */
        preferredUplink: string;
        /**
         * Traffic filters
         */
        trafficFilters: outputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter[];
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilter {
        /**
         * Traffic filter type. Must be "custom"
         */
        type: string;
        /**
         * Value of traffic filter
         */
        value: outputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValue {
        /**
         * Destination of 'custom' type traffic filter
         */
        destination: outputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination;
        /**
         * Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
         */
        protocol: string;
        /**
         * Source of 'custom' type traffic filter
         */
        source: outputs.networks.ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueDestination {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
         */
        cidr: string;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
    }

    export interface ApplianceTrafficShapingUplinkSelectionWanTrafficUplinkPreferenceTrafficFilterValueSource {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
         */
        cidr: string;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host: number;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
         */
        vlan: number;
    }

    export interface ApplianceTrafficShapingVpnExclusionsItem {
        /**
         * Custom VPN exclusion rules.
         */
        customs: outputs.networks.ApplianceTrafficShapingVpnExclusionsItemCustom[];
        /**
         * Major Application based VPN exclusion rules.
         */
        majorApplications: outputs.networks.ApplianceTrafficShapingVpnExclusionsItemMajorApplication[];
        /**
         * ID of the network whose VPN exclusion rules are returned.
         */
        networkId: string;
        /**
         * Name of the network whose VPN exclusion rules are returned.
         */
        networkName: string;
    }

    export interface ApplianceTrafficShapingVpnExclusionsItemCustom {
        /**
         * Destination address; hostname required for DNS, IPv4 otherwise.
         */
        destination: string;
        /**
         * Destination port.
         */
        port: string;
        /**
         * Protocol.
         */
        protocol: string;
    }

    export interface ApplianceTrafficShapingVpnExclusionsItemMajorApplication {
        /**
         * Application's Meraki ID.
         */
        id: string;
        /**
         * Application's name.
         */
        name: string;
    }

    export interface ApplianceTrafficShapingVpnExclusionsParameters {
        /**
         * Custom VPN exclusion rules. Pass an empty array to clear existing rules.
         */
        customs: outputs.networks.ApplianceTrafficShapingVpnExclusionsParametersCustom[];
        /**
         * Major Application based VPN exclusion rules. Pass an empty array to clear existing rules.
         */
        majorApplications: outputs.networks.ApplianceTrafficShapingVpnExclusionsParametersMajorApplication[];
    }

    export interface ApplianceTrafficShapingVpnExclusionsParametersCustom {
        /**
         * Destination address; hostname required for DNS, IPv4 otherwise.
         */
        destination: string;
        /**
         * Destination port.
         */
        port: string;
        /**
         * Protocol.
         */
        protocol: string;
    }

    export interface ApplianceTrafficShapingVpnExclusionsParametersMajorApplication {
        /**
         * Application's Meraki ID.
         */
        id: string;
        /**
         * Application's name.
         */
        name: string;
    }

    export interface ApplianceVlansDhcpOption {
        /**
         * The code for the DHCP option. This should be an integer between 2 and 254.
         */
        code: string;
        /**
         * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
         */
        type: string;
        /**
         * The value for the DHCP option
         */
        value: string;
    }

    export interface ApplianceVlansIpv6 {
        /**
         * Enable IPv6 on VLAN
         */
        enabled: boolean;
        /**
         * Prefix assignments on the VLAN
         */
        prefixAssignments: outputs.networks.ApplianceVlansIpv6PrefixAssignment[];
    }

    export interface ApplianceVlansIpv6PrefixAssignment {
        /**
         * Auto assign a /64 prefix from the origin to the VLAN
         */
        autonomous: boolean;
        /**
         * The origin of the prefix
         */
        origin: outputs.networks.ApplianceVlansIpv6PrefixAssignmentOrigin;
        /**
         * Manual configuration of the IPv6 Appliance IP
         */
        staticApplianceIp6: string;
        /**
         * Manual configuration of a /64 prefix on the VLAN
         */
        staticPrefix: string;
    }

    export interface ApplianceVlansIpv6PrefixAssignmentOrigin {
        /**
         * Interfaces associated with the prefix
         */
        interfaces: string[];
        /**
         * Type of the origin
         */
        type: string;
    }

    export interface ApplianceVlansMandatoryDhcp {
        /**
         * Enable Mandatory DHCP on VLAN.
         */
        enabled: boolean;
    }

    export interface ApplianceVlansReservedIpRange {
        /**
         * A text comment for the reserved range
         */
        comment?: string;
        /**
         * The last IP in the reserved range
         */
        end: string;
        /**
         * The first IP in the reserved range
         */
        start: string;
    }

    export interface ApplianceVpnBgpNeighbor {
        /**
         * When this feature is on, the Meraki device will advertise routes learned from other Autonomous Systems, thereby allowing traffic between Autonomous Systems to transit this AS. When absent, it defaults to false.
         */
        allowTransit: boolean;
        /**
         * Authentication settings between BGP peers.
         */
        authentication: outputs.networks.ApplianceVpnBgpNeighborAuthentication;
        /**
         * The eBGP hold timer in seconds for each neighbor. The eBGP hold timer must be an integer between 12 and 240.
         */
        ebgpHoldTimer: number;
        /**
         * Configure this if the neighbor is not adjacent. The eBGP multi-hop must be an integer between 1 and 255.
         */
        ebgpMultihop: number;
        /**
         * The IPv4 address of the neighbor
         */
        ip: string;
        /**
         * Information regarding IPv6 address of the neighbor, Required if *ip* is not present.
         */
        ipv6: outputs.networks.ApplianceVpnBgpNeighborIpv6;
        /**
         * The IPv4 address of the remote BGP peer that will establish a TCP session with the local MX.
         */
        nextHopIp: string;
        /**
         * The receive limit is the maximum number of routes that can be received from any BGP peer. The receive limit must be an integer between 0 and 4294967295. When absent, it defaults to 0.
         */
        receiveLimit: number;
        /**
         * Remote ASN of the neighbor. The remote ASN must be an integer between 1 and 4294967295.
         */
        remoteAsNumber: number;
        /**
         * The output interface for peering with the remote BGP peer. Valid values are: 'wan1', 'wan2' or 'vlan{VLAN ID}'(e.g. 'vlan123').
         */
        sourceInterface: string;
        /**
         * Settings for BGP TTL security to protect BGP peering sessions from forged IP attacks.
         */
        ttlSecurity: outputs.networks.ApplianceVpnBgpNeighborTtlSecurity;
    }

    export interface ApplianceVpnBgpNeighborAuthentication {
        /**
         * Password to configure MD5 authentication between BGP peers.
         */
        password: string;
    }

    export interface ApplianceVpnBgpNeighborIpv6 {
        /**
         * The IPv6 address of the neighbor.
         */
        address: string;
    }

    export interface ApplianceVpnBgpNeighborTtlSecurity {
        /**
         * Boolean value to enable or disable BGP TTL security.
         */
        enabled: boolean;
    }

    export interface ApplianceVpnSiteToSiteVpnHub {
        /**
         * The network ID of the hub.
         */
        hubId: string;
        /**
         * Indicates whether default route traffic should be sent to this hub.
         */
        useDefaultRoute: boolean;
    }

    export interface ApplianceVpnSiteToSiteVpnSubnet {
        /**
         * The CIDR notation subnet used within the VPN
         */
        localSubnet: string;
        /**
         * Indicates the presence of the subnet in the VPN
         */
        useVpn: boolean;
    }

    export interface ApplianceWarmSpareWan1 {
        ip: string;
        subnet: string;
    }

    export interface ApplianceWarmSpareWan2 {
        ip: string;
        subnet: string;
    }

    export interface BindItem {
        /**
         * ID of the config template the network is being bound to
         */
        configTemplateId: string;
        /**
         * Enrollment string for the network
         */
        enrollmentString: string;
        /**
         * Network ID
         */
        id: string;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate: boolean;
        /**
         * Network name
         */
        name: string;
        /**
         * Notes for the network
         */
        notes: string;
        /**
         * Organization ID
         */
        organizationId: string;
        /**
         * List of the product types that the network supports
         */
        productTypes: string[];
        /**
         * Network tags
         */
        tags: string[];
        /**
         * Timezone of the network
         */
        timeZone: string;
        /**
         * URL to the network Dashboard UI
         */
        url: string;
    }

    export interface BindParameters {
        /**
         * Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.
         */
        autoBind: boolean;
        /**
         * The ID of the template to which the network should be bound.
         */
        configTemplateId: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettings {
        /**
         * Quality and resolution for MV12/MV22/MV72 camera models.
         */
        mV12MV22MV72: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72;
        /**
         * Quality and resolution for MV12WE camera models.
         */
        mV12We: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV12We;
        /**
         * Quality and resolution for MV13 camera models.
         */
        mV13: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV13;
        /**
         * Quality and resolution for MV21/MV71 camera models.
         */
        mV21MV71: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV21MV71;
        /**
         * Quality and resolution for MV22X/MV72X camera models.
         */
        mV22Xmv72X: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X;
        /**
         * Quality and resolution for MV32 camera models.
         */
        mV32: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV32;
        /**
         * Quality and resolution for MV33 camera models.
         */
        mV33: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV33;
        /**
         * Quality and resolution for MV52 camera models.
         */
        mV52: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV52;
        /**
         * Quality and resolution for MV63 camera models.
         */
        mV63: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV63;
        /**
         * Quality and resolution for MV63X camera models.
         */
        mV63X: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV63X;
        /**
         * Quality and resolution for MV93 camera models.
         */
        mV93: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV93;
        /**
         * Quality and resolution for MV93X camera models.
         */
        mV93X: outputs.networks.CameraQualityRetentionProfilesVideoSettingsMV93X;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV12MV22MV72 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV12We {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1280x720' or '1920x1080'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV13 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV21MV71 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1280x720'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV22Xmv72X {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV32 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV33 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV52 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV63 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV63X {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV93 {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.
         */
        resolution: string;
    }

    export interface CameraQualityRetentionProfilesVideoSettingsMV93X {
        /**
         * Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.
         */
        quality: string;
        /**
         * Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.
         */
        resolution: string;
    }

    export interface CameraWirelessProfilesIdentity {
        /**
         * The password of the identity.
         */
        password: string;
        /**
         * The username of the identity.
         */
        username: string;
    }

    export interface CameraWirelessProfilesSsid {
        /**
         * The auth mode of the SSID. It can be set to ('psk', '8021x-radius').
         */
        authMode: string;
        /**
         * The encryption mode of the SSID. It can be set to ('wpa', 'wpa-eap'). With 'wpa' mode, the authMode should be 'psk' and with 'wpa-eap' the authMode should be '8021x-radius'
         */
        encryptionMode: string;
        /**
         * The name of the SSID.
         */
        name: string;
        /**
         * The pre-shared key of the SSID.
         */
        psk: string;
    }

    export interface CellularGatewayConnectivityMonitoringDestinationsDestination {
        /**
         * Boolean indicating whether this is the default testing destination (true) or not (false). Defaults to false. Only one default is allowed
         */
        default: boolean;
        /**
         * Description of the testing destination. Optional, defaults to an empty string
         */
        description: string;
        /**
         * The IP address to test connectivity with
         */
        ip: string;
    }

    export interface CellularGatewaySubnetPoolSubnet {
        applianceIp: string;
        name: string;
        serial: string;
        subnet: string;
    }

    export interface CellularGatewayUplinkBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps). 'null' indicates no limit.
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
         */
        limitUp: number;
    }

    export interface ClientsProvisionItem {
        /**
         * The list of clients to provision
         */
        clients: outputs.networks.ClientsProvisionItemClient[];
        /**
         * The name of the client's policy
         */
        devicePolicy: string;
        /**
         * The group policy identifier of the client
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionItemClient {
        /**
         * The identifier of the client
         */
        clientId: string;
        /**
         * The MAC address of the client
         */
        mac: string;
        /**
         * The client's display message if its group policy is 'Blocked'
         */
        message: string;
        /**
         * The name of the client
         */
        name: string;
    }

    export interface ClientsProvisionParameters {
        /**
         * The array of clients to provision
         */
        clients: outputs.networks.ClientsProvisionParametersClient[];
        /**
         * The policy to apply to the specified client. Can be 'Group policy', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
        /**
         * An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)
         */
        policiesBySecurityAppliance: outputs.networks.ClientsProvisionParametersPoliciesBySecurityAppliance;
        /**
         * An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy
         */
        policiesBySsid: outputs.networks.ClientsProvisionParametersPoliciesBySsid;
    }

    export interface ClientsProvisionParametersClient {
        /**
         * The MAC address of the client. Required.
         */
        mac: string;
        /**
         * The display name for the client. Optional. Limited to 255 bytes.
         */
        name: string;
    }

    export interface ClientsProvisionParametersPoliciesBySecurityAppliance {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked' or 'Normal'. Required.
         */
        devicePolicy: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsid {
        /**
         * The number for the SSID
         */
        status0: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus0;
        /**
         * The number for the SSID
         */
        status1: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus1;
        /**
         * The number for the SSID
         */
        status10: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus10;
        /**
         * The number for the SSID
         */
        status11: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus11;
        /**
         * The number for the SSID
         */
        status12: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus12;
        /**
         * The number for the SSID
         */
        status13: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus13;
        /**
         * The number for the SSID
         */
        status14: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus14;
        /**
         * The number for the SSID
         */
        status2: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus2;
        /**
         * The number for the SSID
         */
        status3: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus3;
        /**
         * The number for the SSID
         */
        status4: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus4;
        /**
         * The number for the SSID
         */
        status5: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus5;
        /**
         * The number for the SSID
         */
        status6: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus6;
        /**
         * The number for the SSID
         */
        status7: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus7;
        /**
         * The number for the SSID
         */
        status8: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus8;
        /**
         * The number for the SSID
         */
        status9: outputs.networks.ClientsProvisionParametersPoliciesBySsidStatus9;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus0 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus1 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus10 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus11 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus12 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus13 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus14 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus2 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus3 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus4 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus5 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus6 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus7 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus8 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsProvisionParametersPoliciesBySsidStatus9 {
        /**
         * The policy to apply to the specified client. Can be 'Allowed', 'Blocked', 'Normal' or 'Group policy'. Required.
         */
        devicePolicy: string;
        /**
         * The ID of the desired group policy to apply to the client. Required if 'devicePolicy' is set to "Group policy". Otherwise this is ignored.
         */
        groupPolicyId: string;
    }

    export interface ClientsSplashAuthorizationStatusSsids {
        /**
         * Splash authorization for SSID 0
         */
        status0: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus0;
        /**
         * Splash authorization for SSID 1
         */
        status1: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus1;
        /**
         * Splash authorization for SSID 10
         */
        status10: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus10;
        /**
         * Splash authorization for SSID 11
         */
        status11: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus11;
        /**
         * Splash authorization for SSID 12
         */
        status12: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus12;
        /**
         * Splash authorization for SSID 13
         */
        status13: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus13;
        /**
         * Splash authorization for SSID 14
         */
        status14: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus14;
        /**
         * Splash authorization for SSID 2
         */
        status2: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus2;
        /**
         * Splash authorization for SSID 3
         */
        status3: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus3;
        /**
         * Splash authorization for SSID 4
         */
        status4: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus4;
        /**
         * Splash authorization for SSID 5
         */
        status5: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus5;
        /**
         * Splash authorization for SSID 6
         */
        status6: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus6;
        /**
         * Splash authorization for SSID 7
         */
        status7: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus7;
        /**
         * Splash authorization for SSID 8
         */
        status8: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus8;
        /**
         * Splash authorization for SSID 9
         */
        status9: outputs.networks.ClientsSplashAuthorizationStatusSsidsStatus9;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus0 {
        authorizedAt: string;
        expiresAt: string;
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus1 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus10 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus11 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus12 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus13 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus14 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus2 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus3 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus4 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus5 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus6 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus7 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus8 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface ClientsSplashAuthorizationStatusSsidsStatus9 {
        /**
         * New authorization status for the SSID (true, false).
         */
        isAuthorized: boolean;
    }

    export interface DevicesClaimItem {
        /**
         * The serials of the devices
         */
        serials: string[];
    }

    export interface DevicesClaimParameters {
        /**
         * A list of serials of devices to claim
         */
        serials: string[];
    }

    export interface DevicesClaimVmxItem {
        /**
         * Physical address of the device
         */
        address: string;
        /**
         * Additional device information
         */
        details: outputs.networks.DevicesClaimVmxItemDetail[];
        /**
         * Firmware version of the device
         */
        firmware: string;
        /**
         * IMEI of the device, if applicable
         */
        imei: string;
        /**
         * LAN IP address of the device
         */
        lanIp: string;
        /**
         * Latitude of the device
         */
        lat: number;
        /**
         * Longitude of the device
         */
        lng: number;
        /**
         * MAC address of the device
         */
        mac: string;
        /**
         * Model of the device
         */
        model: string;
        /**
         * Name of the device
         */
        name: string;
        /**
         * ID of the network the device belongs to
         */
        networkId: string;
        /**
         * Notes for the device, limited to 255 characters
         */
        notes: string;
        /**
         * Product type of the device
         */
        productType: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * List of tags assigned to the device
         */
        tags: string[];
    }

    export interface DevicesClaimVmxItemDetail {
        /**
         * Additional property name
         */
        name: string;
        /**
         * Additional property value
         */
        value: string;
    }

    export interface DevicesClaimVmxParameters {
        /**
         * The size of the vMX you claim. It can be one of: small, medium, large, xlarge, 100
         */
        size: string;
    }

    export interface DevicesRemoveParameters {
        /**
         * The serial of a device
         */
        serial: string;
    }

    export interface FirmwareUpgradesProducts {
        /**
         * The network device to be updated
         */
        appliance: outputs.networks.FirmwareUpgradesProductsAppliance;
        /**
         * The network device to be updated
         */
        camera: outputs.networks.FirmwareUpgradesProductsCamera;
        /**
         * The network device to be updated
         */
        cellularGateway: outputs.networks.FirmwareUpgradesProductsCellularGateway;
        /**
         * The network device to be updated
         */
        sensor: outputs.networks.FirmwareUpgradesProductsSensor;
        /**
         * The network device to be updated
         */
        switch: outputs.networks.FirmwareUpgradesProductsSwitch;
        /**
         * The network device to be updated
         */
        switchCatalyst: outputs.networks.FirmwareUpgradesProductsSwitchCatalyst;
        /**
         * The network device to be updated
         */
        wireless: outputs.networks.FirmwareUpgradesProductsWireless;
    }

    export interface FirmwareUpgradesProductsAppliance {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.FirmwareUpgradesProductsApplianceAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.FirmwareUpgradesProductsApplianceCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.FirmwareUpgradesProductsApplianceLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesProductsApplianceNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface FirmwareUpgradesProductsApplianceAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsApplianceCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsApplianceLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.FirmwareUpgradesProductsApplianceLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsApplianceLastUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsApplianceLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsApplianceLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsApplianceNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsApplianceNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsApplianceNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCamera {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.FirmwareUpgradesProductsCameraAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.FirmwareUpgradesProductsCameraCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.FirmwareUpgradesProductsCameraLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesProductsCameraNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface FirmwareUpgradesProductsCameraAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCameraCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCameraLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.FirmwareUpgradesProductsCameraLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsCameraLastUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsCameraLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCameraLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCameraNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsCameraNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsCameraNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCellularGateway {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.FirmwareUpgradesProductsCellularGatewayAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.FirmwareUpgradesProductsCellularGatewayCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.FirmwareUpgradesProductsCellularGatewayLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesProductsCellularGatewayNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface FirmwareUpgradesProductsCellularGatewayAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCellularGatewayCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCellularGatewayLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsCellularGatewayLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCellularGatewayLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsCellularGatewayNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsCellularGatewayNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSensor {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.FirmwareUpgradesProductsSensorAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.FirmwareUpgradesProductsSensorCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.FirmwareUpgradesProductsSensorLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesProductsSensorNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface FirmwareUpgradesProductsSensorAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSensorCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSensorLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.FirmwareUpgradesProductsSensorLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsSensorLastUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsSensorLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSensorLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSensorNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsSensorNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsSensorNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSwitch {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.FirmwareUpgradesProductsSwitchAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.FirmwareUpgradesProductsSwitchCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.FirmwareUpgradesProductsSwitchLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesProductsSwitchNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface FirmwareUpgradesProductsSwitchAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSwitchCatalyst {
        /**
         * The pending firmware upgrade if it exists
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesProductsSwitchCatalystNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface FirmwareUpgradesProductsSwitchCatalystNextUpgrade {
        /**
         * The time of the last successful upgrade
         */
        time: string;
        /**
         * The version to be updated to
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsSwitchCatalystNextUpgradeToVersion {
        /**
         * The version ID
         */
        id: string;
    }

    export interface FirmwareUpgradesProductsSwitchCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSwitchLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.FirmwareUpgradesProductsSwitchLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsSwitchLastUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsSwitchLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSwitchLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsSwitchNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsSwitchNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsSwitchNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsWireless {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.FirmwareUpgradesProductsWirelessAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.FirmwareUpgradesProductsWirelessCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.FirmwareUpgradesProductsWirelessLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesProductsWirelessNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface FirmwareUpgradesProductsWirelessAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsWirelessCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsWirelessLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.FirmwareUpgradesProductsWirelessLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsWirelessLastUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsWirelessLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsWirelessLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesProductsWirelessNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.FirmwareUpgradesProductsWirelessNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesProductsWirelessNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesRollbacksItem {
        /**
         * Product type to rollback (if the network is a combined network)
         */
        product: string;
        /**
         * Reasons for the rollback
         */
        reasons: outputs.networks.FirmwareUpgradesRollbacksItemReason[];
        /**
         * Status of the rollback
         */
        status: string;
        /**
         * Scheduled time for the rollback
         */
        time: string;
        /**
         * Version to downgrade to (if the network has firmware flexibility)
         */
        toVersion: outputs.networks.FirmwareUpgradesRollbacksItemToVersion;
        /**
         * Batch ID of the firmware rollback
         */
        upgradeBatchId: string;
    }

    export interface FirmwareUpgradesRollbacksItemReason {
        /**
         * Reason for the rollback
         */
        category: string;
        /**
         * Additional comment about the rollback
         */
        comment: string;
    }

    export interface FirmwareUpgradesRollbacksItemToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesRollbacksParameters {
        /**
         * Product type to rollback (if the network is a combined network)
         */
        product: string;
        /**
         * Reasons for the rollback
         */
        reasons: outputs.networks.FirmwareUpgradesRollbacksParametersReason[];
        /**
         * Scheduled time for the rollback
         */
        time: string;
        /**
         * Version to downgrade to (if the network has firmware flexibility)
         */
        toVersion: outputs.networks.FirmwareUpgradesRollbacksParametersToVersion;
    }

    export interface FirmwareUpgradesRollbacksParametersReason {
        /**
         * Reason for the rollback
         */
        category: string;
        /**
         * Additional comment about the rollback
         */
        comment: string;
    }

    export interface FirmwareUpgradesRollbacksParametersToVersion {
        /**
         * The version ID
         */
        id: string;
    }

    export interface FirmwareUpgradesStagedEventsDeferItem {
        /**
         * The network devices to be updated
         */
        products: outputs.networks.FirmwareUpgradesStagedEventsDeferItemProducts;
        /**
         * Reasons for the rollback
         */
        reasons: outputs.networks.FirmwareUpgradesStagedEventsDeferItemReason[];
        /**
         * The ordered stages in the network
         */
        stages: outputs.networks.FirmwareUpgradesStagedEventsDeferItemStage[];
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProducts {
        /**
         * The Switch network to be updated
         */
        switch: outputs.networks.FirmwareUpgradesStagedEventsDeferItemProductsSwitch;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProductsSwitch {
        /**
         * Details of the next firmware upgrade
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgrade {
        /**
         * Details of the version the device will upgrade to
         */
        toVersion: outputs.networks.FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemProductsSwitchNextUpgradeToVersion {
        /**
         * Id of the Version being upgraded to
         */
        id: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemReason {
        /**
         * Reason for the rollback
         */
        category: string;
        /**
         * Additional comment about the rollback
         */
        comment: string;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemStage {
        /**
         * The staged upgrade group
         */
        group: outputs.networks.FirmwareUpgradesStagedEventsDeferItemStageGroup;
        /**
         * The Staged Upgrade Milestones for the stage
         */
        milestones: outputs.networks.FirmwareUpgradesStagedEventsDeferItemStageMilestones;
        /**
         * Current upgrade status of the group
         */
        status: string;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemStageGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description: string;
        /**
         * Id of the Staged Upgrade Group
         */
        id: string;
        /**
         * Name of the Staged Upgrade Group
         */
        name: string;
    }

    export interface FirmwareUpgradesStagedEventsDeferItemStageMilestones {
        /**
         * Time that the group was canceled
         */
        canceledAt: string;
        /**
         * Finish time for the group
         */
        completedAt: string;
        /**
         * Scheduled start time for the group
         */
        scheduledFor: string;
        /**
         * Start time for the group
         */
        startedAt: string;
    }

    export interface FirmwareUpgradesStagedEventsProducts {
        /**
         * The Switch network to be updated
         */
        switch: outputs.networks.FirmwareUpgradesStagedEventsProductsSwitch;
        /**
         * Version information for the switch network being upgraded
         */
        switchCatalyst: outputs.networks.FirmwareUpgradesStagedEventsProductsSwitchCatalyst;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitch {
        /**
         * Details of the next firmware upgrade
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchCatalyst {
        /**
         * The next upgrade version for the switch network
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgrade {
        /**
         * The version to be updated to for switch Catalyst devices
         */
        toVersion: outputs.networks.FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchCatalystNextUpgradeToVersion {
        /**
         * The version ID
         */
        id: string;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchNextUpgrade {
        /**
         * Details of the version the device will upgrade to
         */
        toVersion: outputs.networks.FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesStagedEventsProductsSwitchNextUpgradeToVersion {
        /**
         * Id of the Version being upgraded to
         */
        id: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesStagedEventsReason {
        /**
         * Reason for the rollback
         */
        category: string;
        /**
         * Additional comment about the rollback
         */
        comment: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItem {
        /**
         * The network devices to be updated
         */
        products: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProducts;
        /**
         * Reasons for the rollback
         */
        reasons: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemReason[];
        /**
         * The ordered stages in the network
         */
        stages: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemStage[];
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProducts {
        /**
         * The Switch network to be updated
         */
        switch: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProductsSwitch {
        /**
         * Details of the next firmware upgrade
         */
        nextUpgrade: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgrade {
        /**
         * Details of the version the device will upgrade to
         */
        toVersion: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemProductsSwitchNextUpgradeToVersion {
        /**
         * Id of the Version being upgraded to
         */
        id: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemReason {
        /**
         * Reason for the rollback
         */
        category: string;
        /**
         * Additional comment about the rollback
         */
        comment: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemStage {
        /**
         * The staged upgrade group
         */
        group: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemStageGroup;
        /**
         * The Staged Upgrade Milestones for the stage
         */
        milestones: outputs.networks.FirmwareUpgradesStagedEventsRollbacksItemStageMilestones;
        /**
         * Current upgrade status of the group
         */
        status: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemStageGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description: string;
        /**
         * Id of the Staged Upgrade Group
         */
        id: string;
        /**
         * Name of the Staged Upgrade Group
         */
        name: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksItemStageMilestones {
        /**
         * Time that the group was canceled
         */
        canceledAt: string;
        /**
         * Finish time for the group
         */
        completedAt: string;
        /**
         * Scheduled start time for the group
         */
        scheduledFor: string;
        /**
         * Start time for the group
         */
        startedAt: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParameters {
        /**
         * The reason for rolling back the staged upgrade
         */
        reasons: outputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersReason[];
        /**
         * All completed or in-progress stages in the network with their new start times. All pending stages will be canceled
         */
        stages: outputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersStage[];
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersReason {
        /**
         * Reason for the rollback
         */
        category: string;
        /**
         * Additional comment about the rollback
         */
        comment: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersStage {
        /**
         * The Staged Upgrade Group containing the name and ID
         */
        group: outputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersStageGroup;
        /**
         * The Staged Upgrade Milestones for the specific stage
         */
        milestones: outputs.networks.FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersStageGroup {
        /**
         * ID of the Staged Upgrade Group
         */
        id: string;
    }

    export interface FirmwareUpgradesStagedEventsRollbacksParametersStageMilestones {
        /**
         * The start time of the staged upgrade stage. (In ISO-8601 format, in the time zone of the network.)
         */
        scheduledFor: string;
    }

    export interface FirmwareUpgradesStagedEventsStage {
        /**
         * The staged upgrade group
         */
        group: outputs.networks.FirmwareUpgradesStagedEventsStageGroup;
        /**
         * The Staged Upgrade Milestones for the stage
         */
        milestones: outputs.networks.FirmwareUpgradesStagedEventsStageMilestones;
        /**
         * Current upgrade status of the group
         */
        status: string;
    }

    export interface FirmwareUpgradesStagedEventsStageGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description: string;
        /**
         * Id of the Staged Upgrade Group
         */
        id: string;
        /**
         * Name of the Staged Upgrade Group
         */
        name: string;
    }

    export interface FirmwareUpgradesStagedEventsStageMilestones {
        /**
         * Time that the group was canceled
         */
        canceledAt: string;
        /**
         * Finish time for the group
         */
        completedAt: string;
        /**
         * Scheduled start time for the group
         */
        scheduledFor: string;
        /**
         * Start time for the group
         */
        startedAt: string;
    }

    export interface FirmwareUpgradesStagedGroupsAssignedDevices {
        /**
         * Data Array of Devices containing the name and serial
         */
        devices: outputs.networks.FirmwareUpgradesStagedGroupsAssignedDevicesDevice[];
        /**
         * Data Array of Switch Stacks containing the name and id
         */
        switchStacks: outputs.networks.FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack[];
    }

    export interface FirmwareUpgradesStagedGroupsAssignedDevicesDevice {
        /**
         * Name of the device
         */
        name: string;
        /**
         * Serial of the device
         */
        serial: string;
    }

    export interface FirmwareUpgradesStagedGroupsAssignedDevicesSwitchStack {
        /**
         * ID of the Switch Stack
         */
        id: string;
        /**
         * Name of the Switch Stack
         */
        name: string;
    }

    export interface FirmwareUpgradesStagedStagesGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description: string;
        /**
         * Id of the Staged Upgrade Group
         */
        id: string;
        /**
         * Name of the Staged Upgrade Group
         */
        name: string;
    }

    export interface FirmwareUpgradesStagedStagesJson {
        /**
         * The Staged Upgrade Group
         */
        group: outputs.networks.FirmwareUpgradesStagedStagesJsonGroup;
    }

    export interface FirmwareUpgradesStagedStagesJsonGroup {
        /**
         * ID of the Staged Upgrade Group
         */
        id: string;
    }

    export interface FirmwareUpgradesUpgradeWindow {
        /**
         * Day of the week
         */
        dayOfWeek: string;
        /**
         * Hour of the day
         */
        hourOfDay: string;
    }

    export interface FloorPlansBottomLeftCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface FloorPlansBottomRightCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface FloorPlansCenter {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface FloorPlansDevice {
        /**
         * Physical address of the device
         */
        address: string;
        /**
         * Additional device information
         */
        details: outputs.networks.FloorPlansDeviceDetail[];
        /**
         * Firmware version of the device
         */
        firmware: string;
        /**
         * IMEI of the device, if applicable
         */
        imei: string;
        /**
         * LAN IP address of the device
         */
        lanIp: string;
        /**
         * Latitude of the device
         */
        lat: number;
        /**
         * Longitude of the device
         */
        lng: number;
        /**
         * MAC address of the device
         */
        mac: string;
        /**
         * Model of the device
         */
        model: string;
        /**
         * Name of the device
         */
        name: string;
        /**
         * ID of the network the device belongs to
         */
        networkId: string;
        /**
         * Notes for the device, limited to 255 characters
         */
        notes: string;
        /**
         * Product type of the device
         */
        productType: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * List of tags assigned to the device
         */
        tags: string[];
    }

    export interface FloorPlansDeviceDetail {
        /**
         * Additional property name
         */
        name: string;
        /**
         * Additional property value
         */
        value: string;
    }

    export interface FloorPlansTopLeftCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface FloorPlansTopRightCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface GetAlertsHistoryItem {
        /**
         * relevant data about the event that caused the alert
         */
        alertData: string;
        /**
         * user friendly alert type
         */
        alertType: string;
        /**
         * type of alert
         */
        alertTypeId: string;
        /**
         * the destinations this alert is configured to be delivered to
         */
        destinations: outputs.networks.GetAlertsHistoryItemDestinations;
        /**
         * info related to the device that caused the alert
         */
        device: outputs.networks.GetAlertsHistoryItemDevice;
        /**
         * time when the event occurred
         */
        occurredAt: string;
    }

    export interface GetAlertsHistoryItemDestinations {
        /**
         * email destinations for this alert
         */
        email: outputs.networks.GetAlertsHistoryItemDestinationsEmail;
        /**
         * push destinations for this alert
         */
        push: outputs.networks.GetAlertsHistoryItemDestinationsPush;
        /**
         * sms destinations for this alert
         */
        sms: outputs.networks.GetAlertsHistoryItemDestinationsSms;
        /**
         * webhook destinations for this alert
         */
        webhook: outputs.networks.GetAlertsHistoryItemDestinationsWebhook;
    }

    export interface GetAlertsHistoryItemDestinationsEmail {
        /**
         * time when the alert was sent to the user(s) for this channel
         */
        sentAt: string;
    }

    export interface GetAlertsHistoryItemDestinationsPush {
        /**
         * time when the alert was sent to the user(s) for this channel
         */
        sentAt: string;
    }

    export interface GetAlertsHistoryItemDestinationsSms {
        /**
         * time when the alert was sent to the user(s) for this channel
         */
        sentAt: string;
    }

    export interface GetAlertsHistoryItemDestinationsWebhook {
        /**
         * time when the alert was sent to the user(s) for this channel
         */
        sentAt: string;
    }

    export interface GetAlertsHistoryItemDevice {
        /**
         * device serial
         */
        serial: string;
    }

    export interface GetAlertsSettingsItem {
        alerts: outputs.networks.GetAlertsSettingsItemAlert[];
        defaultDestinations: outputs.networks.GetAlertsSettingsItemDefaultDestinations;
    }

    export interface GetAlertsSettingsItemAlert {
        alertDestinations: outputs.networks.GetAlertsSettingsItemAlertAlertDestinations;
        enabled: boolean;
        filters: outputs.networks.GetAlertsSettingsItemAlertFilters;
        type: string;
    }

    export interface GetAlertsSettingsItemAlertAlertDestinations {
        allAdmins: boolean;
        emails: string[];
        httpServerIds: string[];
        snmp: boolean;
    }

    export interface GetAlertsSettingsItemAlertFilters {
        timeout: number;
    }

    export interface GetAlertsSettingsItemDefaultDestinations {
        allAdmins: boolean;
        emails: string[];
        httpServerIds: string[];
        snmp: boolean;
    }

    export interface GetApplianceConnectivityMonitoringDestinationsItem {
        destinations: outputs.networks.GetApplianceConnectivityMonitoringDestinationsItemDestination[];
    }

    export interface GetApplianceConnectivityMonitoringDestinationsItemDestination {
        default: boolean;
        description: string;
        ip: string;
    }

    export interface GetApplianceContentFilteringCategoriesItem {
        categories: outputs.networks.GetApplianceContentFilteringCategoriesItemCategory[];
    }

    export interface GetApplianceContentFilteringCategoriesItemCategory {
        id: string;
        name: string;
    }

    export interface GetApplianceContentFilteringItem {
        allowedUrlPatterns: string[];
        blockedUrlCategories: outputs.networks.GetApplianceContentFilteringItemBlockedUrlCategory[];
        blockedUrlPatterns: string[];
        urlCategoryListSize: string;
    }

    export interface GetApplianceContentFilteringItemBlockedUrlCategory {
        id: string;
        name: string;
    }

    export interface GetApplianceFirewallCellularFirewallRulesItem {
        rules: outputs.networks.GetApplianceFirewallCellularFirewallRulesItemRule[];
    }

    export interface GetApplianceFirewallCellularFirewallRulesItemRule {
        comment: string;
        destCidr: string;
        destPort: string;
        policy: string;
        protocol: string;
        srcCidr: string;
        srcPort: string;
        syslogEnabled: boolean;
    }

    export interface GetApplianceFirewallFirewalledServicesItem {
        /**
         * A string indicating the rule for which IPs are allowed to use the specified service
         */
        access: string;
        /**
         * An array of allowed IPs that can access the service
         */
        allowedIps: string[];
        /**
         * Appliance service name
         */
        service: string;
    }

    export interface GetApplianceFirewallInboundFirewallRulesItem {
        /**
         * An ordered array of the firewall rules (not including the default rule)
         */
        rules: outputs.networks.GetApplianceFirewallInboundFirewallRulesItemRule[];
        /**
         * Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)
         */
        syslogDefaultRule: boolean;
    }

    export interface GetApplianceFirewallInboundFirewallRulesItemRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled: boolean;
    }

    export interface GetApplianceFirewallL3FirewallRulesItem {
        rules: outputs.networks.GetApplianceFirewallL3FirewallRulesItemRule[];
    }

    export interface GetApplianceFirewallL3FirewallRulesItemRule {
        comment: string;
        destCidr: string;
        destPort: string;
        policy: string;
        protocol: string;
        srcCidr: string;
        srcPort: string;
        syslogEnabled: boolean;
    }

    export interface GetApplianceFirewallL7FirewallRulesApplicationCategoriesItem {
        /**
         * The L7 firewall application categories and their associated applications for an MX network
         */
        applicationCategories: outputs.networks.GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategory[];
    }

    export interface GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategory {
        /**
         * Details of the associated applications
         */
        applications: outputs.networks.GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryApplication[];
        /**
         * The id of the category
         */
        id: string;
        /**
         * The name of the category
         */
        name: string;
    }

    export interface GetApplianceFirewallL7FirewallRulesApplicationCategoriesItemApplicationCategoryApplication {
        /**
         * The id of the application
         */
        id: string;
        /**
         * The name of the application
         */
        name: string;
    }

    export interface GetApplianceFirewallL7FirewallRulesItem {
        rules: outputs.networks.GetApplianceFirewallL7FirewallRulesItemRule[];
    }

    export interface GetApplianceFirewallL7FirewallRulesItemRule {
        policy: string;
        type: string;
        value: string;
    }

    export interface GetApplianceFirewallOneToManyNatRulesItem {
        rules: outputs.networks.GetApplianceFirewallOneToManyNatRulesItemRule[];
    }

    export interface GetApplianceFirewallOneToManyNatRulesItemRule {
        portRules: outputs.networks.GetApplianceFirewallOneToManyNatRulesItemRulePortRule[];
        publicIp: string;
        uplink: string;
    }

    export interface GetApplianceFirewallOneToManyNatRulesItemRulePortRule {
        allowedIps: string[];
        localIp: string;
        localPort: string;
        name: string;
        protocol: string;
        publicPort: string;
    }

    export interface GetApplianceFirewallOneToOneNatRulesItem {
        rules: outputs.networks.GetApplianceFirewallOneToOneNatRulesItemRule[];
    }

    export interface GetApplianceFirewallOneToOneNatRulesItemRule {
        allowedInbounds: outputs.networks.GetApplianceFirewallOneToOneNatRulesItemRuleAllowedInbound[];
        lanIp: string;
        name: string;
        publicIp: string;
        uplink: string;
    }

    export interface GetApplianceFirewallOneToOneNatRulesItemRuleAllowedInbound {
        allowedIps: string[];
        destinationPorts: string[];
        protocol: string;
    }

    export interface GetApplianceFirewallPortForwardingRulesItem {
        rules: outputs.networks.GetApplianceFirewallPortForwardingRulesItemRule[];
    }

    export interface GetApplianceFirewallPortForwardingRulesItemRule {
        allowedIps: string[];
        lanIp: string;
        localPort: string;
        name: string;
        protocol: string;
        publicPort: string;
        uplink: string;
    }

    export interface GetApplianceFirewallSettingsItem {
        spoofingProtection: outputs.networks.GetApplianceFirewallSettingsItemSpoofingProtection;
    }

    export interface GetApplianceFirewallSettingsItemSpoofingProtection {
        ipSourceGuard: outputs.networks.GetApplianceFirewallSettingsItemSpoofingProtectionIpSourceGuard;
    }

    export interface GetApplianceFirewallSettingsItemSpoofingProtectionIpSourceGuard {
        mode: string;
    }

    export interface GetAppliancePortsItem {
        /**
         * The name of the policy. Only applicable to Access ports.
         */
        accessPolicy: string;
        /**
         * Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.
         */
        allowedVlans: string;
        /**
         * Whether the trunk port can drop all untagged traffic.
         */
        dropUntaggedTraffic: boolean;
        /**
         * The status of the port
         */
        enabled: boolean;
        /**
         * Number of the port
         */
        number: number;
        /**
         * The type of the port: 'access' or 'trunk'.
         */
        type: string;
        /**
         * Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.
         */
        vlan: number;
    }

    export interface GetAppliancePrefixesDelegatedStaticsItem {
        /**
         * Prefix creation time.
         */
        createdAt: string;
        /**
         * Identifying description for the prefix.
         */
        description: string;
        /**
         * WAN1/WAN2/Independent prefix.
         */
        origin: outputs.networks.GetAppliancePrefixesDelegatedStaticsItemOrigin;
        /**
         * IPv6 prefix/prefix length.
         */
        prefix: string;
        /**
         * Static delegated prefix id.
         */
        staticDelegatedPrefixId: string;
        /**
         * Prefix Updated time.
         */
        updatedAt: string;
    }

    export interface GetAppliancePrefixesDelegatedStaticsItemOrigin {
        /**
         * Uplink provided or independent
         */
        interfaces: string[];
        /**
         * Origin type
         */
        type: string;
    }

    export interface GetApplianceRfProfilesItem {
        /**
         * Settings related to 5Ghz band.
         */
        fiveGhzSettings: outputs.networks.GetApplianceRfProfilesItemFiveGhzSettings;
        /**
         * ID of the RF Profile.
         */
        id: string;
        /**
         * The name of the profile.
         */
        name: string;
        /**
         * ID of network this RF Profile belongs in.
         */
        networkId: string;
        /**
         * Per-SSID radio settings by number.
         */
        perSsidSettings: outputs.networks.GetApplianceRfProfilesItemPerSsidSettings;
        /**
         * Settings related to 2.4Ghz band.
         */
        twoFourGhzSettings: outputs.networks.GetApplianceRfProfilesItemTwoFourGhzSettings;
    }

    export interface GetApplianceRfProfilesItemFiveGhzSettings {
        /**
         * Whether ax radio on 5Ghz band is on or off.
         */
        axEnabled: boolean;
        /**
         * Min bitrate (Mbps) of 2.4Ghz band.
         */
        minBitrate: number;
    }

    export interface GetApplianceRfProfilesItemPerSsidSettings {
        /**
         * Settings for SSID 1.
         */
        status1: outputs.networks.GetApplianceRfProfilesItemPerSsidSettingsStatus1;
        /**
         * Settings for SSID 2.
         */
        status2: outputs.networks.GetApplianceRfProfilesItemPerSsidSettingsStatus2;
        /**
         * Settings for SSID 3.
         */
        status3: outputs.networks.GetApplianceRfProfilesItemPerSsidSettingsStatus3;
        /**
         * Settings for SSID 4.
         */
        status4: outputs.networks.GetApplianceRfProfilesItemPerSsidSettingsStatus4;
    }

    export interface GetApplianceRfProfilesItemPerSsidSettingsStatus1 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface GetApplianceRfProfilesItemPerSsidSettingsStatus2 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface GetApplianceRfProfilesItemPerSsidSettingsStatus3 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface GetApplianceRfProfilesItemPerSsidSettingsStatus4 {
        /**
         * Band mode of this SSID
         */
        bandOperationMode: string;
        /**
         * Whether this SSID steers clients to the most open band between 2.4 GHz and 5 GHz.
         */
        bandSteeringEnabled: boolean;
    }

    export interface GetApplianceRfProfilesItemTwoFourGhzSettings {
        /**
         * Whether ax radio on 2.4Ghz band is on or off.
         */
        axEnabled: boolean;
        /**
         * Min bitrate (Mbps) of 2.4Ghz band.
         */
        minBitrate: number;
    }

    export interface GetApplianceSecurityIntrusionItem {
        /**
         * Intrusion detection ruleset
         */
        idsRulesets: string;
        /**
         * Intrusion detection mode
         */
        mode: string;
        /**
         * Networks included in and excluded from the detection engine
         */
        protectedNetworks: outputs.networks.GetApplianceSecurityIntrusionItemProtectedNetworks;
    }

    export interface GetApplianceSecurityIntrusionItemProtectedNetworks {
        /**
         * List of IP addresses or subnets being excluded from protection
         */
        excludedCidrs: string[];
        /**
         * List of IP addresses or subnets being protected
         */
        includedCidrs: string[];
        /**
         * Whether special IPv4 addresses should be used (see: [https://tools.ietf.org/html/rfc5735](https://tools.ietf.org/html/rfc5735))
         */
        useDefault: boolean;
    }

    export interface GetApplianceSecurityMalwareItem {
        /**
         * Sha256 digests of files permitted by the malware detection engine
         */
        allowedFiles: outputs.networks.GetApplianceSecurityMalwareItemAllowedFile[];
        /**
         * URLs permitted by the malware detection engine
         */
        allowedUrls: outputs.networks.GetApplianceSecurityMalwareItemAllowedUrl[];
        /**
         * Current status of malware prevention
         */
        mode: string;
    }

    export interface GetApplianceSecurityMalwareItemAllowedFile {
        /**
         * Comment about the allowed file
         */
        comment: string;
        /**
         * The sha256 digest of allowed file
         */
        sha256: string;
    }

    export interface GetApplianceSecurityMalwareItemAllowedUrl {
        /**
         * Comment about the allowed URL
         */
        comment: string;
        /**
         * The allowed URL
         */
        url: string;
    }

    export interface GetApplianceSettingsItem {
        /**
         * Client tracking method of a network
         */
        clientTrackingMethod: string;
        /**
         * Deployment mode of a network
         */
        deploymentMode: string;
        /**
         * Dynamic DNS settings for a network
         */
        dynamicDns: outputs.networks.GetApplianceSettingsItemDynamicDns;
    }

    export interface GetApplianceSettingsItemDynamicDns {
        /**
         * Dynamic DNS enabled
         */
        enabled: boolean;
        /**
         * Dynamic DNS url prefix. DDNS must be enabled to update
         */
        prefix: string;
        /**
         * Dynamic DNS url. DDNS must be enabled to update
         */
        url: string;
    }

    export interface GetApplianceSingleLanItem {
        /**
         * The local IP of the appliance on the single LAN
         */
        applianceIp: string;
        /**
         * IPv6 configuration on the single LAN
         */
        ipv6: outputs.networks.GetApplianceSingleLanItemIpv6;
        /**
         * Mandatory DHCP will enforce that clients connecting to this single LAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
         */
        mandatoryDhcp: outputs.networks.GetApplianceSingleLanItemMandatoryDhcp;
        /**
         * The subnet of the single LAN
         */
        subnet: string;
    }

    export interface GetApplianceSingleLanItemIpv6 {
        /**
         * Enable IPv6 on single LAN
         */
        enabled: boolean;
        /**
         * Prefix assignments on the single LAN
         */
        prefixAssignments: outputs.networks.GetApplianceSingleLanItemIpv6PrefixAssignment[];
    }

    export interface GetApplianceSingleLanItemIpv6PrefixAssignment {
        /**
         * Auto assign a /64 prefix from the origin to the single LAN
         */
        autonomous: boolean;
        /**
         * The origin of the prefix
         */
        origin: outputs.networks.GetApplianceSingleLanItemIpv6PrefixAssignmentOrigin;
        /**
         * Manual configuration of the IPv6 Appliance IP
         */
        staticApplianceIp6: string;
        /**
         * Manual configuration of a /64 prefix on the single LAN
         */
        staticPrefix: string;
    }

    export interface GetApplianceSingleLanItemIpv6PrefixAssignmentOrigin {
        /**
         * Interfaces associated with the prefix
         */
        interfaces: string[];
        /**
         * Type of the origin
         */
        type: string;
    }

    export interface GetApplianceSingleLanItemMandatoryDhcp {
        /**
         * Enable Mandatory DHCP on single LAN.
         */
        enabled: boolean;
    }

    export interface GetApplianceSsidsItem {
        /**
         * The association control method for the SSID.
         */
        authMode: string;
        /**
         * The VLAN ID of the VLAN associated to this SSID.
         */
        defaultVlanId: number;
        /**
         * Whether or not the SSID is enabled.
         */
        enabled: boolean;
        /**
         * The psk encryption mode for the SSID.
         */
        encryptionMode: string;
        /**
         * The name of the SSID.
         */
        name: string;
        /**
         * The number of the SSID.
         */
        number: number;
        /**
         * The RADIUS 802.1x servers to be used for authentication.
         */
        radiusServers: outputs.networks.GetApplianceSsidsItemRadiusServer[];
        /**
         * Boolean indicating whether the MX should advertise or hide this SSID.
         */
        visible: boolean;
        /**
         * WPA encryption mode for the SSID.
         */
        wpaEncryptionMode: string;
    }

    export interface GetApplianceSsidsItemRadiusServer {
        /**
         * The IP address of your RADIUS server.
         */
        host: string;
        /**
         * The UDP port your RADIUS servers listens on for Access-requests.
         */
        port: number;
    }

    export interface GetApplianceTrafficShapingItem {
        globalBandwidthLimits: outputs.networks.GetApplianceTrafficShapingItemGlobalBandwidthLimits;
    }

    export interface GetApplianceTrafficShapingItemGlobalBandwidthLimits {
        limitDown: number;
        limitUp: number;
    }

    export interface GetApplianceTrafficShapingRulesItem {
        defaultRulesEnabled: boolean;
        rules: outputs.networks.GetApplianceTrafficShapingRulesItemRule[];
    }

    export interface GetApplianceTrafficShapingRulesItemRule {
        definitions: outputs.networks.GetApplianceTrafficShapingRulesItemRuleDefinition[];
        dscpTagValue: number;
        perClientBandwidthLimits: outputs.networks.GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimits;
        priority: string;
    }

    export interface GetApplianceTrafficShapingRulesItemRuleDefinition {
        type: string;
        value: string;
    }

    export interface GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimits {
        bandwidthLimits: outputs.networks.GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimits;
        settings: string;
    }

    export interface GetApplianceTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimits {
        limitDown: number;
        limitUp: number;
    }

    export interface GetApplianceTrafficShapingUplinkBandwidthItem {
        /**
         * A hash uplink keys and their configured settings for the Appliance
         */
        bandwidthLimits: outputs.networks.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimits;
    }

    export interface GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimits {
        /**
         * uplink cellular configured limits [optional]
         */
        cellular: outputs.networks.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsCellular;
        /**
         * uplink wan1 configured limits [optional]
         */
        wan1: outputs.networks.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan1;
        /**
         * uplink wan2 configured limits [optional]
         */
        wan2: outputs.networks.GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan2;
    }

    export interface GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsCellular {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown: number;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp: number;
    }

    export interface GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan1 {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown: number;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp: number;
    }

    export interface GetApplianceTrafficShapingUplinkBandwidthItemBandwidthLimitsWan2 {
        /**
         * configured DOWN limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitDown: number;
        /**
         * configured UP limit for the uplink (in Kbps).  Null indicated unlimited
         */
        limitUp: number;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItem {
        /**
         * Whether active-active AutoVPN is enabled
         */
        activeActiveAutoVpnEnabled: boolean;
        /**
         * The default uplink. Must be one of: 'wan1' or 'wan2'
         */
        defaultUplink: string;
        /**
         * WAN failover and failback
         */
        failoverAndFailback: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailback;
        /**
         * Whether load balancing is enabled
         */
        loadBalancingEnabled: boolean;
        /**
         * Uplink preference rules for VPN traffic
         */
        vpnTrafficUplinkPreferences: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreference[];
        /**
         * Uplink preference rules for WAN traffic
         */
        wanTrafficUplinkPreferences: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreference[];
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailback {
        /**
         * Immediate WAN failover and failback
         */
        immediate: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackImmediate;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemFailoverAndFailbackImmediate {
        /**
         * Whether immediate WAN failover and failback is enabled
         */
        enabled: boolean;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreference {
        /**
         * Fail over criterion for uplink preference rule. Must be one of: 'poorPerformance' or 'uplinkDown'
         */
        failOverCriterion: string;
        /**
         * Performance class setting for uplink preference rule
         */
        performanceClass: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferencePerformanceClass;
        /**
         * Preferred uplink for uplink preference rule. Must be one of: 'wan1', 'wan2', 'bestForVoIP', 'loadBalancing' or 'defaultUplink'
         */
        preferredUplink: string;
        /**
         * Traffic filters
         */
        trafficFilters: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilter[];
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferencePerformanceClass {
        /**
         * Name of builtin performance class. Must be present when performanceClass type is 'builtin' and value must be one of: 'VoIP'
         */
        builtinPerformanceClassName: string;
        /**
         * ID of created custom performance class, must be present when performanceClass type is "custom"
         */
        customPerformanceClassId: string;
        /**
         * Type of this performance class. Must be one of: 'builtin' or 'custom'
         */
        type: string;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilter {
        /**
         * Traffic filter type. Must be one of: 'applicationCategory', 'application' or 'custom'
         */
        type: string;
        /**
         * Value of traffic filter
         */
        value: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValue;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValue {
        /**
         * Destination of 'custom' type traffic filter
         */
        destination: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueDestination;
        /**
         * ID of 'applicationCategory' or 'application' type traffic filter
         */
        id: string;
        /**
         * Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp', 'icmp6' or 'any'
         */
        protocol: string;
        /**
         * Source of 'custom' type traffic filter
         */
        source: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueSource;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueDestination {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" or "fqdn" property
         */
        cidr: string;
        /**
         * FQDN format address. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available in the "destination" object of the "vpnTrafficUplinkPreference" object. E.g.: "www.google.com"
         */
        fqdn: string;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host: number;
        /**
         * Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
         */
        network: string;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" or "fqdn" property and is currently only available under a template network.
         */
        vlan: number;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemVpnTrafficUplinkPreferenceTrafficFilterValueSource {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
         */
        cidr: string;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host: number;
        /**
         * Meraki network ID. Currently only available under a template network, and the value should be ID of either same template network, or another template network currently. E.g.: "L_12345678".
         */
        network: string;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
         */
        vlan: number;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreference {
        /**
         * Preferred uplink for uplink preference rule. Must be one of: 'wan1' or 'wan2'
         */
        preferredUplink: string;
        /**
         * Traffic filters
         */
        trafficFilters: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilter[];
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilter {
        /**
         * Traffic filter type. Must be "custom"
         */
        type: string;
        /**
         * Value of traffic filter
         */
        value: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValue;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValue {
        /**
         * Destination of 'custom' type traffic filter
         */
        destination: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueDestination;
        /**
         * Protocol of 'custom' type traffic filter. Must be one of: 'tcp', 'udp', 'icmp6' or 'any'
         */
        protocol: string;
        /**
         * Source of 'custom' type traffic filter
         */
        source: outputs.networks.GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueSource;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueDestination {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any"
         */
        cidr: string;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
    }

    export interface GetApplianceTrafficShapingUplinkSelectionItemWanTrafficUplinkPreferenceTrafficFilterValueSource {
        /**
         * CIDR format address (e.g."192.168.10.1", which is the same as "192.168.10.1/32"), or "any". Cannot be used in combination with the "vlan" property
         */
        cidr: string;
        /**
         * Host ID in the VLAN. Should not exceed the VLAN subnet capacity. Must be used along with the "vlan" property and is currently only available under a template network.
         */
        host: number;
        /**
         * E.g.: "any", "0" (also means "any"), "8080", "1-1024"
         */
        port: string;
        /**
         * VLAN ID of the configured VLAN in the Meraki network. Cannot be used in combination with the "cidr" property and is currently only available under a template network.
         */
        vlan: number;
    }

    export interface GetApplianceVlansItem {
        /**
         * The local IP of the appliance on the VLAN
         */
        applianceIp: string;
        /**
         * CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
         */
        cidr: string;
        /**
         * DHCP boot option for boot filename
         */
        dhcpBootFilename: string;
        /**
         * DHCP boot option to direct boot clients to the server to load the boot file from
         */
        dhcpBootNextServer: string;
        /**
         * Use DHCP boot options specified in other properties
         */
        dhcpBootOptionsEnabled: boolean;
        /**
         * The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
         */
        dhcpHandling: string;
        /**
         * The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
         */
        dhcpLeaseTime: string;
        /**
         * The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
         */
        dhcpOptions: outputs.networks.GetApplianceVlansItemDhcpOption[];
        /**
         * The IPs of the DHCP servers that DHCP requests should be relayed to
         */
        dhcpRelayServerIps: string[];
        /**
         * The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
         */
        dnsNameservers: string;
        /**
         * The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.
         */
        fixedIpAssignments: string;
        /**
         * The id of the desired group policy to apply to the VLAN
         */
        groupPolicyId: string;
        /**
         * The VLAN ID of the VLAN
         */
        id: number;
        /**
         * The interface ID of the VLAN
         */
        interfaceId: string;
        /**
         * IPv6 configuration on the VLAN
         */
        ipv6: outputs.networks.GetApplianceVlansItemIpv6;
        /**
         * Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
         */
        mandatoryDhcp: outputs.networks.GetApplianceVlansItemMandatoryDhcp;
        /**
         * Mask used for the subnet of all bound to the template networks. Applicable only for template network.
         */
        mask: number;
        /**
         * The name of the VLAN
         */
        name: string;
        /**
         * The DHCP reserved IP ranges on the VLAN
         */
        reservedIpRanges: outputs.networks.GetApplianceVlansItemReservedIpRange[];
        /**
         * The subnet of the VLAN
         */
        subnet: string;
        /**
         * Type of subnetting of the VLAN. Applicable only for template network.
         */
        templateVlanType: string;
        /**
         * The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
         */
        vpnNatSubnet: string;
    }

    export interface GetApplianceVlansItemDhcpOption {
        /**
         * The code for the DHCP option. This should be an integer between 2 and 254.
         */
        code: string;
        /**
         * The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'
         */
        type: string;
        /**
         * The value for the DHCP option
         */
        value: string;
    }

    export interface GetApplianceVlansItemIpv6 {
        /**
         * Enable IPv6 on VLAN
         */
        enabled: boolean;
        /**
         * Prefix assignments on the VLAN
         */
        prefixAssignments: outputs.networks.GetApplianceVlansItemIpv6PrefixAssignment[];
    }

    export interface GetApplianceVlansItemIpv6PrefixAssignment {
        /**
         * Auto assign a /64 prefix from the origin to the VLAN
         */
        autonomous: boolean;
        /**
         * The origin of the prefix
         */
        origin: outputs.networks.GetApplianceVlansItemIpv6PrefixAssignmentOrigin;
        /**
         * Manual configuration of the IPv6 Appliance IP
         */
        staticApplianceIp6: string;
        /**
         * Manual configuration of a /64 prefix on the VLAN
         */
        staticPrefix: string;
    }

    export interface GetApplianceVlansItemIpv6PrefixAssignmentOrigin {
        /**
         * Interfaces associated with the prefix
         */
        interfaces: string[];
        /**
         * Type of the origin
         */
        type: string;
    }

    export interface GetApplianceVlansItemMandatoryDhcp {
        /**
         * Enable Mandatory DHCP on VLAN.
         */
        enabled: boolean;
    }

    export interface GetApplianceVlansItemReservedIpRange {
        /**
         * A text comment for the reserved range
         */
        comment: string;
        /**
         * The last IP in the reserved range
         */
        end: string;
        /**
         * The first IP in the reserved range
         */
        start: string;
    }

    export interface GetApplianceVlansSettingsItem {
        /**
         * Boolean indicating whether VLANs are enabled (true) or disabled (false) for the network
         */
        vlansEnabled: boolean;
    }

    export interface GetApplianceVpnBgpItem {
        asNumber: number;
        enabled: boolean;
        ibgpHoldTimer: number;
        neighbors: outputs.networks.GetApplianceVpnBgpItemNeighbor[];
    }

    export interface GetApplianceVpnBgpItemNeighbor {
        allowTransit: boolean;
        ebgpHoldTimer: number;
        ebgpMultihop: number;
        ip: string;
        receiveLimit: number;
        remoteAsNumber: number;
    }

    export interface GetApplianceVpnSiteToSiteVpnItem {
        /**
         * The list of VPN hubs, in order of preference.
         */
        hubs: outputs.networks.GetApplianceVpnSiteToSiteVpnItemHub[];
        /**
         * The site-to-site VPN mode.
         */
        mode: string;
        /**
         * The list of subnets and their VPN presence.
         */
        subnets: outputs.networks.GetApplianceVpnSiteToSiteVpnItemSubnet[];
    }

    export interface GetApplianceVpnSiteToSiteVpnItemHub {
        /**
         * The network ID of the hub.
         */
        hubId: string;
        /**
         * Indicates whether default route traffic should be sent to this hub.
         */
        useDefaultRoute: boolean;
    }

    export interface GetApplianceVpnSiteToSiteVpnItemSubnet {
        /**
         * The CIDR notation subnet used within the VPN
         */
        localSubnet: string;
        /**
         * Indicates the presence of the subnet in the VPN
         */
        useVpn: boolean;
    }

    export interface GetApplianceWarmSpareItem {
        enabled: boolean;
        primarySerial: string;
        spareSerial: string;
        uplinkMode: string;
        wan1: outputs.networks.GetApplianceWarmSpareItemWan1;
        wan2: outputs.networks.GetApplianceWarmSpareItemWan2;
    }

    export interface GetApplianceWarmSpareItemWan1 {
        ip: string;
        subnet: string;
    }

    export interface GetApplianceWarmSpareItemWan2 {
        ip: string;
        subnet: string;
    }

    export interface GetBluetoothClientsItem {
        deviceName: string;
        id: string;
        inSightAlert: boolean;
        lastSeen: number;
        mac: string;
        manufacturer: string;
        name: string;
        networkId: string;
        outOfSightAlert: boolean;
        seenByDeviceMac: string;
        tags: string[];
    }

    export interface GetCameraQualityRetentionProfilesItem {
        audioRecordingEnabled: boolean;
        cloudArchiveEnabled: boolean;
        id: string;
        maxRetentionDays: number;
        motionBasedRetentionEnabled: boolean;
        motionDetectorVersion: number;
        name: string;
        networkId: string;
        restrictedBandwidthModeEnabled: boolean;
        scheduleId: string;
        videoSettings: outputs.networks.GetCameraQualityRetentionProfilesItemVideoSettings;
    }

    export interface GetCameraQualityRetentionProfilesItemVideoSettings {
        mV12MV22MV72: outputs.networks.GetCameraQualityRetentionProfilesItemVideoSettingsMV12MV22MV72;
        mV12We: outputs.networks.GetCameraQualityRetentionProfilesItemVideoSettingsMV12We;
        mV21MV71: outputs.networks.GetCameraQualityRetentionProfilesItemVideoSettingsMV21MV71;
        mV32: outputs.networks.GetCameraQualityRetentionProfilesItemVideoSettingsMV32;
    }

    export interface GetCameraQualityRetentionProfilesItemVideoSettingsMV12MV22MV72 {
        quality: string;
        resolution: string;
    }

    export interface GetCameraQualityRetentionProfilesItemVideoSettingsMV12We {
        quality: string;
        resolution: string;
    }

    export interface GetCameraQualityRetentionProfilesItemVideoSettingsMV21MV71 {
        quality: string;
        resolution: string;
    }

    export interface GetCameraQualityRetentionProfilesItemVideoSettingsMV32 {
        quality: string;
        resolution: string;
    }

    export interface GetCameraWirelessProfilesItem {
        appliedDeviceCount: number;
        id: string;
        identity: outputs.networks.GetCameraWirelessProfilesItemIdentity;
        name: string;
        ssid: outputs.networks.GetCameraWirelessProfilesItemSsid;
    }

    export interface GetCameraWirelessProfilesItemIdentity {
        password: string;
        username: string;
    }

    export interface GetCameraWirelessProfilesItemSsid {
        authMode: string;
        encryptionMode: string;
        name: string;
    }

    export interface GetCellularGatewayConnectivityMonitoringDestinationsItem {
        destinations: outputs.networks.GetCellularGatewayConnectivityMonitoringDestinationsItemDestination[];
    }

    export interface GetCellularGatewayConnectivityMonitoringDestinationsItemDestination {
        default: boolean;
        description: string;
        ip: string;
    }

    export interface GetCellularGatewayDhcpItem {
        /**
         * DHCP Lease time for all MG in the network.
         */
        dhcpLeaseTime: string;
        /**
         * List of fixed IPs representing the the DNS Name servers when the mode is 'custom'.
         */
        dnsCustomNameservers: string[];
        /**
         * DNS name servers mode for all MG in the network.
         */
        dnsNameservers: string;
    }

    export interface GetCellularGatewaySubnetPoolItem {
        cidr: string;
        deploymentMode: string;
        mask: number;
        subnets: outputs.networks.GetCellularGatewaySubnetPoolItemSubnet[];
    }

    export interface GetCellularGatewaySubnetPoolItemSubnet {
        applianceIp: string;
        name: string;
        serial: string;
        subnet: string;
    }

    export interface GetCellularGatewayUplinkItem {
        /**
         * The bandwidth settings for the 'cellular' uplink
         */
        bandwidthLimits: outputs.networks.GetCellularGatewayUplinkItemBandwidthLimits;
    }

    export interface GetCellularGatewayUplinkItemBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps). 'null' indicates no limit.
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps). 'null' indicates no limit.
         */
        limitUp: number;
    }

    export interface GetClientsItem {
        /**
         * The Cisco discover protocol settings for the client
         */
        cdps: outputs.networks.GetClientsItemCdp[];
        /**
         * VPN connections associated with the client
         */
        clientVpnConnections: outputs.networks.GetClientsItemClientVpnConnection[];
        /**
         * Short description of the client
         */
        description: string;
        /**
         * Timestamp client was first seen in the network
         */
        firstSeen: number;
        /**
         * The ID of the client
         */
        id: string;
        /**
         * The IP address of the client
         */
        ip: string;
        /**
         * The IPv6 address of the client
         */
        ip6: string;
        /**
         * Timestamp client was last seen in the network
         */
        lastSeen: number;
        /**
         * The link layer discover protocol settings for the client
         */
        lldps: outputs.networks.GetClientsItemLldp[];
        /**
         * The MAC address of the client
         */
        mac: string;
        /**
         * Manufacturer of the client
         */
        manufacturer: string;
        /**
         * The operating system of the client
         */
        os: string;
        /**
         * The MAC address of the node that the device was last connected to
         */
        recentDeviceMac: string;
        /**
         * Status of SM for the client
         */
        smInstalled: boolean;
        /**
         * The name of the SSID that the client is connected to
         */
        ssid: string;
        /**
         * The connection status of the client
         */
        status: string;
        /**
         * The switch port that the client is connected to
         */
        switchport: string;
        /**
         * The username of the user of the client
         */
        user: string;
        /**
         * The name of the VLAN that the client is connected to
         */
        vlan: string;
        /**
         * Wireless capabilities of the client
         */
        wirelessCapabilities: string;
    }

    export interface GetClientsItemCdp {
    }

    export interface GetClientsItemClientVpnConnection {
        /**
         * The time the client last connected to the VPN
         */
        connectedAt: number;
        /**
         * The time the client last disconnectd from the VPN
         */
        disconnectedAt: number;
        /**
         * The IP address of the VPN the client last connected to
         */
        remoteIp: string;
    }

    export interface GetClientsItemLldp {
    }

    export interface GetClientsOverviewItem {
        /**
         * The number of clients on a network over a given time range
         */
        counts: outputs.networks.GetClientsOverviewItemCounts;
        /**
         * The average usage of the clients on a network over a given time range
         */
        usages: outputs.networks.GetClientsOverviewItemUsages;
    }

    export interface GetClientsOverviewItemCounts {
        /**
         * The total number of clients on a network
         */
        total: number;
        /**
         * The total number of clients with heavy usage on a network
         */
        withHeavyUsage: number;
    }

    export interface GetClientsOverviewItemUsages {
        /**
         * The average usage of all clients on a network
         */
        average: number;
        /**
         * The average usage of all clients with heavy usage on a network
         */
        withHeavyUsageAverage: number;
    }

    export interface GetClientsPolicyItem {
        /**
         * The name of the client's policy
         */
        devicePolicy: string;
        /**
         * The group policy identifier of the client
         */
        groupPolicyId: string;
        /**
         * The MAC address of the client
         */
        mac: string;
    }

    export interface GetClientsSplashAuthorizationStatusItem {
        ssids: outputs.networks.GetClientsSplashAuthorizationStatusItemSsids;
    }

    export interface GetClientsSplashAuthorizationStatusItemSsids {
        status0: outputs.networks.GetClientsSplashAuthorizationStatusItemSsidsStatus0;
        status2: outputs.networks.GetClientsSplashAuthorizationStatusItemSsidsStatus2;
    }

    export interface GetClientsSplashAuthorizationStatusItemSsidsStatus0 {
        authorizedAt: string;
        expiresAt: string;
        isAuthorized: boolean;
    }

    export interface GetClientsSplashAuthorizationStatusItemSsidsStatus2 {
        isAuthorized: boolean;
    }

    export interface GetEventsEventTypesItem {
        /**
         * Event category
         */
        category: string;
        /**
         * Description of the event
         */
        description: string;
        /**
         * Event type
         */
        type: string;
    }

    export interface GetEventsItem {
        /**
         * An array of events that took place in the network.
         */
        events: outputs.networks.GetEventsItemEvent[];
        /**
         * A message regarding the events sent. Usually 'null' unless there are no events
         */
        message: string;
        /**
         * An UTC ISO8601 string of the latest occured at time of the listed events of the page.
         */
        pageEndAt: string;
        /**
         * An UTC ISO8601 string of the earliest occured at time of the listed events of the page.
         */
        pageStartAt: string;
    }

    export interface GetEventsItemEvent {
        /**
         * The category that the event type belongs to
         */
        category: string;
        /**
         * A description of the client. This is usually the client's device name.
         */
        clientDescription: string;
        /**
         * A string identifying the client. This could be a client's MAC or IP address
         */
        clientId: string;
        /**
         * The client's MAC address.
         */
        clientMac: string;
        /**
         * A description of the event the happened.
         */
        description: string;
        /**
         * The name of the device. Only shown if the device is an access point.
         */
        deviceName: string;
        /**
         * The serial number of the device. Only shown if the device is an access point.
         */
        deviceSerial: string;
        /**
         * An object containing more data related to the event.
         */
        eventData: outputs.networks.GetEventsItemEventEventData;
        /**
         * The ID of the network.
         */
        networkId: string;
        /**
         * An UTC ISO8601 string of the time the event occurred at.
         */
        occurredAt: string;
        /**
         * The SSID number of the device.
         */
        ssidNumber: number;
        /**
         * The type of event being listed.
         */
        type: string;
    }

    export interface GetEventsItemEventEventData {
        /**
         * The association ID of the client.
         */
        aid: string;
        /**
         * The radio channel the client is connecting to.
         */
        channel: string;
        /**
         * The client's IP address
         */
        clientIp: string;
        /**
         * The client's MAC address
         */
        clientMac: string;
        /**
         * The radio band number the client is trying to connect to.
         */
        radio: string;
        /**
         * The current received signal strength indication (RSSI) of the client connected to an AP.
         */
        rssi: string;
        /**
         * The virtual access point (VAP) number the client is connecting to.
         */
        vap: string;
    }

    export interface GetFirmwareUpgradesItem {
        /**
         * The network devices to be updated
         */
        products: outputs.networks.GetFirmwareUpgradesItemProducts;
        /**
         * The timezone for the network
         */
        timezone: string;
        /**
         * Upgrade window for devices in network
         */
        upgradeWindow: outputs.networks.GetFirmwareUpgradesItemUpgradeWindow;
    }

    export interface GetFirmwareUpgradesItemProducts {
        /**
         * The network device to be updated
         */
        appliance: outputs.networks.GetFirmwareUpgradesItemProductsAppliance;
        /**
         * The network device to be updated
         */
        camera: outputs.networks.GetFirmwareUpgradesItemProductsCamera;
        /**
         * The network device to be updated
         */
        cellularGateway: outputs.networks.GetFirmwareUpgradesItemProductsCellularGateway;
        /**
         * The network device to be updated
         */
        sensor: outputs.networks.GetFirmwareUpgradesItemProductsSensor;
        /**
         * The network device to be updated
         */
        switch: outputs.networks.GetFirmwareUpgradesItemProductsSwitch;
        /**
         * The network device to be updated
         */
        wireless: outputs.networks.GetFirmwareUpgradesItemProductsWireless;
    }

    export interface GetFirmwareUpgradesItemProductsAppliance {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.GetFirmwareUpgradesItemProductsApplianceAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.GetFirmwareUpgradesItemProductsApplianceCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsApplianceLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsApplianceNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface GetFirmwareUpgradesItemProductsApplianceAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsApplianceCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsApplianceLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.GetFirmwareUpgradesItemProductsApplianceLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsApplianceLastUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsApplianceLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsApplianceLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsApplianceNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsApplianceNextUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsApplianceNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCamera {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.GetFirmwareUpgradesItemProductsCameraAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.GetFirmwareUpgradesItemProductsCameraCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsCameraLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsCameraNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface GetFirmwareUpgradesItemProductsCameraAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCameraCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCameraLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.GetFirmwareUpgradesItemProductsCameraLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsCameraLastUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsCameraLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCameraLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCameraNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsCameraNextUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsCameraNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGateway {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.GetFirmwareUpgradesItemProductsCellularGatewayAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.GetFirmwareUpgradesItemProductsCellularGatewayCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsCellularGatewayNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGatewayAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGatewayCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGatewayLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGatewayLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGatewayNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsCellularGatewayNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSensor {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.GetFirmwareUpgradesItemProductsSensorAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.GetFirmwareUpgradesItemProductsSensorCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsSensorLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsSensorNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface GetFirmwareUpgradesItemProductsSensorAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSensorCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSensorLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.GetFirmwareUpgradesItemProductsSensorLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsSensorLastUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsSensorLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSensorLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSensorNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsSensorNextUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsSensorNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSwitch {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.GetFirmwareUpgradesItemProductsSwitchAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.GetFirmwareUpgradesItemProductsSwitchCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsSwitchLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsSwitchNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface GetFirmwareUpgradesItemProductsSwitchAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSwitchCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSwitchLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.GetFirmwareUpgradesItemProductsSwitchLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsSwitchLastUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsSwitchLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSwitchLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsSwitchNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsSwitchNextUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsSwitchNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsWireless {
        /**
         * Firmware versions available for upgrade
         */
        availableVersions: outputs.networks.GetFirmwareUpgradesItemProductsWirelessAvailableVersion[];
        /**
         * Details of the current version on the device
         */
        currentVersion: outputs.networks.GetFirmwareUpgradesItemProductsWirelessCurrentVersion;
        /**
         * Details of the last firmware upgrade on the device
         */
        lastUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsWirelessLastUpgrade;
        /**
         * Details of the next firmware upgrade on the device
         */
        nextUpgrade: outputs.networks.GetFirmwareUpgradesItemProductsWirelessNextUpgrade;
        /**
         * Whether or not the network wants beta firmware
         */
        participateInNextBetaRelease: boolean;
    }

    export interface GetFirmwareUpgradesItemProductsWirelessAvailableVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsWirelessCurrentVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsWirelessLastUpgrade {
        /**
         * Details of the version the device upgraded from
         */
        fromVersion: outputs.networks.GetFirmwareUpgradesItemProductsWirelessLastUpgradeFromVersion;
        /**
         * Timestamp of the last successful firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device upgraded to
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsWirelessLastUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsWirelessLastUpgradeFromVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsWirelessLastUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemProductsWirelessNextUpgrade {
        /**
         * Timestamp of the next scheduled firmware upgrade
         */
        time: string;
        /**
         * Details of the version the device will upgrade to if it exists
         */
        toVersion: outputs.networks.GetFirmwareUpgradesItemProductsWirelessNextUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesItemProductsWirelessNextUpgradeToVersion {
        /**
         * Name of the firmware version
         */
        firmware: string;
        /**
         * Firmware version identifier
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemUpgradeWindow {
        /**
         * Day of the week
         */
        dayOfWeek: string;
        /**
         * Hour of the day
         */
        hourOfDay: string;
    }

    export interface GetFirmwareUpgradesStagedEventsItem {
        /**
         * The network devices to be updated
         */
        products: outputs.networks.GetFirmwareUpgradesStagedEventsItemProducts;
        /**
         * Reasons for the rollback
         */
        reasons: outputs.networks.GetFirmwareUpgradesStagedEventsItemReason[];
        /**
         * The ordered stages in the network
         */
        stages: outputs.networks.GetFirmwareUpgradesStagedEventsItemStage[];
    }

    export interface GetFirmwareUpgradesStagedEventsItemProducts {
        /**
         * The Switch network to be updated
         */
        switch: outputs.networks.GetFirmwareUpgradesStagedEventsItemProductsSwitch;
    }

    export interface GetFirmwareUpgradesStagedEventsItemProductsSwitch {
        /**
         * Details of the next firmware upgrade
         */
        nextUpgrade: outputs.networks.GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgrade;
    }

    export interface GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgrade {
        /**
         * Details of the version the device will upgrade to
         */
        toVersion: outputs.networks.GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeToVersion;
    }

    export interface GetFirmwareUpgradesStagedEventsItemProductsSwitchNextUpgradeToVersion {
        /**
         * Id of the Version being upgraded to
         */
        id: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesStagedEventsItemReason {
        /**
         * Reason for the rollback
         */
        category: string;
        /**
         * Additional comment about the rollback
         */
        comment: string;
    }

    export interface GetFirmwareUpgradesStagedEventsItemStage {
        /**
         * The staged upgrade group
         */
        group: outputs.networks.GetFirmwareUpgradesStagedEventsItemStageGroup;
        /**
         * The Staged Upgrade Milestones for the stage
         */
        milestones: outputs.networks.GetFirmwareUpgradesStagedEventsItemStageMilestones;
        /**
         * Current upgrade status of the group
         */
        status: string;
    }

    export interface GetFirmwareUpgradesStagedEventsItemStageGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description: string;
        /**
         * Id of the Staged Upgrade Group
         */
        id: string;
        /**
         * Name of the Staged Upgrade Group
         */
        name: string;
    }

    export interface GetFirmwareUpgradesStagedEventsItemStageMilestones {
        /**
         * Time that the group was canceled
         */
        canceledAt: string;
        /**
         * Finish time for the group
         */
        completedAt: string;
        /**
         * Scheduled start time for the group
         */
        scheduledFor: string;
        /**
         * Start time for the group
         */
        startedAt: string;
    }

    export interface GetFirmwareUpgradesStagedGroupsItem {
        /**
         * The devices and Switch Stacks assigned to the Group
         */
        assignedDevices: outputs.networks.GetFirmwareUpgradesStagedGroupsItemAssignedDevices;
        /**
         * Description of the Staged Upgrade Group
         */
        description: string;
        /**
         * Id of staged upgrade group
         */
        groupId: string;
        /**
         * Boolean indicating the default Group. Any device that does not have a group explicitly assigned will upgrade with this group
         */
        isDefault: boolean;
        /**
         * Name of the Staged Upgrade Group
         */
        name: string;
    }

    export interface GetFirmwareUpgradesStagedGroupsItemAssignedDevices {
        /**
         * Data Array of Devices containing the name and serial
         */
        devices: outputs.networks.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesDevice[];
        /**
         * Data Array of Switch Stacks containing the name and id
         */
        switchStacks: outputs.networks.GetFirmwareUpgradesStagedGroupsItemAssignedDevicesSwitchStack[];
    }

    export interface GetFirmwareUpgradesStagedGroupsItemAssignedDevicesDevice {
        /**
         * Name of the device
         */
        name: string;
        /**
         * Serial of the device
         */
        serial: string;
    }

    export interface GetFirmwareUpgradesStagedGroupsItemAssignedDevicesSwitchStack {
        /**
         * ID of the Switch Stack
         */
        id: string;
        /**
         * Name of the Switch Stack
         */
        name: string;
    }

    export interface GetFirmwareUpgradesStagedStagesItem {
        /**
         * The Staged Upgrade Group
         */
        group: outputs.networks.GetFirmwareUpgradesStagedStagesItemGroup;
    }

    export interface GetFirmwareUpgradesStagedStagesItemGroup {
        /**
         * Description of the Staged Upgrade Group
         */
        description: string;
        /**
         * Id of the Staged Upgrade Group
         */
        id: string;
        /**
         * Name of the Staged Upgrade Group
         */
        name: string;
    }

    export interface GetFloorPlansItem {
        /**
         * The longitude and latitude of the bottom left corner of your floor plan.
         */
        bottomLeftCorner: outputs.networks.GetFloorPlansItemBottomLeftCorner;
        /**
         * The longitude and latitude of the bottom right corner of your floor plan.
         */
        bottomRightCorner: outputs.networks.GetFloorPlansItemBottomRightCorner;
        /**
         * The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.
         */
        center: outputs.networks.GetFloorPlansItemCenter;
        /**
         * List of devices for the floorplan
         */
        devices: outputs.networks.GetFloorPlansItemDevice[];
        /**
         * Floor plan ID
         */
        floorPlanId: string;
        /**
         * The height of your floor plan.
         */
        height: number;
        /**
         * The format type of the image.
         */
        imageExtension: string;
        /**
         * The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.
         */
        imageMd5: string;
        /**
         * The url link for the floor plan image.
         */
        imageUrl: string;
        /**
         * The time the image url link will expire.
         */
        imageUrlExpiresAt: string;
        /**
         * The name of your floor plan.
         */
        name: string;
        /**
         * The longitude and latitude of the top left corner of your floor plan.
         */
        topLeftCorner: outputs.networks.GetFloorPlansItemTopLeftCorner;
        /**
         * The longitude and latitude of the top right corner of your floor plan.
         */
        topRightCorner: outputs.networks.GetFloorPlansItemTopRightCorner;
        /**
         * The width of your floor plan.
         */
        width: number;
    }

    export interface GetFloorPlansItemBottomLeftCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface GetFloorPlansItemBottomRightCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface GetFloorPlansItemCenter {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface GetFloorPlansItemDevice {
        /**
         * Physical address of the device
         */
        address: string;
        /**
         * Additional device information
         */
        details: outputs.networks.GetFloorPlansItemDeviceDetail[];
        /**
         * Firmware version of the device
         */
        firmware: string;
        /**
         * IMEI of the device, if applicable
         */
        imei: string;
        /**
         * LAN IP address of the device
         */
        lanIp: string;
        /**
         * Latitude of the device
         */
        lat: number;
        /**
         * Longitude of the device
         */
        lng: number;
        /**
         * MAC address of the device
         */
        mac: string;
        /**
         * Model of the device
         */
        model: string;
        /**
         * Name of the device
         */
        name: string;
        /**
         * ID of the network the device belongs to
         */
        networkId: string;
        /**
         * Notes for the device, limited to 255 characters
         */
        notes: string;
        /**
         * Product type of the device
         */
        productType: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * List of tags assigned to the device
         */
        tags: string[];
    }

    export interface GetFloorPlansItemDeviceDetail {
        /**
         * Additional property name
         */
        name: string;
        /**
         * Additional property value
         */
        value: string;
    }

    export interface GetFloorPlansItemTopLeftCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface GetFloorPlansItemTopRightCorner {
        /**
         * Latitude
         */
        lat: number;
        /**
         * Longitude
         */
        lng: number;
    }

    export interface GetGroupPoliciesItem {
        /**
         * The bandwidth settings for clients bound to your group policy.
         */
        bandwidth: outputs.networks.GetGroupPoliciesItemBandwidth;
        /**
         * The Bonjour settings for your group policy. Only valid if your network has a wireless configuration.
         */
        bonjourForwarding: outputs.networks.GetGroupPoliciesItemBonjourForwarding;
        /**
         * The content filtering settings for your group policy
         */
        contentFiltering: outputs.networks.GetGroupPoliciesItemContentFiltering;
        /**
         * The firewall and traffic shaping rules and settings for your policy.
         */
        firewallAndTrafficShaping: outputs.networks.GetGroupPoliciesItemFirewallAndTrafficShaping;
        /**
         * The ID of the group policy
         */
        groupPolicyId: string;
        /**
         * The schedule for the group policy. Schedules are applied to days of the week.
         */
        scheduling: outputs.networks.GetGroupPoliciesItemScheduling;
        /**
         * Whether clients bound to your policy will bypass splash authorization or behave according to the network's rules. Can be one of 'network default' or 'bypass'. Only available if your network has a wireless configuration.
         */
        splashAuthSettings: string;
        /**
         * The VLAN tagging settings for your group policy. Only available if your network has a wireless configuration.
         */
        vlanTagging: outputs.networks.GetGroupPoliciesItemVlanTagging;
    }

    export interface GetGroupPoliciesItemBandwidth {
        /**
         * The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits: outputs.networks.GetGroupPoliciesItemBandwidthBandwidthLimits;
        /**
         * How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface GetGroupPoliciesItemBandwidthBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps). null indicates no limit
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps). null indicates no limit
         */
        limitUp: number;
    }

    export interface GetGroupPoliciesItemBonjourForwarding {
        /**
         * A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
         */
        rules: outputs.networks.GetGroupPoliciesItemBonjourForwardingRule[];
        /**
         * How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface GetGroupPoliciesItemBonjourForwardingRule {
        /**
         * A description for your Bonjour forwarding rule. Optional.
         */
        description: string;
        /**
         * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
         */
        services: string[];
        /**
         * The ID of the service VLAN. Required.
         */
        vlanId: string;
    }

    export interface GetGroupPoliciesItemContentFiltering {
        /**
         * Settings for allowed URL patterns
         */
        allowedUrlPatterns: outputs.networks.GetGroupPoliciesItemContentFilteringAllowedUrlPatterns;
        /**
         * Settings for blocked URL categories
         */
        blockedUrlCategories: outputs.networks.GetGroupPoliciesItemContentFilteringBlockedUrlCategories;
        /**
         * Settings for blocked URL patterns
         */
        blockedUrlPatterns: outputs.networks.GetGroupPoliciesItemContentFilteringBlockedUrlPatterns;
    }

    export interface GetGroupPoliciesItemContentFilteringAllowedUrlPatterns {
        /**
         * A list of URL patterns that are allowed
         */
        patterns: string[];
        /**
         * How URL patterns are applied. Can be 'network default', 'append' or 'override'.
         */
        settings: string;
    }

    export interface GetGroupPoliciesItemContentFilteringBlockedUrlCategories {
        /**
         * A list of URL categories to block
         */
        categories: string[];
        /**
         * How URL categories are applied. Can be 'network default', 'append' or 'override'.
         */
        settings: string;
    }

    export interface GetGroupPoliciesItemContentFilteringBlockedUrlPatterns {
        /**
         * A list of URL patterns that are blocked
         */
        patterns: string[];
        /**
         * How URL patterns are applied. Can be 'network default', 'append' or 'override'.
         */
        settings: string;
    }

    export interface GetGroupPoliciesItemFirewallAndTrafficShaping {
        /**
         * An ordered array of the L3 firewall rules
         */
        l3FirewallRules: outputs.networks.GetGroupPoliciesItemFirewallAndTrafficShapingL3FirewallRule[];
        /**
         * An ordered array of L7 firewall rules
         */
        l7FirewallRules: outputs.networks.GetGroupPoliciesItemFirewallAndTrafficShapingL7FirewallRule[];
        /**
         * How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
        /**
         * An array of traffic shaping rules. Rules are applied in the order that
         * they are specified in. An empty list (or null) means no rules. Note that
         * you are allowed a maximum of 8 rules.
         */
        trafficShapingRules: outputs.networks.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRule[];
    }

    export interface GetGroupPoliciesItemFirewallAndTrafficShapingL3FirewallRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
         */
        destCidr: string;
        /**
         * Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
    }

    export interface GetGroupPoliciesItemFirewallAndTrafficShapingL7FirewallRule {
        /**
         * The policy applied to matching traffic. Must be 'deny'.
         */
        policy: string;
        /**
         * Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
         */
        type: string;
        /**
         * The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
         */
        value: string;
    }

    export interface GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions: outputs.networks.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleDefinition[];
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue: number;
        /**
         * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
         * null means 'Do not set PCP tag'.
         */
        pcpTagValue: number;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits: outputs.networks.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits;
        /**
         * A string, indicating the priority level for packets bound to your rule.
         * Can be 'low', 'normal' or 'high'.
         */
        priority: string;
    }

    export interface GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type: string;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         *     a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         *     "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         *     custom ports.
         *      If "type" is 'application' or 'applicationCategory', then "value" must be an object
         *     with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         *     application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         *     endpoint).
         */
        value: string;
    }

    export interface GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits: outputs.networks.GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface GetGroupPoliciesItemFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp: number;
    }

    export interface GetGroupPoliciesItemScheduling {
        /**
         * Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
         */
        enabled: boolean;
        /**
         * The schedule object for Friday.
         */
        friday: outputs.networks.GetGroupPoliciesItemSchedulingFriday;
        /**
         * The schedule object for Monday.
         */
        monday: outputs.networks.GetGroupPoliciesItemSchedulingMonday;
        /**
         * The schedule object for Saturday.
         */
        saturday: outputs.networks.GetGroupPoliciesItemSchedulingSaturday;
        /**
         * The schedule object for Sunday.
         */
        sunday: outputs.networks.GetGroupPoliciesItemSchedulingSunday;
        /**
         * The schedule object for Thursday.
         */
        thursday: outputs.networks.GetGroupPoliciesItemSchedulingThursday;
        /**
         * The schedule object for Tuesday.
         */
        tuesday: outputs.networks.GetGroupPoliciesItemSchedulingTuesday;
        /**
         * The schedule object for Wednesday.
         */
        wednesday: outputs.networks.GetGroupPoliciesItemSchedulingWednesday;
    }

    export interface GetGroupPoliciesItemSchedulingFriday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GetGroupPoliciesItemSchedulingMonday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GetGroupPoliciesItemSchedulingSaturday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GetGroupPoliciesItemSchedulingSunday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GetGroupPoliciesItemSchedulingThursday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GetGroupPoliciesItemSchedulingTuesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GetGroupPoliciesItemSchedulingWednesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GetGroupPoliciesItemVlanTagging {
        /**
         * How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
        /**
         * The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
         */
        vlanId: string;
    }

    export interface GetHealthAlertsItem {
        /**
         * Category of the alert
         */
        category: string;
        /**
         * Alert identifier. Value can be empty
         */
        id: string;
        /**
         * The scope of the alert
         */
        scope: outputs.networks.GetHealthAlertsItemScope;
        /**
         * Severity of the alert
         */
        severity: string;
        /**
         * Alert type
         */
        type: string;
    }

    export interface GetHealthAlertsItemScope {
        /**
         * Applications related to the alert
         */
        applications: outputs.networks.GetHealthAlertsItemScopeApplication[];
        /**
         * Devices related to the alert
         */
        devices: outputs.networks.GetHealthAlertsItemScopeDevice[];
        /**
         * Peers related to the alert
         */
        peers: outputs.networks.GetHealthAlertsItemScopePeer[];
    }

    export interface GetHealthAlertsItemScopeApplication {
        /**
         * Name of the application
         */
        name: string;
        /**
         * URL to the application
         */
        url: string;
    }

    export interface GetHealthAlertsItemScopeDevice {
        /**
         * Clients related to the device
         */
        clients: outputs.networks.GetHealthAlertsItemScopeDeviceClient[];
        /**
         * Lldp information
         */
        lldp: outputs.networks.GetHealthAlertsItemScopeDeviceLldp;
        /**
         * The mac address of the device
         */
        mac: string;
        /**
         * Name of the device
         */
        name: string;
        /**
         * Product type of the device
         */
        productType: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * URL to the device
         */
        url: string;
    }

    export interface GetHealthAlertsItemScopeDeviceClient {
        /**
         * Mac address of the client
         */
        mac: string;
    }

    export interface GetHealthAlertsItemScopeDeviceLldp {
        /**
         * Port Id
         */
        portId: string;
    }

    export interface GetHealthAlertsItemScopePeer {
        /**
         * Network of the peer
         */
        network: outputs.networks.GetHealthAlertsItemScopePeerNetwork;
        /**
         * URL to the peer
         */
        url: string;
    }

    export interface GetHealthAlertsItemScopePeerNetwork {
        /**
         * Id of the network
         */
        id: string;
        /**
         * Name of the network
         */
        name: string;
    }

    export interface GetInsightApplicationsHealthByTimeItem {
        /**
         * The end time of the query range
         */
        endTs: string;
        /**
         * LAN goodput (Number of useful information bits delivered over a LAN per unit of time)
         */
        lanGoodput: number;
        /**
         * LAN latency in milliseconds
         */
        lanLatencyMs: number;
        /**
         * LAN loss percentage
         */
        lanLossPercent: number;
        /**
         * Number of clients
         */
        numClients: number;
        /**
         * Received kilobytes-per-second
         */
        recv: number;
        /**
         * Duration of the response, in milliseconds
         */
        responseDuration: number;
        /**
         * Sent kilobytes-per-second
         */
        sent: number;
        /**
         * The start time of the query range
         */
        startTs: string;
        /**
         * WAN goodput (Number of useful information bits delivered over a WAN per unit of time)
         */
        wanGoodput: number;
        /**
         * WAN latency in milliseconds
         */
        wanLatencyMs: number;
        /**
         * WAN loss percentage
         */
        wanLossPercent: number;
    }

    export interface GetMerakiAuthUsersItem {
        /**
         * Authorization type for user.
         */
        accountType: string;
        /**
         * User authorization info
         */
        authorizations: outputs.networks.GetMerakiAuthUsersItemAuthorization[];
        /**
         * Creation time of the user
         */
        createdAt: string;
        /**
         * Email address of the user
         */
        email: string;
        /**
         * Meraki auth user id
         */
        id: string;
        /**
         * Whether or not the user is a Dashboard administrator
         */
        isAdmin: boolean;
        /**
         * Name of the user
         */
        name: string;
    }

    export interface GetMerakiAuthUsersItemAuthorization {
        /**
         * User is authorized by the account email address
         */
        authorizedByEmail: string;
        /**
         * User is authorized by the account name
         */
        authorizedByName: string;
        /**
         * Authorized zone of the user
         */
        authorizedZone: string;
        /**
         * Authorization expiration time
         */
        expiresAt: string;
        /**
         * SSID number
         */
        ssidNumber: number;
    }

    export interface GetNetflowItem {
        /**
         * The IPv4 address of the NetFlow collector.
         */
        collectorIp: string;
        /**
         * The port that the NetFlow collector will be listening on.
         */
        collectorPort: number;
        /**
         * The port that the Encrypted Traffic Analytics collector will be listening on.
         */
        etaDstPort: number;
        /**
         * Boolean indicating whether Encrypted Traffic Analytics is enabled (true) or disabled (false).
         */
        etaEnabled: boolean;
        /**
         * Boolean indicating whether NetFlow traffic reporting is enabled (true) or disabled (false).
         */
        reportingEnabled: boolean;
    }

    export interface GetPiiPiiKeysItem {
        n1234: outputs.networks.GetPiiPiiKeysItemN1234;
    }

    export interface GetPiiPiiKeysItemN1234 {
        bluetoothMacs: string[];
        emails: string[];
        imeis: string[];
        macs: string[];
        serials: string[];
        usernames: string[];
    }

    export interface GetPiiRequestsItem {
        /**
         * The request's completion time
         */
        completedAt: number;
        /**
         * The request's creation time
         */
        createdAt: number;
        /**
         * The stringified array of datasets related to the provided key that should be deleted.
         */
        datasets: string;
        /**
         * The network or organization identifier
         */
        id: string;
        /**
         * The MAC address of the PII request
         */
        mac: string;
        /**
         * The network identifier
         */
        networkId: string;
        /**
         * If the data returned is organization-wide. False indicates the data is network-wide.
         */
        organizationWide: boolean;
        /**
         * The status of the PII request
         */
        status: string;
        /**
         * The type of PII request
         */
        type: string;
    }

    export interface GetPiiSmDevicesForKeyItem {
        n1234s: string[];
    }

    export interface GetPiiSmOwnersForKeyItem {
        n1234s: string[];
    }

    export interface GetPoliciesByClientItem {
        /**
         * Assigned policies
         */
        assigneds: outputs.networks.GetPoliciesByClientItemAssigned[];
        /**
         * ID of client
         */
        clientId: string;
        /**
         * Name of client
         */
        name: string;
    }

    export interface GetPoliciesByClientItemAssigned {
        /**
         * id of policy
         */
        groupPolicyId: string;
        /**
         * name of policy
         */
        name: string;
        /**
         * ssid
         */
        ssids: outputs.networks.GetPoliciesByClientItemAssignedSsid[];
        /**
         * type of policy
         */
        type: string;
    }

    export interface GetPoliciesByClientItemAssignedSsid {
        /**
         * number of ssid
         */
        ssidNumber: number;
    }

    export interface GetSensorAlertsCurrentOverviewByMetricItem {
        /**
         * Counts of currently alerting sensors, aggregated by alerting metric
         */
        counts: outputs.networks.GetSensorAlertsCurrentOverviewByMetricItemCounts;
        /**
         * List of metrics that are supported for alerts, based on available sensor devices in the network
         */
        supportedMetrics: string[];
    }

    export interface GetSensorAlertsCurrentOverviewByMetricItemCounts {
        /**
         * Number of sensors that are currently alerting due to apparent power readings
         */
        apparentPower: number;
        /**
         * Number of sensors that are currently alerting due to CO2 readings
         */
        co2: number;
        /**
         * Number of sensors that are currently alerting due to electrical current readings
         */
        current: number;
        /**
         * Number of sensors that are currently alerting due to an open door
         */
        door: number;
        /**
         * Number of sensors that are currently alerting due to frequency readings
         */
        frequency: number;
        /**
         * Number of sensors that are currently alerting due to humidity readings
         */
        humidity: number;
        /**
         * Number of sensors that are currently alerting due to indoor air quality readings
         */
        indoorAirQuality: number;
        /**
         * Object containing the number of sensors that are currently alerting due to noise readings
         */
        noise: outputs.networks.GetSensorAlertsCurrentOverviewByMetricItemCountsNoise;
        /**
         * Number of sensors that are currently alerting due to PM2.5 readings
         */
        pm25: number;
        /**
         * Number of sensors that are currently alerting due to power factor readings
         */
        powerFactor: number;
        /**
         * Number of sensors that are currently alerting due to real power readings
         */
        realPower: number;
        /**
         * Number of sensors that are currently alerting due to temperature readings
         */
        temperature: number;
        /**
         * Number of sensors that are currently alerting due to TVOC readings
         */
        tvoc: number;
        /**
         * Number of sensors that are currently alerting due to an upstream power outage
         */
        upstreamPower: number;
        /**
         * Number of sensors that are currently alerting due to voltage readings
         */
        voltage: number;
        /**
         * Number of sensors that are currently alerting due to the presence of water
         */
        water: number;
    }

    export interface GetSensorAlertsCurrentOverviewByMetricItemCountsNoise {
        /**
         * Number of sensors that are currently alerting due to ambient noise readings
         */
        ambient: number;
    }

    export interface GetSensorAlertsOverviewByMetricItem {
        /**
         * Counts of sensor alerts over the timespan, by reading metric
         */
        counts: outputs.networks.GetSensorAlertsOverviewByMetricItemCounts;
        /**
         * End of the timespan over which sensor alerts are counted
         */
        endTs: string;
        /**
         * Start of the timespan over which sensor alerts are counted
         */
        startTs: string;
    }

    export interface GetSensorAlertsOverviewByMetricItemCounts {
        /**
         * Number of sensor alerts that occurred due to apparent power readings
         */
        apparentPower: number;
        /**
         * Number of sensors that are currently alerting due to CO2 readings
         */
        co2: number;
        /**
         * Number of sensor alerts that occurred due to electrical current readings
         */
        current: number;
        /**
         * Number of sensor alerts that occurred due to an open door
         */
        door: number;
        /**
         * Number of sensor alerts that occurred due to frequency readings
         */
        frequency: number;
        /**
         * Number of sensor alerts that occurred due to humidity readings
         */
        humidity: number;
        /**
         * Number of sensor alerts that occurred due to indoor air quality readings
         */
        indoorAirQuality: number;
        /**
         * Object containing the number of sensor alerts that occurred due to noise readings
         */
        noise: outputs.networks.GetSensorAlertsOverviewByMetricItemCountsNoise;
        /**
         * Number of sensor alerts that occurred due to PM2.5 readings
         */
        pm25: number;
        /**
         * Number of sensor alerts that occurred due to power factor readings
         */
        powerFactor: number;
        /**
         * Number of sensor alerts that occurred due to real power readings
         */
        realPower: number;
        /**
         * Number of sensor alerts that occurred due to temperature readings
         */
        temperature: number;
        /**
         * Number of sensor alerts that occurred due to TVOC readings
         */
        tvoc: number;
        /**
         * Number of sensor alerts that occurred due to upstream power outages
         */
        upstreamPower: number;
        /**
         * Number of sensor alerts that occurred due to voltage readings
         */
        voltage: number;
        /**
         * Number of sensor alerts that occurred due to the presence of water
         */
        water: number;
    }

    export interface GetSensorAlertsOverviewByMetricItemCountsNoise {
        /**
         * Number of sensor alerts that occurred due to ambient noise readings
         */
        ambient: number;
    }

    export interface GetSensorAlertsProfilesItem {
        /**
         * List of conditions that will cause the profile to send an alert.
         */
        conditions: outputs.networks.GetSensorAlertsProfilesItemCondition[];
        /**
         * Name of the sensor alert profile.
         */
        name: string;
        /**
         * ID of the sensor alert profile.
         */
        profileId: string;
        /**
         * List of recipients that will receive the alert.
         */
        recipients: outputs.networks.GetSensorAlertsProfilesItemRecipients;
        /**
         * The sensor schedule to use with the alert profile.
         */
        schedule: outputs.networks.GetSensorAlertsProfilesItemSchedule;
        /**
         * List of device serials assigned to this sensor alert profile.
         */
        serials: string[];
    }

    export interface GetSensorAlertsProfilesItemCondition {
        /**
         * If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
         */
        direction: string;
        /**
         * Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
         */
        duration: number;
        /**
         * The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
         */
        metric: string;
        /**
         * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
         */
        threshold: outputs.networks.GetSensorAlertsProfilesItemConditionThreshold;
    }

    export interface GetSensorAlertsProfilesItemConditionThreshold {
        /**
         * Apparent power threshold. 'draw' must be provided.
         */
        apparentPower: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdApparentPower;
        /**
         * Electrical current threshold. 'level' must be provided.
         */
        current: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdCurrent;
        /**
         * Door open threshold. 'open' must be provided and set to true.
         */
        door: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdDoor;
        /**
         * Electrical frequency threshold. 'level' must be provided.
         */
        frequency: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdFrequency;
        /**
         * Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
         */
        humidity: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdHumidity;
        /**
         * Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
         */
        indoorAirQuality: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdIndoorAirQuality;
        /**
         * Noise threshold. 'ambient' must be provided.
         */
        noise: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdNoise;
        /**
         * PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        pm25: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdPm25;
        /**
         * Power factor threshold. 'percentage' must be provided.
         */
        powerFactor: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdPowerFactor;
        /**
         * Real power threshold. 'draw' must be provided.
         */
        realPower: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdRealPower;
        /**
         * Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
         */
        temperature: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdTemperature;
        /**
         * TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        tvoc: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdTvoc;
        /**
         * Upstream power threshold. 'outageDetected' must be provided and set to true.
         */
        upstreamPower: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdUpstreamPower;
        /**
         * Voltage threshold. 'level' must be provided.
         */
        voltage: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdVoltage;
        /**
         * Water detection threshold. 'present' must be provided and set to true.
         */
        water: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdWater;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdApparentPower {
        /**
         * Alerting threshold in volt-amps. Must be between 0 and 3750.
         */
        draw: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdCurrent {
        /**
         * Alerting threshold in amps. Must be between 0 and 15.
         */
        draw: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdDoor {
        /**
         * Alerting threshold for a door open event. Must be set to true.
         */
        open: boolean;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdFrequency {
        /**
         * Alerting threshold in hertz. Must be between 0 and 60.
         */
        level: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdHumidity {
        /**
         * Alerting threshold as a qualitative humidity level.
         */
        quality: string;
        /**
         * Alerting threshold in %RH.
         */
        relativePercentage: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdIndoorAirQuality {
        /**
         * Alerting threshold as a qualitative indoor air quality level.
         */
        quality: string;
        /**
         * Alerting threshold as indoor air quality score.
         */
        score: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdNoise {
        /**
         * Ambient noise threshold. One of 'level' or 'quality' must be provided.
         */
        ambient: outputs.networks.GetSensorAlertsProfilesItemConditionThresholdNoiseAmbient;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdNoiseAmbient {
        /**
         * Alerting threshold as adjusted decibels.
         */
        level: number;
        /**
         * Alerting threshold as a qualitative ambient noise level.
         */
        quality: string;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdPm25 {
        /**
         * Alerting threshold as PM2.5 parts per million.
         */
        concentration: number;
        /**
         * Alerting threshold as a qualitative PM2.5 level.
         */
        quality: string;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdPowerFactor {
        /**
         * Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
         */
        percentage: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdRealPower {
        /**
         * Alerting threshold in watts. Must be between 0 and 3750.
         */
        draw: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdTemperature {
        /**
         * Alerting threshold in degrees Celsius.
         */
        celsius: number;
        /**
         * Alerting threshold in degrees Fahrenheit.
         */
        fahrenheit: number;
        /**
         * Alerting threshold as a qualitative temperature level.
         */
        quality: string;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdTvoc {
        /**
         * Alerting threshold as TVOC micrograms per cubic meter.
         */
        concentration: number;
        /**
         * Alerting threshold as a qualitative TVOC level.
         */
        quality: string;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdUpstreamPower {
        /**
         * Alerting threshold for an upstream power event. Must be set to true.
         */
        outageDetected: boolean;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdVoltage {
        /**
         * Alerting threshold in volts. Must be between 0 and 250.
         */
        level: number;
    }

    export interface GetSensorAlertsProfilesItemConditionThresholdWater {
        /**
         * Alerting threshold for a water detection event. Must be set to true.
         */
        present: boolean;
    }

    export interface GetSensorAlertsProfilesItemRecipients {
        /**
         * A list of emails that will receive information about the alert.
         */
        emails: string[];
        /**
         * A list of webhook endpoint IDs that will receive information about the alert.
         */
        httpServerIds: string[];
        /**
         * A list of SMS numbers that will receive information about the alert.
         */
        smsNumbers: string[];
    }

    export interface GetSensorAlertsProfilesItemSchedule {
        /**
         * ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
         */
        id: string;
        /**
         * Name of the sensor schedule to use with the alert profile.
         */
        name: string;
    }

    export interface GetSensorMqttBrokersItem {
        /**
         * Specifies whether the broker is enabled for sensor data. Currently, only a single broker may be enabled for sensor data.
         */
        enabled: boolean;
        /**
         * ID of the MQTT Broker.
         */
        mqttBrokerId: string;
    }

    export interface GetSensorRelationshipsItem {
        /**
         * A sensor or gateway device in the network
         */
        device: outputs.networks.GetSensorRelationshipsItemDevice;
        /**
         * An object describing the relationships defined between the device and other devices
         */
        relationships: outputs.networks.GetSensorRelationshipsItemRelationships;
    }

    export interface GetSensorRelationshipsItemDevice {
        /**
         * The name of the device
         */
        name: string;
        /**
         * The product type of the device
         */
        productType: string;
        /**
         * The serial of the device
         */
        serial: string;
    }

    export interface GetSensorRelationshipsItemRelationships {
        /**
         * A role defined between an MT sensor and an MV camera that adds the camera's livestream to the sensor's details page. Snapshots from the camera will also appear in alert notifications that the sensor triggers.
         */
        livestream: outputs.networks.GetSensorRelationshipsItemRelationshipsLivestream;
    }

    export interface GetSensorRelationshipsItemRelationshipsLivestream {
        /**
         * An array of the related devices for the role
         */
        relatedDevices: outputs.networks.GetSensorRelationshipsItemRelationshipsLivestreamRelatedDevice[];
    }

    export interface GetSensorRelationshipsItemRelationshipsLivestreamRelatedDevice {
        /**
         * The product type of the related device
         */
        productType: string;
        /**
         * The serial of the related device
         */
        serial: string;
    }

    export interface GetSettingsItem {
        /**
         * A hash of FIPS options applied to the Network
         */
        fips: outputs.networks.GetSettingsItemFips;
        /**
         * A hash of Local Status page(s)' authentication options applied to the Network.
         */
        localStatusPage: outputs.networks.GetSettingsItemLocalStatusPage;
        /**
         * Enables / disables the local device status pages (\n\nmy.meraki.com, \n\n\n\nap.meraki.com, \n\n\n\nswitch.meraki.com, \n\n\n\nwired.meraki.com\n\n). Optional (defaults to false)
         */
        localStatusPageEnabled: boolean;
        /**
         * A hash of Named VLANs options applied to the Network.
         */
        namedVlans: outputs.networks.GetSettingsItemNamedVlans;
        /**
         * Enables / disables access to the device status page (\n\nhttp://[device's LAN IP])\n\n. Optional. Can only be set if localStatusPageEnabled is set to true
         */
        remoteStatusPageEnabled: boolean;
        /**
         * A hash of SecureConnect options applied to the Network.
         */
        securePort: outputs.networks.GetSettingsItemSecurePort;
    }

    export interface GetSettingsItemFips {
        /**
         * Enables / disables FIPS on the network.
         */
        enabled: boolean;
    }

    export interface GetSettingsItemLocalStatusPage {
        /**
         * A hash of Local Status page(s)' authentication options applied to the Network.
         */
        authentication: outputs.networks.GetSettingsItemLocalStatusPageAuthentication;
    }

    export interface GetSettingsItemLocalStatusPageAuthentication {
        /**
         * Enables / disables the authentication on Local Status page(s).
         */
        enabled: boolean;
        /**
         * The username used for Local Status Page(s).
         */
        username: string;
    }

    export interface GetSettingsItemNamedVlans {
        /**
         * Enables / disables Named VLANs on the Network.
         */
        enabled: boolean;
    }

    export interface GetSettingsItemSecurePort {
        /**
         * Enables / disables SecureConnect on the network. Optional.
         */
        enabled: boolean;
    }

    export interface GetSmBypassActivationLockAttemptsItem {
        data: outputs.networks.GetSmBypassActivationLockAttemptsItemData;
        id: string;
        status: string;
    }

    export interface GetSmBypassActivationLockAttemptsItemData {
        status2090938209: outputs.networks.GetSmBypassActivationLockAttemptsItemDataStatus2090938209;
        status38290139892: outputs.networks.GetSmBypassActivationLockAttemptsItemDataStatus38290139892;
    }

    export interface GetSmBypassActivationLockAttemptsItemDataStatus2090938209 {
        errors: string[];
        success: boolean;
    }

    export interface GetSmBypassActivationLockAttemptsItemDataStatus38290139892 {
        success: boolean;
    }

    export interface GetSmDevicesCellularUsageHistoryItem {
        /**
         * The amount of cellular data received by the device.
         */
        received: number;
        /**
         * The amount of cellular sent received by the device.
         */
        sent: number;
        /**
         * When the cellular usage data was collected.
         */
        ts: string;
    }

    export interface GetSmDevicesCertsItem {
        /**
         * The PEM of the certificate.
         */
        certPem: string;
        /**
         * The Meraki managed device Id.
         */
        deviceId: string;
        /**
         * The Meraki Id of the certificate record.
         */
        id: string;
        /**
         * The certificate issuer.
         */
        issuer: string;
        /**
         * The name of the certificate.
         */
        name: string;
        /**
         * The date after which the certificate is no longer valid.
         */
        notValidAfter: string;
        /**
         * The date before which the certificate is not valid.
         */
        notValidBefore: string;
        /**
         * The subject of the certificate.
         */
        subject: string;
    }

    export interface GetSmDevicesConnectivityItem {
        /**
         * When the device was first seen as connected to the internet in each connection.
         */
        firstSeenAt: string;
        /**
         * When the device was last seen as connected to the internet in each connection.
         */
        lastSeenAt: string;
    }

    export interface GetSmDevicesDesktopLogsItem {
        /**
         * The IP address of the DCHP Server.
         */
        dhcpServer: string;
        /**
         * The DNS Server during the connection.
         */
        dnsServer: string;
        /**
         * The gateway IP the device was connected to.
         */
        gateway: string;
        /**
         * The IP of the device during connection.
         */
        ip: string;
        /**
         * The time the data was measured at.
         */
        measuredAt: string;
        /**
         * The network device for the device used for connection.
         */
        networkDevice: string;
        /**
         * The network driver for the device.
         */
        networkDriver: string;
        /**
         * The network max transmission unit.
         */
        networkMtu: string;
        /**
         * The public IP address of the device.
         */
        publicIp: string;
        /**
         * The subnet of the device connection.
         */
        subnet: string;
        /**
         * The time the connection was logged.
         */
        ts: string;
        /**
         * The user during connection.
         */
        user: string;
        /**
         * The type of authentication used by the SSID.
         */
        wifiAuth: string;
        /**
         * The MAC of the access point the device is connected to.
         */
        wifiBssid: string;
        /**
         * Channel through which the connection is routing.
         */
        wifiChannel: string;
        /**
         * The wireless signal power level received by the device.
         */
        wifiNoise: string;
        /**
         * The Received Signal Strength Indicator for the device.
         */
        wifiRssi: string;
        /**
         * The name of the network the device is connected to.
         */
        wifiSsid: string;
    }

    export interface GetSmDevicesDeviceCommandLogsItem {
        /**
         * The type of command sent to the device.
         */
        action: string;
        /**
         * The Meraki dashboard user who initiated the command.
         */
        dashboardUser: string;
        /**
         * A JSON string object containing command details.
         */
        details: string;
        /**
         * The name of the device to which the command is sent.
         */
        name: string;
        /**
         * The time the command was sent to the device.
         */
        ts: string;
    }

    export interface GetSmDevicesDeviceProfilesItem {
        /**
         * The Meraki managed device Id.
         */
        deviceId: string;
        /**
         * The numerical Meraki Id of the profile.
         */
        id: string;
        /**
         * A boolean indicating if the profile is encrypted.
         */
        isEncrypted: boolean;
        /**
         * Whether or not the profile is managed by Meraki.
         */
        isManaged: boolean;
        /**
         * The name of the profile.
         */
        name: string;
        /**
         * A string containing a JSON object with the profile data.
         */
        profileData: string;
        /**
         * The identifier of the profile.
         */
        profileIdentifier: string;
        /**
         * The verison of the profile.
         */
        version: string;
    }

    export interface GetSmDevicesItem {
        /**
         * The Meraki Id of the device record.
         */
        id: string;
        /**
         * The IP address of the device.
         */
        ip: string;
        /**
         * The name of the device.
         */
        name: string;
        /**
         * Notes associated with the device.
         */
        notes: string;
        /**
         * The name of the device OS.
         */
        osName: string;
        /**
         * The device serial.
         */
        serial: string;
        /**
         * The device serial number.
         */
        serialNumber: string;
        /**
         * The name of the SSID the device was last connected to.
         */
        ssid: string;
        /**
         * The device model.
         */
        systemModel: string;
        /**
         * An array of tags associated with the device.
         */
        tags: string[];
        /**
         * The UUID of the device.
         */
        uuid: string;
        /**
         * The MAC of the device.
         */
        wifiMac: string;
    }

    export interface GetSmDevicesNetworkAdaptersItem {
        /**
         * The IP address of the DCHP Server.
         */
        dhcpServer: string;
        /**
         * The IP address of the DNS Server.
         */
        dnsServer: string;
        /**
         * The IP address of the Gateway.
         */
        gateway: string;
        /**
         * The Meraki Id of the network adapter record.
         */
        id: string;
        /**
         * The IP address of the network adapter.
         */
        ip: string;
        /**
         * The MAC associated with the network adapter.
         */
        mac: string;
        /**
         * The name of the newtwork adapter.
         */
        name: string;
        /**
         * The subnet for the network adapter.
         */
        subnet: string;
    }

    export interface GetSmDevicesPerformanceHistoryItem {
        /**
         * The percentage of CPU used as a decimal format.
         */
        cpuPercentUsed: number;
        /**
         * An object containing disk usage details.
         */
        diskUsage: outputs.networks.GetSmDevicesPerformanceHistoryItemDiskUsage;
        /**
         * The active RAM on the device.
         */
        memActive: number;
        /**
         * Memory that is not yet in use by the system.
         */
        memFree: number;
        /**
         * The inactive RAM on the device.
         */
        memInactive: number;
        /**
         * Memory used for core OS functions on the device.
         */
        memWired: number;
        /**
         * Network bandwith received.
         */
        networkReceived: number;
        /**
         * Network bandwith transmitted.
         */
        networkSent: number;
        /**
         * The amount of space being used on the startup disk to swap unused files to and from RAM.
         */
        swapUsed: number;
        /**
         * The time at which the performance was measured.
         */
        ts: string;
    }

    export interface GetSmDevicesPerformanceHistoryItemDiskUsage {
        /**
         * An object containing current disk usage details.
         */
        c: outputs.networks.GetSmDevicesPerformanceHistoryItemDiskUsageC;
    }

    export interface GetSmDevicesPerformanceHistoryItemDiskUsageC {
        /**
         * The available disk space.
         */
        space: number;
        /**
         * The used disk space.
         */
        used: number;
    }

    export interface GetSmDevicesSecurityCentersItem {
        /**
         * The Meraki managed application Id for this record on a particular device.
         */
        appId: string;
        /**
         * The size of the software bundle.
         */
        bundleSize: number;
        /**
         * When the Meraki record for the software was created.
         */
        createdAt: string;
        /**
         * The Meraki managed device Id.
         */
        deviceId: string;
        /**
         * The size of the data stored in the application.
         */
        dynamicSize: number;
        /**
         * The Meraki software Id.
         */
        id: string;
        /**
         * Software bundle identifier.
         */
        identifier: string;
        /**
         * When the Software was installed on the device.
         */
        installedAt: string;
        /**
         * A boolean indicating whether or not an iOS redemption code was used.
         */
        iosRedemptionCode: boolean;
        /**
         * A boolean indicating whether or not the software is managed by Meraki.
         */
        isManaged: boolean;
        /**
         * The itunes numerical identifier.
         */
        itunesId: string;
        /**
         * The license key associated with this software installation.
         */
        licenseKey: string;
        /**
         * The name of the software.
         */
        name: string;
        /**
         * The path on the device where the software record is located.
         */
        path: string;
        /**
         * The redemption code used for this software.
         */
        redemptionCode: number;
        /**
         * Short version notation for the software.
         */
        shortVersion: string;
        /**
         * The management status of the software.
         */
        status: string;
        /**
         * A boolean indicating this software record should be installed on the associated device.
         */
        toInstall: boolean;
        /**
         * A boolean indicating this software record should be uninstalled on the associated device.
         */
        toUninstall: boolean;
        /**
         * When the record was uninstalled from the device.
         */
        uninstalledAt: string;
        /**
         * When the record was last updated by Meraki.
         */
        updatedAt: string;
        /**
         * The vendor of the software.
         */
        vendor: string;
        /**
         * Full version notation for the software.
         */
        version: string;
    }

    export interface GetSmDevicesWlanListsItem {
        /**
         * When the Meraki record for the wlanList was created.
         */
        createdAt: string;
        /**
         * The Meraki managed Id of the wlanList record.
         */
        id: string;
        /**
         * An XML string containing the WLAN List for the device.
         */
        xml: string;
    }

    export interface GetSmProfilesItem {
        /**
         * Description of a profile.
         */
        description: string;
        /**
         * ID of a profile.
         */
        id: string;
        /**
         * Name of a profile.
         */
        name: string;
        /**
         * Payloads in the profile.
         */
        payloadTypes: string[];
        /**
         * Scope of a profile.
         */
        scope: string;
        /**
         * Tags of a profile.
         */
        tags: string[];
    }

    export interface GetSmTargetGroupsItem {
        /**
         * The ID of this target group.
         */
        id: string;
        /**
         * The name of this target group.
         */
        name: string;
        /**
         * The scope of the target group.
         */
        scope: string;
        /**
         * The tags of the target group.
         */
        tags: string[];
    }

    export interface GetSmTrustedAccessConfigsItem {
        /**
         * time that access ends
         */
        accessEndAt: string;
        /**
         * time that access starts
         */
        accessStartAt: string;
        /**
         * Optional email text
         */
        additionalEmailText: string;
        /**
         * device ID
         */
        id: string;
        /**
         * device name
         */
        name: string;
        /**
         * Time before access expiration reminder email sends
         */
        notifyTimeBeforeAccessEnds: number;
        /**
         * scope
         */
        scope: string;
        /**
         * Send Email Notifications
         */
        sendExpirationEmails: boolean;
        /**
         * SSID name
         */
        ssidName: string;
        /**
         * device tags
         */
        tags: string[];
        /**
         * type of access period, either a static range or a dynamic period
         */
        timeboundType: string;
    }

    export interface GetSmUserAccessDevicesItem {
        /**
         * user email
         */
        email: string;
        /**
         * device ID
         */
        id: string;
        /**
         * mac address
         */
        mac: string;
        /**
         * device name
         */
        name: string;
        /**
         * system type
         */
        systemType: string;
        /**
         * device tags
         */
        tags: string[];
        /**
         * Array of trusted access configs
         */
        trustedAccessConnections: outputs.networks.GetSmUserAccessDevicesItemTrustedAccessConnection[];
        /**
         * username
         */
        username: string;
    }

    export interface GetSmUserAccessDevicesItemTrustedAccessConnection {
        /**
         * time that config was downloaded
         */
        downloadedAt: string;
        /**
         * time of last connection
         */
        lastConnectedAt: string;
        /**
         * time that SCEP completed
         */
        scepCompletedAt: string;
        /**
         * config id
         */
        trustedAccessConfigId: string;
    }

    export interface GetSmUsersDeviceProfilesItem {
        /**
         * The Meraki managed device Id.
         */
        deviceId: string;
        /**
         * The numerical Meraki Id of the profile.
         */
        id: string;
        /**
         * A boolean indicating if the profile is encrypted.
         */
        isEncrypted: boolean;
        /**
         * Whether or not the profile is managed by Meraki.
         */
        isManaged: boolean;
        /**
         * The name of the profile.
         */
        name: string;
        /**
         * A string containing a JSON object with the profile data.
         */
        profileData: string;
        /**
         * The identifier of the profile.
         */
        profileIdentifier: string;
        /**
         * The verison of the profile.
         */
        version: string;
    }

    export interface GetSmUsersItem {
        /**
         * Active Directory Groups the user belongs to.
         */
        adGroups: string[];
        /**
         * Apple School Manager Groups the user belongs to.
         */
        asmGroups: string[];
        /**
         * Azure Active Directory Groups the user belongs to.
         */
        azureAdGroups: string[];
        /**
         * The user display name.
         */
        displayName: string;
        /**
         * User email.
         */
        email: string;
        /**
         * User full name.
         */
        fullName: string;
        /**
         * A boolean indicating if the user has an associated identity certificate..
         */
        hasIdentityCertificate: boolean;
        /**
         * A boolean denoting if the user has a password associated with the record.
         */
        hasPassword: boolean;
        /**
         * The Meraki managed Id of the user record.
         */
        id: string;
        /**
         * Whether the user was created using an external integration, or via the Meraki Dashboard.
         */
        isExternal: boolean;
        /**
         * SAML Groups the user belongs to.
         */
        samlGroups: string[];
        /**
         * The set of tags the user is scoped to.
         */
        tags: string;
        /**
         * The url where the users thumbnail is hosted.
         */
        userThumbnail: string;
        /**
         * The users username.
         */
        username: string;
    }

    export interface GetSmUsersSoftwaresItem {
        /**
         * The Meraki managed application Id for this record on a particular device.
         */
        appId: string;
        /**
         * The size of the software bundle.
         */
        bundleSize: number;
        /**
         * When the Meraki record for the software was created.
         */
        createdAt: string;
        /**
         * The Meraki managed device Id.
         */
        deviceId: string;
        /**
         * The size of the data stored in the application.
         */
        dynamicSize: number;
        /**
         * The Meraki software Id.
         */
        id: string;
        /**
         * Software bundle identifier.
         */
        identifier: string;
        /**
         * When the Software was installed on the device.
         */
        installedAt: string;
        /**
         * A boolean indicating whether or not an iOS redemption code was used.
         */
        iosRedemptionCode: boolean;
        /**
         * A boolean indicating whether or not the software is managed by Meraki.
         */
        isManaged: boolean;
        /**
         * The itunes numerical identifier.
         */
        itunesId: string;
        /**
         * The license key associated with this software installation.
         */
        licenseKey: string;
        /**
         * The name of the software.
         */
        name: string;
        /**
         * The path on the device where the software record is located.
         */
        path: string;
        /**
         * The redemption code used for this software.
         */
        redemptionCode: number;
        /**
         * Short version notation for the software.
         */
        shortVersion: string;
        /**
         * The management status of the software.
         */
        status: string;
        /**
         * A boolean indicating this software record should be installed on the associated device.
         */
        toInstall: boolean;
        /**
         * A boolean indicating this software record should be uninstalled on the associated device.
         */
        toUninstall: boolean;
        /**
         * When the record was uninstalled from the device.
         */
        uninstalledAt: string;
        /**
         * When the record was last updated by Meraki.
         */
        updatedAt: string;
        /**
         * The vendor of the software.
         */
        vendor: string;
        /**
         * Full version notation for the software.
         */
        version: string;
    }

    export interface GetSnmpItem {
        /**
         * The type of SNMP access. Can be one of 'none' (disabled), 'community' (V1/V2c), or 'users' (V3).
         */
        access: string;
        /**
         * SNMP community string if access is 'community'.
         */
        communityString: string;
        /**
         * SNMP settings if access is 'users'.
         */
        users: outputs.networks.GetSnmpItemUser[];
    }

    export interface GetSnmpItemUser {
        /**
         * The passphrase for the SNMP user.
         */
        passphrase: string;
        /**
         * The username for the SNMP user.
         */
        username: string;
    }

    export interface GetSwitchAccessControlListsItem {
        /**
         * An ordered array of the access control list rules
         */
        rules: outputs.networks.GetSwitchAccessControlListsItemRule[];
    }

    export interface GetSwitchAccessControlListsItemRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Destination IP address (in IP or CIDR notation)
         */
        dstCidr: string;
        /**
         * Destination port
         */
        dstPort: string;
        /**
         * IP address version
         */
        ipVersion: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol
         */
        protocol: string;
        /**
         * Source IP address (in IP or CIDR notation)
         */
        srcCidr: string;
        /**
         * Source port
         */
        srcPort: string;
        /**
         * ncoming traffic VLAN
         */
        vlan: string;
    }

    export interface GetSwitchAccessPoliciesItem {
        /**
         * Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
         */
        accessPolicyType: string;
        /**
         * Counts associated with the access policy
         */
        counts: outputs.networks.GetSwitchAccessPoliciesItemCounts;
        /**
         * 802.1x Settings
         */
        dot1x: outputs.networks.GetSwitchAccessPoliciesItemDot1x;
        /**
         * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
         */
        guestPortBouncing: boolean;
        /**
         * ID for the guest VLAN allow unauthorized devices access to limited network resources
         */
        guestVlanId: number;
        /**
         * Choose the Host Mode for the access policy.
         */
        hostMode: string;
        /**
         * Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
         */
        increaseAccessSpeed: boolean;
        /**
         * Name of the access policy
         */
        name: string;
        /**
         * Object for RADIUS Settings
         */
        radius: outputs.networks.GetSwitchAccessPoliciesItemRadius;
        /**
         * Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
         */
        radiusAccountingEnabled: boolean;
        /**
         * List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
         */
        radiusAccountingServers: outputs.networks.GetSwitchAccessPoliciesItemRadiusAccountingServer[];
        /**
         * Change of authentication for RADIUS re-authentication and disconnection
         */
        radiusCoaSupportEnabled: boolean;
        /**
         * Acceptable values are *''* for None, or *'11'* for Group Policies ACL
         */
        radiusGroupAttribute: string;
        /**
         * List of RADIUS servers to require connecting devices to authenticate against before granting network access
         */
        radiusServers: outputs.networks.GetSwitchAccessPoliciesItemRadiusServer[];
        /**
         * If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
         */
        radiusTestingEnabled: boolean;
        /**
         * Enable to restrict access for clients to a responseObjectific set of IP addresses or hostnames prior to authentication
         */
        urlRedirectWalledGardenEnabled: boolean;
        /**
         * IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
         */
        urlRedirectWalledGardenRanges: string[];
        /**
         * CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
         */
        voiceVlanClients: boolean;
    }

    export interface GetSwitchAccessPoliciesItemCounts {
        /**
         * Counts associated with ports
         */
        ports: outputs.networks.GetSwitchAccessPoliciesItemCountsPorts;
    }

    export interface GetSwitchAccessPoliciesItemCountsPorts {
        /**
         * Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
         */
        withThisPolicy: number;
    }

    export interface GetSwitchAccessPoliciesItemDot1x {
        /**
         * Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
         */
        controlDirection: string;
    }

    export interface GetSwitchAccessPoliciesItemRadius {
        /**
         * Critical auth settings for when authentication is rejected by the RADIUS server
         */
        criticalAuth: outputs.networks.GetSwitchAccessPoliciesItemRadiusCriticalAuth;
        /**
         * VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        failedAuthVlanId: number;
        /**
         * Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
         */
        reAuthenticationInterval: number;
    }

    export interface GetSwitchAccessPoliciesItemRadiusAccountingServer {
        /**
         * Public IP address of the RADIUS accounting server
         */
        host: string;
        /**
         * UDP port that the RADIUS Accounting server listens on for access requests
         */
        port: number;
    }

    export interface GetSwitchAccessPoliciesItemRadiusCriticalAuth {
        /**
         * VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        dataVlanId: number;
        /**
         * Enable to suspend port bounce when RADIUS servers are unreachable
         */
        suspendPortBounce: boolean;
        /**
         * VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        voiceVlanId: number;
    }

    export interface GetSwitchAccessPoliciesItemRadiusServer {
        /**
         * Public IP address of the RADIUS server
         */
        host: string;
        /**
         * UDP port that the RADIUS server listens on for access requests
         */
        port: number;
    }

    export interface GetSwitchAlternateManagementInterfaceItem {
        /**
         * Boolean value to enable or disable AMI configuration. If enabled, VLAN and protocols must be set
         */
        enabled: boolean;
        /**
         * Can be one or more of the following values: 'radius', 'snmp' or 'syslog'
         */
        protocols: string[];
        /**
         * Array of switch serial number and IP assignment. If parameter is present, it cannot have empty body. Note: switches parameter is not applicable for template networks, in other words, do not put 'switches' in the body when updating template networks. Also, an empty 'switches' array will remove all previous assignments
         */
        switches: outputs.networks.GetSwitchAlternateManagementInterfaceItemSwitch[];
        /**
         * Alternate management VLAN, must be between 1 and 4094
         */
        vlanId: number;
    }

    export interface GetSwitchAlternateManagementInterfaceItemSwitch {
        /**
         * Switch alternative management IP. To remove a prior IP setting, provide an empty string
         */
        alternateManagementIp: string;
        /**
         * Switch gateway must be in IP format. Only and must be specified for Polaris switches
         */
        gateway: string;
        /**
         * Switch serial number
         */
        serial: string;
        /**
         * Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
         */
        subnetMask: string;
    }

    export interface GetSwitchDhcpServerPolicyArpInspectionTrustedServersItem {
        /**
         * IPv4 attributes of the trusted server.
         */
        ipv4: outputs.networks.GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemIpv4;
        /**
         * Mac address of the trusted server.
         */
        mac: string;
        /**
         * ID of the trusted server.
         */
        trustedServerId: string;
        /**
         * Vlan ID of the trusted server.
         */
        vlan: number;
    }

    export interface GetSwitchDhcpServerPolicyArpInspectionTrustedServersItemIpv4 {
        /**
         * IPv4 address of the trusted server.
         */
        address: string;
    }

    export interface GetSwitchDhcpServerPolicyArpInspectionWarningsByDeviceItem {
        /**
         * Whether this switch has a trusted DAI port. Always false if supportsInspection is false.
         */
        hasTrustedPort: boolean;
        /**
         * Switch name.
         */
        name: string;
        /**
         * Switch serial.
         */
        serial: string;
        /**
         * Whether this switch supports Dynamic ARP Inspection.
         */
        supportsInspection: boolean;
        /**
         * Url link to switch.
         */
        url: string;
    }

    export interface GetSwitchDhcpServerPolicyItem {
        /**
         * Email alert settings for DHCP servers
         */
        alerts: outputs.networks.GetSwitchDhcpServerPolicyItemAlerts;
        /**
         * List the MAC addresses of DHCP servers to permit on the network when defaultPolicy is set
         * to block.An empty array will clear the entries.
         */
        allowedServers: string[];
        /**
         * Dynamic ARP Inspection settings
         */
        arpInspection: outputs.networks.GetSwitchDhcpServerPolicyItemArpInspection;
        /**
         * List the MAC addresses of DHCP servers to block on the network when defaultPolicy is set
         * to allow.An empty array will clear the entries.
         */
        blockedServers: string[];
        /**
         * 'allow' or 'block' new DHCP servers. Default value is 'allow'.
         */
        defaultPolicy: string;
    }

    export interface GetSwitchDhcpServerPolicyItemAlerts {
        /**
         * Alert settings for DHCP servers
         */
        email: outputs.networks.GetSwitchDhcpServerPolicyItemAlertsEmail;
    }

    export interface GetSwitchDhcpServerPolicyItemAlertsEmail {
        /**
         * When enabled, send an email if a new DHCP server is seen. Default value is false.
         */
        enabled: boolean;
    }

    export interface GetSwitchDhcpServerPolicyItemArpInspection {
        /**
         * Enable or disable Dynamic ARP Inspection on the network. Default value is false.
         */
        enabled: boolean;
        /**
         * List of switch models that does not support dynamic ARP inspection
         */
        unsupportedModels: string[];
    }

    export interface GetSwitchDhcpV4ServersSeenItem {
        /**
         * Client id of the server if available.
         */
        clientId: string;
        /**
         * Attributes of the server when it's a device.
         */
        device: outputs.networks.GetSwitchDhcpV4ServersSeenItemDevice;
        /**
         * IPv4 attributes of the server.
         */
        ipv4: outputs.networks.GetSwitchDhcpV4ServersSeenItemIpv4;
        /**
         * Whether the server is allowed or blocked. Always true for configured servers.
         */
        isAllowed: boolean;
        /**
         * Whether the server is configured.
         */
        isConfigured: boolean;
        /**
         * Attributes of the server's last ack.
         */
        lastAck: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastAck;
        /**
         * Last packet the server received.
         */
        lastPacket: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacket;
        /**
         * Last time the server was seen.
         */
        lastSeenAt: string;
        /**
         * Mac address of the server.
         */
        mac: string;
        /**
         * Devices that saw the server.
         */
        seenBies: outputs.networks.GetSwitchDhcpV4ServersSeenItemSeenBy[];
        /**
         * server type. Can be a 'device', 'stack', or 'discovered' (i.e client).
         */
        type: string;
        /**
         * Vlan id of the server.
         */
        vlan: number;
    }

    export interface GetSwitchDhcpV4ServersSeenItemDevice {
        /**
         * Interface attributes of the server. Only for configured servers.
         */
        interface: outputs.networks.GetSwitchDhcpV4ServersSeenItemDeviceInterface;
        /**
         * Device name.
         */
        name: string;
        /**
         * Device serial.
         */
        serial: string;
        /**
         * Url link to device.
         */
        url: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemDeviceInterface {
        /**
         * Interface name.
         */
        name: string;
        /**
         * Url link to interface.
         */
        url: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemIpv4 {
        /**
         * IPv4 address of the server.
         */
        address: string;
        /**
         * IPv4 gateway address of the server.
         */
        gateway: string;
        /**
         * Subnet of the server.
         */
        subnet: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastAck {
        /**
         * IPv4 attributes of the last ack.
         */
        ipv4: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastAckIpv4;
        /**
         * Last time the server was acked.
         */
        ts: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastAckIpv4 {
        /**
         * IPv4 address of the last ack.
         */
        address: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacket {
        /**
         * Destination of the packet.
         */
        destination: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketDestination;
        /**
         * Additional ethernet attributes of the packet.
         */
        ethernet: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketEthernet;
        /**
         * DHCP-specific fields of the packet.
         */
        fields: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketFields;
        /**
         * Additional IP attributes of the packet.
         */
        ip: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketIp;
        /**
         * Source of the packet.
         */
        source: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketSource;
        /**
         * Packet type.
         */
        type: string;
        /**
         * UDP attributes of the packet.
         */
        udp: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketUdp;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketDestination {
        /**
         * Destination ipv4 attributes of the packet.
         */
        ipv4: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketDestinationIpv4;
        /**
         * Destination mac address of the packet.
         */
        mac: string;
        /**
         * Destination port of the packet.
         */
        port: number;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketDestinationIpv4 {
        /**
         * Destination ipv4 address of the packet.
         */
        address: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketEthernet {
        /**
         * Ethernet type of the packet.
         */
        type: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketFields {
        /**
         * Client hardware address of the packet.
         */
        chaddr: string;
        /**
         * Client IP address of the packet.
         */
        ciaddr: string;
        /**
         * Packet flags.
         */
        flags: string;
        /**
         * Gateway IP address of the packet.
         */
        giaddr: string;
        /**
         * Hardware length of the packet.
         */
        hlen: number;
        /**
         * Number of hops the packet took.
         */
        hops: number;
        /**
         * Hardware type code of the packet.
         */
        htype: number;
        /**
         * Magic cookie of the packet.
         */
        magicCookie: string;
        /**
         * Operation code of the packet.
         */
        op: number;
        /**
         * Additional DHCP options of the packet.
         */
        options: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketFieldsOption[];
        /**
         * Number of seconds since receiving the packet.
         */
        secs: number;
        /**
         * Server IP address of the packet.
         */
        siaddr: string;
        /**
         * Server identifier address of the packet.
         */
        sname: string;
        /**
         * Transaction id of the packet.
         */
        xid: string;
        /**
         * Assigned IP address of the packet.
         */
        yiaddr: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketFieldsOption {
        /**
         * Option name.
         */
        name: string;
        /**
         * Option value.
         */
        value: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketIp {
        /**
         * DSCP attributes of the packet.
         */
        dscp: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketIpDscp;
        /**
         * IP header length of the packet.
         */
        headerLength: number;
        /**
         * IP ID of the packet.
         */
        id: string;
        /**
         * IP length of the packet.
         */
        length: number;
        /**
         * IP protocol number of the packet.
         */
        protocol: number;
        /**
         * Time to live of the packet.
         */
        ttl: number;
        /**
         * IP version of the packet.
         */
        version: number;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketIpDscp {
        /**
         * ECN number of the packet.
         */
        ecn: number;
        /**
         * DSCP tag number of the packet.
         */
        tag: number;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketSource {
        /**
         * Source ipv4 attributes of the packet.
         */
        ipv4: outputs.networks.GetSwitchDhcpV4ServersSeenItemLastPacketSourceIpv4;
        /**
         * Source mac address of the packet.
         */
        mac: string;
        /**
         * Source port of the packet.
         */
        port: number;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketSourceIpv4 {
        /**
         * Source ipv4 address of the packet.
         */
        address: string;
    }

    export interface GetSwitchDhcpV4ServersSeenItemLastPacketUdp {
        /**
         * UDP checksum of the packet.
         */
        checksum: string;
        /**
         * UDP length of the packet.
         */
        length: number;
    }

    export interface GetSwitchDhcpV4ServersSeenItemSeenBy {
        /**
         * Device name.
         */
        name: string;
        /**
         * Device serial.
         */
        serial: string;
        /**
         * Url link to device.
         */
        url: string;
    }

    export interface GetSwitchDscpToCosMappingsItem {
        /**
         * An array of DSCP to CoS mappings. An empty array will reset the mappings to default.
         */
        mappings: outputs.networks.GetSwitchDscpToCosMappingsItemMapping[];
    }

    export interface GetSwitchDscpToCosMappingsItemMapping {
        /**
         * The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
         */
        cos: number;
        /**
         * The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
         */
        dscp: number;
        /**
         * Label for the mapping (optional).
         */
        title: string;
    }

    export interface GetSwitchLinkAggregationsItem {
        id: string;
        switchPorts: outputs.networks.GetSwitchLinkAggregationsItemSwitchPort[];
    }

    export interface GetSwitchLinkAggregationsItemSwitchPort {
        portId: string;
        serial: string;
    }

    export interface GetSwitchMtuItem {
        /**
         * MTU size for the entire network. Default value is 9578.
         */
        defaultMtuSize: number;
        /**
         * Override MTU size for individual switches or switch templates.
         * An empty array will clear overrides.
         */
        overrides: outputs.networks.GetSwitchMtuItemOverride[];
    }

    export interface GetSwitchMtuItemOverride {
        /**
         * MTU size for the switches or switch templates.
         */
        mtuSize: number;
        /**
         * List of switch template IDs. Applicable only for template network.
         */
        switchProfiles: string[];
        /**
         * List of switch serials. Applicable only for switch network.
         */
        switches: string[];
    }

    export interface GetSwitchPortSchedulesItem {
        /**
         * Switch port schedule ID
         */
        id: string;
        /**
         * Switch port schedule name
         */
        name: string;
        /**
         * Network ID
         */
        networkId: string;
        /**
         * Port schedule
         */
        portSchedule: outputs.networks.GetSwitchPortSchedulesItemPortSchedule;
    }

    export interface GetSwitchPortSchedulesItemPortSchedule {
        /**
         * Friday schedule
         */
        friday: outputs.networks.GetSwitchPortSchedulesItemPortScheduleFriday;
        /**
         * Monday schedule
         */
        monday: outputs.networks.GetSwitchPortSchedulesItemPortScheduleMonday;
        /**
         * Saturday schedule
         */
        saturday: outputs.networks.GetSwitchPortSchedulesItemPortScheduleSaturday;
        /**
         * Sunday schedule
         */
        sunday: outputs.networks.GetSwitchPortSchedulesItemPortScheduleSunday;
        /**
         * Thursday schedule
         */
        thursday: outputs.networks.GetSwitchPortSchedulesItemPortScheduleThursday;
        /**
         * Tuesday schedule
         */
        tuesday: outputs.networks.GetSwitchPortSchedulesItemPortScheduleTuesday;
        /**
         * Wednesday schedule
         */
        wednesday: outputs.networks.GetSwitchPortSchedulesItemPortScheduleWednesday;
    }

    export interface GetSwitchPortSchedulesItemPortScheduleFriday {
        /**
         * Whether the schedule is active or inactive
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'
         */
        to: string;
    }

    export interface GetSwitchPortSchedulesItemPortScheduleMonday {
        /**
         * Whether the schedule is active or inactive
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'
         */
        to: string;
    }

    export interface GetSwitchPortSchedulesItemPortScheduleSaturday {
        /**
         * Whether the schedule is active or inactive
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'
         */
        to: string;
    }

    export interface GetSwitchPortSchedulesItemPortScheduleSunday {
        /**
         * Whether the schedule is active or inactive
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'
         */
        to: string;
    }

    export interface GetSwitchPortSchedulesItemPortScheduleThursday {
        /**
         * Whether the schedule is active or inactive
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'
         */
        to: string;
    }

    export interface GetSwitchPortSchedulesItemPortScheduleTuesday {
        /**
         * Whether the schedule is active or inactive
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'
         */
        to: string;
    }

    export interface GetSwitchPortSchedulesItemPortScheduleWednesday {
        /**
         * Whether the schedule is active or inactive
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'
         */
        to: string;
    }

    export interface GetSwitchQosRulesOrderItem {
        dscp: number;
        dstPort: number;
        dstPortRange: string;
        id: string;
        protocol: string;
        srcPort: number;
        srcPortRange: string;
        vlan: number;
    }

    export interface GetSwitchRoutingMulticastItem {
        /**
         * Default multicast setting for entire network. IGMP snooping and Flood unknown
         * multicast traffic settings are enabled by default.
         */
        defaultSettings: outputs.networks.GetSwitchRoutingMulticastItemDefaultSettings;
        /**
         * Array of paired switches/stacks/profiles and corresponding multicast settings.
         * An empty array will clear the multicast settings.
         */
        overrides: outputs.networks.GetSwitchRoutingMulticastItemOverride[];
    }

    export interface GetSwitchRoutingMulticastItemDefaultSettings {
        /**
         * Flood unknown multicast traffic enabled for the entire network
         */
        floodUnknownMulticastTrafficEnabled: boolean;
        /**
         * IGMP snooping enabled for the entire network
         */
        igmpSnoopingEnabled: boolean;
    }

    export interface GetSwitchRoutingMulticastItemOverride {
        /**
         * Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
         */
        floodUnknownMulticastTrafficEnabled: boolean;
        /**
         * IGMP snooping enabled for switches, switch stacks or switch templates
         */
        igmpSnoopingEnabled: boolean;
        /**
         * (optional) List of switch stack ids for non-template network
         */
        stacks: string[];
        /**
         * (optional) List of switch templates ids for template network
         */
        switchProfiles: string[];
        /**
         * (optional) List of switch serials for non-template network
         */
        switches: string[];
    }

    export interface GetSwitchRoutingMulticastRendezvousPointsItem {
        /**
         * TheIP address of the interface to use.
         */
        interfaceIp: string;
        /**
         * The name of the interface to use.
         */
        interfaceName: string;
        /**
         * 'Any', or the IP address of a multicast group.
         */
        multicastGroup: string;
        /**
         * The id.
         */
        rendezvousPointId: string;
        /**
         * The serial.
         */
        serial: string;
    }

    export interface GetSwitchRoutingOspfItem {
        areas: outputs.networks.GetSwitchRoutingOspfItemArea[];
        deadTimerInSeconds: number;
        enabled: boolean;
        helloTimerInSeconds: number;
        md5AuthenticationEnabled: boolean;
        md5AuthenticationKey: outputs.networks.GetSwitchRoutingOspfItemMd5AuthenticationKey;
        v3: outputs.networks.GetSwitchRoutingOspfItemV3;
    }

    export interface GetSwitchRoutingOspfItemArea {
        areaId: string;
        areaName: string;
        areaType: string;
    }

    export interface GetSwitchRoutingOspfItemMd5AuthenticationKey {
        id: number;
        passphrase: string;
    }

    export interface GetSwitchRoutingOspfItemV3 {
        areas: outputs.networks.GetSwitchRoutingOspfItemV3Area[];
        deadTimerInSeconds: number;
        enabled: boolean;
        helloTimerInSeconds: number;
    }

    export interface GetSwitchRoutingOspfItemV3Area {
        areaId: string;
        areaName: string;
        areaType: string;
    }

    export interface GetSwitchSettingsItem {
        /**
         * MAC blocklist
         */
        macBlocklist: outputs.networks.GetSwitchSettingsItemMacBlocklist;
        /**
         * Exceptions on a per switch basis to "useCombinedPower"
         */
        powerExceptions: outputs.networks.GetSwitchSettingsItemPowerException[];
        /**
         * Uplink client sampling
         */
        uplinkClientSampling: outputs.networks.GetSwitchSettingsItemUplinkClientSampling;
        /**
         * The use Combined Power as the default behavior of secondary power supplies on supported devices.
         */
        useCombinedPower: boolean;
        /**
         * Management VLAN
         */
        vlan: number;
    }

    export interface GetSwitchSettingsItemMacBlocklist {
        /**
         * Enable MAC blocklist for switches in the network
         */
        enabled: boolean;
    }

    export interface GetSwitchSettingsItemPowerException {
        /**
         * Per switch exception (combined, redundant, useNetworkSetting)
         */
        powerType: string;
        /**
         * Serial number of the switch
         */
        serial: string;
    }

    export interface GetSwitchSettingsItemUplinkClientSampling {
        /**
         * Enable client sampling on uplink
         */
        enabled: boolean;
    }

    export interface GetSwitchStacksItem {
        /**
         * ID of the Switch stack
         */
        id: string;
        /**
         * Name of the Switch stack
         */
        name: string;
        /**
         * Serials of the switches in the switch stack
         */
        serials: string[];
    }

    export interface GetSwitchStacksRoutingInterfacesDhcpItem {
        /**
         * The PXE boot server file name for the DHCP server running on the switch stack interface
         */
        bootFileName: string;
        /**
         * The PXE boot server IP for the DHCP server running on the switch stack interface
         */
        bootNextServer: string;
        /**
         * Enable DHCP boot options to provide PXE boot options configs for the dhcp server running on the switch stack interface
         */
        bootOptionsEnabled: boolean;
        /**
         * The DHCP lease time config for the dhcp server running on the switch stack interface ('30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week')
         */
        dhcpLeaseTime: string;
        /**
         * The DHCP mode options for the switch stack interface ('dhcpDisabled', 'dhcpRelay' or 'dhcpServer')
         */
        dhcpMode: string;
        /**
         * Array of DHCP options consisting of code, type and value for the DHCP server running on the switch stack interface
         */
        dhcpOptions: outputs.networks.GetSwitchStacksRoutingInterfacesDhcpItemDhcpOption[];
        /**
         * The DHCP relay server IPs to which DHCP packets would get relayed for the switch stack interface
         */
        dhcpRelayServerIps: string[];
        /**
         * The DHCP name server IPs when DHCP name server option is 'custom'
         */
        dnsCustomNameservers: string[];
        /**
         * The DHCP name server option for the dhcp server running on the switch stack interface ('googlePublicDns', 'openDns' or 'custom')
         */
        dnsNameserversOption: string;
        /**
         * Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
         */
        fixedIpAssignments: outputs.networks.GetSwitchStacksRoutingInterfacesDhcpItemFixedIpAssignment[];
        /**
         * Array of DHCP reserved IP assignments for the DHCP server running on the switch stack interface
         */
        reservedIpRanges: outputs.networks.GetSwitchStacksRoutingInterfacesDhcpItemReservedIpRange[];
    }

    export interface GetSwitchStacksRoutingInterfacesDhcpItemDhcpOption {
        /**
         * The code for DHCP option which should be from 2 to 254
         */
        code: string;
        /**
         * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
         */
        type: string;
        /**
         * The value of the DHCP option
         */
        value: string;
    }

    export interface GetSwitchStacksRoutingInterfacesDhcpItemFixedIpAssignment {
        /**
         * The IP address of the client which has fixed IP address assigned to it
         */
        ip: string;
        /**
         * The MAC address of the client which has fixed IP address
         */
        mac: string;
        /**
         * The name of the client which has fixed IP address
         */
        name: string;
    }

    export interface GetSwitchStacksRoutingInterfacesDhcpItemReservedIpRange {
        /**
         * The comment for the reserved IP range
         */
        comment: string;
        /**
         * The ending IP address of the reserved IP range
         */
        end: string;
        /**
         * The starting IP address of the reserved IP range
         */
        start: string;
    }

    export interface GetSwitchStacksRoutingInterfacesItem {
        /**
         * IPv4 default gateway
         */
        defaultGateway: string;
        /**
         * The id
         */
        interfaceId: string;
        /**
         * IPv4 address
         */
        interfaceIp: string;
        /**
         * IPv6 addressing
         */
        ipv6: outputs.networks.GetSwitchStacksRoutingInterfacesItemIpv6;
        /**
         * Multicast routing status
         */
        multicastRouting: string;
        /**
         * The name
         */
        name: string;
        /**
         * IPv4 OSPF Settings
         */
        ospfSettings: outputs.networks.GetSwitchStacksRoutingInterfacesItemOspfSettings;
        /**
         * IPv6 OSPF Settings
         */
        ospfV3: outputs.networks.GetSwitchStacksRoutingInterfacesItemOspfV3;
        /**
         * IPv4 subnet
         */
        subnet: string;
        /**
         * VLAN id
         */
        vlanId: number;
    }

    export interface GetSwitchStacksRoutingInterfacesItemIpv6 {
        /**
         * IPv6 address
         */
        address: string;
        /**
         * Assignment mode
         */
        assignmentMode: string;
        /**
         * IPv6 gateway
         */
        gateway: string;
        /**
         * IPv6 subnet
         */
        prefix: string;
    }

    export interface GetSwitchStacksRoutingInterfacesItemOspfSettings {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv4 area
         */
        isPassiveEnabled: boolean;
    }

    export interface GetSwitchStacksRoutingInterfacesItemOspfV3 {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv6 area
         */
        isPassiveEnabled: boolean;
    }

    export interface GetSwitchStacksRoutingStaticRoutesItem {
        /**
         * Option to advertise static routes via OSPF
         */
        advertiseViaOspfEnabled: boolean;
        /**
         * The name or description of the layer 3 static route
         */
        name: string;
        /**
         * The IP address of the router to which traffic for this destination network should be sent
         */
        nextHopIp: string;
        /**
         * Option to prefer static routes over OSPF routes
         */
        preferOverOspfRoutesEnabled: boolean;
        /**
         * The identifier of a layer 3 static route
         */
        staticRouteId: string;
        /**
         * The IP address of the subnetwork specified in CIDR notation (ex. 1.2.3.0/24)
         */
        subnet: string;
    }

    export interface GetSwitchStormControlItem {
        /**
         * Broadcast threshold.
         */
        broadcastThreshold: number;
        /**
         * Multicast threshold.
         */
        multicastThreshold: number;
        /**
         * Unknown Unicast threshold.
         */
        unknownUnicastThreshold: number;
    }

    export interface GetSwitchStpItem {
        rstpEnabled: boolean;
        stpBridgePriorities: outputs.networks.GetSwitchStpItemStpBridgePriority[];
    }

    export interface GetSwitchStpItemStpBridgePriority {
        stpPriority: number;
        switches: string[];
    }

    export interface GetSyslogServersItem {
        /**
         * List of the syslog servers for this network
         */
        servers: outputs.networks.GetSyslogServersItemServer[];
    }

    export interface GetSyslogServersItemServer {
        /**
         * The IP address of the syslog server
         */
        host: string;
        /**
         * The port of the syslog server
         */
        port: number;
        /**
         * A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
         */
        roles: string[];
    }

    export interface GetTopologyLinkLayerItem {
        errors: string[];
        links: outputs.networks.GetTopologyLinkLayerItemLink[];
        nodes: outputs.networks.GetTopologyLinkLayerItemNode[];
    }

    export interface GetTopologyLinkLayerItemLink {
        ends: outputs.networks.GetTopologyLinkLayerItemLinkEnd[];
        lastReportedAt: string;
    }

    export interface GetTopologyLinkLayerItemLinkEnd {
        device: outputs.networks.GetTopologyLinkLayerItemLinkEndDevice;
        discovered: outputs.networks.GetTopologyLinkLayerItemLinkEndDiscovered;
        node: outputs.networks.GetTopologyLinkLayerItemLinkEndNode;
    }

    export interface GetTopologyLinkLayerItemLinkEndDevice {
        name: string;
        serial: string;
    }

    export interface GetTopologyLinkLayerItemLinkEndDiscovered {
        cdp: outputs.networks.GetTopologyLinkLayerItemLinkEndDiscoveredCdp;
        lldp: outputs.networks.GetTopologyLinkLayerItemLinkEndDiscoveredLldp;
    }

    export interface GetTopologyLinkLayerItemLinkEndDiscoveredCdp {
        nativeVlan: number;
        portId: string;
    }

    export interface GetTopologyLinkLayerItemLinkEndDiscoveredLldp {
        portDescription: string;
        portId: string;
    }

    export interface GetTopologyLinkLayerItemLinkEndNode {
        derivedId: string;
        type: string;
    }

    export interface GetTopologyLinkLayerItemNode {
        derivedId: string;
        discovered: outputs.networks.GetTopologyLinkLayerItemNodeDiscovered;
        mac: string;
        root: boolean;
        type: string;
    }

    export interface GetTopologyLinkLayerItemNodeDiscovered {
        cdp: string;
        lldp: outputs.networks.GetTopologyLinkLayerItemNodeDiscoveredLldp;
    }

    export interface GetTopologyLinkLayerItemNodeDiscoveredLldp {
        chassisId: string;
        managementAddress: string;
        systemCapabilities: string[];
        systemDescription: string;
        systemName: string;
    }

    export interface GetTrafficAnalysisItem {
        /**
         * The list of items that make up the custom pie chart for traffic reporting.
         */
        customPieChartItems: outputs.networks.GetTrafficAnalysisItemCustomPieChartItem[];
        /**
         * The traffic analysis mode for the network. Can be one of 'disabled' (do not collect traffic types),
         * 'basic' (collect generic traffic categories), or 'detailed' (collect destination hostnames).
         */
        mode: string;
    }

    export interface GetTrafficAnalysisItemCustomPieChartItem {
        /**
         * The name of the custom pie chart item.
         */
        name: string;
        /**
         * The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
         */
        type: string;
        /**
         * The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
         * (see sample request/response for more details).
         */
        value: string;
    }

    export interface GetTrafficShapingApplicationCategoriesItem {
        applicationCategories: outputs.networks.GetTrafficShapingApplicationCategoriesItemApplicationCategory[];
    }

    export interface GetTrafficShapingApplicationCategoriesItemApplicationCategory {
        applications: outputs.networks.GetTrafficShapingApplicationCategoriesItemApplicationCategoryApplication[];
        id: string;
        name: string;
    }

    export interface GetTrafficShapingApplicationCategoriesItemApplicationCategoryApplication {
        id: string;
        name: string;
    }

    export interface GetTrafficShapingDscpTaggingOptionsItem {
        description: string;
        dscpTagValue: number;
    }

    export interface GetVlanProfilesAssignmentsByDeviceItem {
        /**
         * MAC address of the device
         */
        mac: string;
        /**
         * Name of the Device
         */
        name: string;
        /**
         * The product type
         */
        productType: string;
        /**
         * Serial of the Device
         */
        serial: string;
        /**
         * The Switch Stack the device belongs to
         */
        stack: outputs.networks.GetVlanProfilesAssignmentsByDeviceItemStack;
        /**
         * The VLAN Profile
         */
        vlanProfile: outputs.networks.GetVlanProfilesAssignmentsByDeviceItemVlanProfile;
    }

    export interface GetVlanProfilesAssignmentsByDeviceItemStack {
        /**
         * ID of the Switch Stack
         */
        id: string;
    }

    export interface GetVlanProfilesAssignmentsByDeviceItemVlanProfile {
        /**
         * IName of the VLAN Profile
         */
        iname: string;
        /**
         * Is this VLAN profile the default for the network?
         */
        isDefault: boolean;
        /**
         * Name of the VLAN Profile
         */
        name: string;
    }

    export interface GetVlanProfilesItem {
        /**
         * IName of the VLAN profile
         */
        iname: string;
        /**
         * Boolean indicating the default VLAN Profile for any device that does not have a profile explicitly assigned
         */
        isDefault: boolean;
        /**
         * Name of the profile, string length must be from 1 to 255 characters
         */
        name: string;
        /**
         * An array of named VLANs
         */
        vlanGroups: outputs.networks.GetVlanProfilesItemVlanGroup[];
        /**
         * An array of named VLANs
         */
        vlanNames: outputs.networks.GetVlanProfilesItemVlanName[];
    }

    export interface GetVlanProfilesItemVlanGroup {
        /**
         * Name of the VLAN, string length must be from 1 to 32 characters
         */
        name: string;
        /**
         * Comma-separated VLAN IDs or ID ranges
         */
        vlanIds: string;
    }

    export interface GetVlanProfilesItemVlanName {
        /**
         * Adaptive Policy Group assigned to Vlan ID
         */
        adaptivePolicyGroup: outputs.networks.GetVlanProfilesItemVlanNameAdaptivePolicyGroup;
        /**
         * Name of the VLAN, string length must be from 1 to 32 characters
         */
        name: string;
        /**
         * VLAN ID
         */
        vlanId: string;
    }

    export interface GetVlanProfilesItemVlanNameAdaptivePolicyGroup {
        /**
         * Adaptive Policy Group ID
         */
        id: string;
        /**
         * Adaptive Policy Group name
         */
        name: string;
    }

    export interface GetWebhooksHttpServersItem {
        /**
         * A Base64 encoded ID.
         */
        id: string;
        /**
         * A name for easy reference to the HTTP server
         */
        name: string;
        /**
         * A Meraki network ID.
         */
        networkId: string;
        /**
         * The payload template to use when posting data to the HTTP server.
         */
        payloadTemplate: outputs.networks.GetWebhooksHttpServersItemPayloadTemplate;
        /**
         * The URL of the HTTP server.
         */
        url: string;
    }

    export interface GetWebhooksHttpServersItemPayloadTemplate {
        /**
         * The name of the payload template.
         */
        name: string;
        /**
         * The ID of the payload template.
         */
        payloadTemplateId: string;
    }

    export interface GetWebhooksPayloadTemplatesItem {
        /**
         * The body of the payload template, in liquid template
         */
        body: string;
        /**
         * The payload template headers, will be rendered as a key-value pair in the webhook.
         */
        headers: outputs.networks.GetWebhooksPayloadTemplatesItemHeader[];
        /**
         * The name of the payload template
         */
        name: string;
        /**
         * Webhook payload template Id
         */
        payloadTemplateId: string;
        /**
         * Information on which entities have access to the template
         */
        sharing: outputs.networks.GetWebhooksPayloadTemplatesItemSharing;
        /**
         * The type of the payload template
         */
        type: string;
    }

    export interface GetWebhooksPayloadTemplatesItemHeader {
        /**
         * The name of the header attribute
         */
        name: string;
        /**
         * The value returned in the header attribute, in liquid template
         */
        template: string;
    }

    export interface GetWebhooksPayloadTemplatesItemSharing {
        /**
         * Information on network access to the template
         */
        byNetwork: outputs.networks.GetWebhooksPayloadTemplatesItemSharingByNetwork;
    }

    export interface GetWebhooksPayloadTemplatesItemSharingByNetwork {
        /**
         * Indicates whether network admins may modify this template
         */
        adminsCanModify: boolean;
    }

    export interface GetWebhooksWebhookTestsItem {
        /**
         * Webhook delivery identifier
         */
        id: string;
        /**
         * Current status of the webhook delivery
         */
        status: string;
        /**
         * URL where the webhook was delivered
         */
        url: string;
    }

    export interface GetWirelessAlternateManagementInterfaceItem {
        accessPoints: outputs.networks.GetWirelessAlternateManagementInterfaceItemAccessPoint[];
        enabled: boolean;
        protocols: string[];
        vlanId: number;
    }

    export interface GetWirelessAlternateManagementInterfaceItemAccessPoint {
        alternateManagementIp: string;
        dns1: string;
        dns2: string;
        gateway: string;
        serial: string;
        subnetMask: string;
    }

    export interface GetWirelessBillingItem {
        /**
         * The currency code of this node group's billing plans
         */
        currency: string;
        /**
         * Array of billing plans in the node group. (Can configure a maximum of 5)
         */
        plans: outputs.networks.GetWirelessBillingItemPlan[];
    }

    export interface GetWirelessBillingItemPlan {
        /**
         * The uplink bandwidth settings for the pricing plan.
         */
        bandwidthLimits: outputs.networks.GetWirelessBillingItemPlanBandwidthLimits;
        /**
         * The id of the pricing plan to update.
         */
        id: string;
        /**
         * The price of the billing plan.
         */
        price: number;
        /**
         * The time limit of the pricing plan in minutes.
         */
        timeLimit: string;
    }

    export interface GetWirelessBillingItemPlanBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp: number;
    }

    export interface GetWirelessBluetoothSettingsItem {
        /**
         * Whether APs will advertise beacons.
         */
        advertisingEnabled: boolean;
        /**
         * Whether ESL is enabled on this network.
         */
        eslEnabled: boolean;
        /**
         * The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
         */
        major: number;
        /**
         * The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')
         */
        majorMinorAssignmentMode: string;
        /**
         * The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.
         */
        minor: number;
        /**
         * Whether APs will scan for Bluetooth enabled clients.
         */
        scanningEnabled: boolean;
        /**
         * The UUID to be used in the beacon identifier.
         */
        uuid: string;
    }

    export interface GetWirelessChannelUtilizationHistoryItem {
        /**
         * The end time of the query range
         */
        endTs: string;
        /**
         * The start time of the query range
         */
        startTs: string;
        /**
         * Average wifi utilization
         */
        utilization80211: number;
        /**
         * Average signal interference
         */
        utilizationNon80211: number;
        /**
         * Total channel utilization
         */
        utilizationTotal: number;
    }

    export interface GetWirelessClientCountHistoryItem {
        /**
         * Number of connected clients
         */
        clientCount: number;
        /**
         * The end time of the query range
         */
        endTs: string;
        /**
         * The start time of the query range
         */
        startTs: string;
    }

    export interface GetWirelessClientsConnectionStatsItem {
        connectionStats: outputs.networks.GetWirelessClientsConnectionStatsItemConnectionStats;
        mac: string;
    }

    export interface GetWirelessClientsConnectionStatsItemConnectionStats {
        assoc: number;
        auth: number;
        dhcp: number;
        dns: number;
        success: number;
    }

    export interface GetWirelessClientsLatencyStatsItem {
        latencyStats: outputs.networks.GetWirelessClientsLatencyStatsItemLatencyStats;
        mac: string;
    }

    export interface GetWirelessClientsLatencyStatsItemLatencyStats {
        backgroundTraffic: outputs.networks.GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTraffic;
        bestEffortTraffic: string;
        videoTraffic: string;
        voiceTraffic: string;
    }

    export interface GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTraffic {
        avg: number;
        rawDistribution: outputs.networks.GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficRawDistribution;
    }

    export interface GetWirelessClientsLatencyStatsItemLatencyStatsBackgroundTrafficRawDistribution {
        status0: number;
        status1: number;
        status1024: number;
        status128: number;
        status16: number;
        status2: number;
        status2048: number;
        status256: number;
        status32: number;
        status4: number;
        status512: number;
        status64: number;
        status8: number;
    }

    export interface GetWirelessConnectionStatsItem {
        /**
         * The number of failed association attempts
         */
        assoc: number;
        /**
         * The number of failed authentication attempts
         */
        auth: number;
        /**
         * The number of failed DHCP attempts
         */
        dhcp: number;
        /**
         * The number of failed DNS attempts
         */
        dns: number;
        /**
         * The number of successful connection attempts
         */
        success: number;
    }

    export interface GetWirelessDataRateHistoryItem {
        /**
         * Average data rate in kilobytes-per-second
         */
        averageKbps: number;
        /**
         * Download rate in kilobytes-per-second
         */
        downloadKbps: number;
        /**
         * The end time of the query range
         */
        endTs: string;
        /**
         * The start time of the query range
         */
        startTs: string;
        /**
         * Upload rate in kilobytes-per-second
         */
        uploadKbps: number;
    }

    export interface GetWirelessDevicesConnectionStatsItem {
        /**
         * The connection stats of the device
         */
        connectionStats: outputs.networks.GetWirelessDevicesConnectionStatsItemConnectionStats;
        /**
         * The serial number for the device
         */
        serial: string;
    }

    export interface GetWirelessDevicesConnectionStatsItemConnectionStats {
        /**
         * The number of failed association attempts
         */
        assoc: number;
        /**
         * The number of failed authentication attempts
         */
        auth: number;
        /**
         * The number of failed DHCP attempts
         */
        dhcp: number;
        /**
         * The number of failed DNS attempts
         */
        dns: number;
        /**
         * The number of successful connection attempts
         */
        success: number;
    }

    export interface GetWirelessEthernetPortsProfilesItem {
        /**
         * Is default profile
         */
        isDefault: boolean;
        /**
         * AP port profile name
         */
        name: string;
        /**
         * Ports config
         */
        ports: outputs.networks.GetWirelessEthernetPortsProfilesItemPort[];
        /**
         * AP port profile ID
         */
        profileId: string;
        /**
         * Usb ports config
         */
        usbPorts: outputs.networks.GetWirelessEthernetPortsProfilesItemUsbPort[];
    }

    export interface GetWirelessEthernetPortsProfilesItemPort {
        /**
         * Enabled
         */
        enabled: boolean;
        /**
         * Name
         */
        name: string;
        /**
         * Number
         */
        number: number;
        /**
         * PSK Group number
         */
        pskGroupId: string;
        /**
         * Ssid number
         */
        ssid: number;
    }

    export interface GetWirelessEthernetPortsProfilesItemUsbPort {
        /**
         * Enabled
         */
        enabled: boolean;
        /**
         * Name
         */
        name: string;
        /**
         * Ssid number
         */
        ssid: number;
    }

    export interface GetWirelessFailedConnectionsItem {
        /**
         * Client Mac
         */
        clientMac: string;
        /**
         * The failed onboarding step. One of: assoc, auth, dhcp, dns.
         */
        failureStep: string;
        /**
         * Serial Number
         */
        serial: string;
        /**
         * SSID Number
         */
        ssidNumber: number;
        /**
         * The timestamp when the client mac failed
         */
        ts: string;
        /**
         * The failure type in the onboarding step
         */
        type: string;
        /**
         * LAN
         */
        vlan: number;
    }

    export interface GetWirelessLatencyHistoryItem {
        /**
         * Average latency in milliseconds
         */
        avgLatencyMs: number;
        /**
         * The end time of the query range
         */
        endTs: string;
        /**
         * The start time of the query range
         */
        startTs: string;
    }

    export interface GetWirelessLatencyStatsItem {
        backgroundTraffic: outputs.networks.GetWirelessLatencyStatsItemBackgroundTraffic;
        bestEffortTraffic: string;
        videoTraffic: string;
        voiceTraffic: string;
    }

    export interface GetWirelessLatencyStatsItemBackgroundTraffic {
        avg: number;
        rawDistribution: outputs.networks.GetWirelessLatencyStatsItemBackgroundTrafficRawDistribution;
    }

    export interface GetWirelessLatencyStatsItemBackgroundTrafficRawDistribution {
        status0: number;
        status1: number;
        status1024: number;
        status128: number;
        status16: number;
        status2: number;
        status2048: number;
        status256: number;
        status32: number;
        status4: number;
        status512: number;
        status64: number;
        status8: number;
    }

    export interface GetWirelessMeshStatusesItem {
        /**
         * Current metrics on how the mesh is performing.
         */
        latestMeshPerformance: outputs.networks.GetWirelessMeshStatusesItemLatestMeshPerformance;
        /**
         * List of device serials that make up the mesh.
         */
        meshRoutes: string[];
        /**
         * The serial number for the device.
         */
        serial: string;
    }

    export interface GetWirelessMeshStatusesItemLatestMeshPerformance {
        /**
         * Average Mbps.
         */
        mbps: number;
        /**
         * Represents the quality of the entire route from the repeater access point to its gateway access point.
         */
        metric: number;
        /**
         * Mesh utilization as a percentage.
         */
        usagePercentage: string;
    }

    export interface GetWirelessRfProfilesItem {
        /**
         * Settings that will be enabled if selectionType is set to 'ap'.
         */
        apBandSettings: outputs.networks.GetWirelessRfProfilesItemApBandSettings;
        /**
         * Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.
         */
        bandSelectionType: string;
        /**
         * Steers client to best available access point. Can be either true or false. Defaults to true.
         */
        clientBalancingEnabled: boolean;
        /**
         * Settings related to 5Ghz band
         */
        fiveGhzSettings: outputs.networks.GetWirelessRfProfilesItemFiveGhzSettings;
        /**
         * The name of the new profile. Must be unique.
         */
        id: string;
        /**
         * Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.
         */
        minBitrateType: string;
        /**
         * The name of the new profile. Must be unique. This param is required on creation.
         */
        name: string;
        /**
         * The network ID of the RF Profile
         */
        networkId: string;
        /**
         * Per-SSID radio settings by number.
         */
        perSsidSettings: outputs.networks.GetWirelessRfProfilesItemPerSsidSettings;
        /**
         * Settings related to 6Ghz band. Only applicable to networks with 6Ghz capable APs
         */
        sixGhzSettings: outputs.networks.GetWirelessRfProfilesItemSixGhzSettings;
        /**
         * Settings related to radio transmission.
         */
        transmission: outputs.networks.GetWirelessRfProfilesItemTransmission;
        /**
         * Settings related to 2.4Ghz band
         */
        twoFourGhzSettings: outputs.networks.GetWirelessRfProfilesItemTwoFourGhzSettings;
    }

    export interface GetWirelessRfProfilesItemApBandSettings {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band. Can be either true or false. Defaults to true.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemApBandSettingsBands;
    }

    export interface GetWirelessRfProfilesItemApBandSettingsBands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemFiveGhzSettings {
        /**
         * Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
         */
        channelWidth: string;
        /**
         * Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower: number;
        /**
         * Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
         */
        minBitrate: number;
        /**
         * Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
         */
        minPower: number;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop: number;
        /**
         * Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
         */
        validAutoChannels: number[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettings {
        /**
         * Settings for SSID 0
         */
        status0: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus0;
        /**
         * Settings for SSID 1
         */
        status1: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus1;
        /**
         * Settings for SSID 10
         */
        status10: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus10;
        /**
         * Settings for SSID 11
         */
        status11: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus11;
        /**
         * Settings for SSID 12
         */
        status12: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus12;
        /**
         * Settings for SSID 13
         */
        status13: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus13;
        /**
         * Settings for SSID 14
         */
        status14: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus14;
        /**
         * Settings for SSID 2
         */
        status2: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus2;
        /**
         * Settings for SSID 3
         */
        status3: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus3;
        /**
         * Settings for SSID 4
         */
        status4: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus4;
        /**
         * Settings for SSID 5
         */
        status5: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus5;
        /**
         * Settings for SSID 6
         */
        status6: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus6;
        /**
         * Settings for SSID 7
         */
        status7: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus7;
        /**
         * Settings for SSID 8
         */
        status8: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus8;
        /**
         * Settings for SSID 9
         */
        status9: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus9;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus0 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus0Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus0Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus1 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus1Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus10 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus10Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus10Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus11 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus11Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus11Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus12 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus12Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus12Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus13 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus13Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus13Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus14 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus14Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus14Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus1Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus2 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus2Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus2Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus3 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus3Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus3Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus4 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus4Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus4Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus5 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus5Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus5Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus6 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus6Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus6Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus7 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus7Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus7Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus8 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus8Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus8Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus9 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.GetWirelessRfProfilesItemPerSsidSettingsStatus9Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface GetWirelessRfProfilesItemPerSsidSettingsStatus9Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface GetWirelessRfProfilesItemSixGhzSettings {
        /**
         * Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
         */
        channelWidth: string;
        /**
         * Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower: number;
        /**
         * Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
         */
        minBitrate: number;
        /**
         * Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
         */
        minPower: number;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop: number;
        /**
         * Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
         */
        validAutoChannels: number[];
    }

    export interface GetWirelessRfProfilesItemTransmission {
        /**
         * Toggle for radio transmission. When false, radios will not transmit at all.
         */
        enabled: boolean;
    }

    export interface GetWirelessRfProfilesItemTwoFourGhzSettings {
        /**
         * Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
         */
        axEnabled: boolean;
        /**
         * Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower: number;
        /**
         * Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
         */
        minBitrate: number;
        /**
         * Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
         */
        minPower: number;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop: number;
        /**
         * Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
         */
        validAutoChannels: number[];
    }

    export interface GetWirelessSettingsItem {
        /**
         * Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)
         */
        ipv6BridgeEnabled: boolean;
        /**
         * Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)
         */
        ledLightsOn: boolean;
        /**
         * Toggle for enabling or disabling location analytics for your network
         */
        locationAnalyticsEnabled: boolean;
        /**
         * Toggle for enabling or disabling meshing in a network
         */
        meshingEnabled: boolean;
        /**
         * Named VLAN settings for wireless networks.
         */
        namedVlans: outputs.networks.GetWirelessSettingsItemNamedVlans;
        /**
         * Regulatory domain information for this network.
         */
        regulatoryDomain: outputs.networks.GetWirelessSettingsItemRegulatoryDomain;
        /**
         * The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'
         */
        upgradestrategy: string;
    }

    export interface GetWirelessSettingsItemNamedVlans {
        /**
         * Named VLAN Pool DHCP Monitoring settings.
         */
        poolDhcpMonitoring: outputs.networks.GetWirelessSettingsItemNamedVlansPoolDhcpMonitoring;
    }

    export interface GetWirelessSettingsItemNamedVlansPoolDhcpMonitoring {
        /**
         * The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
         */
        duration: number;
        /**
         * Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
         */
        enabled: boolean;
    }

    export interface GetWirelessSettingsItemRegulatoryDomain {
        /**
         * The country code of the regulatory domain.
         */
        countryCode: string;
        /**
         * The name of the regulatory domain for this network.
         */
        name: string;
        /**
         * Whether or not the regulatory domain for this network permits Wifi 6E.
         */
        permits6e: boolean;
    }

    export interface GetWirelessSignalQualityHistoryItem {
        /**
         * The end time of the query range
         */
        endTs: string;
        /**
         * Received signal strength indicator
         */
        rssi: number;
        /**
         * Signal to noise ratio
         */
        snr: number;
        /**
         * The start time of the query range
         */
        startTs: string;
    }

    export interface GetWirelessSsidsBonjourForwardingItem {
        /**
         * If true, Bonjour forwarding is enabled on the SSID.
         */
        enabled: boolean;
        /**
         * Bonjour forwarding exception
         */
        exception: outputs.networks.GetWirelessSsidsBonjourForwardingItemException;
        /**
         * Bonjour forwarding rules
         */
        rules: outputs.networks.GetWirelessSsidsBonjourForwardingItemRule[];
    }

    export interface GetWirelessSsidsBonjourForwardingItemException {
        /**
         * If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
         */
        enabled: boolean;
    }

    export interface GetWirelessSsidsBonjourForwardingItemRule {
        /**
         * Desctiption of the bonjour forwarding rule
         */
        description: string;
        /**
         * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
         */
        services: string[];
        /**
         * The ID of the service VLAN. Required
         */
        vlanId: string;
    }

    export interface GetWirelessSsidsDeviceTypeGroupPoliciesItem {
        deviceTypePolicies: outputs.networks.GetWirelessSsidsDeviceTypeGroupPoliciesItemDeviceTypePolicy[];
        enabled: boolean;
    }

    export interface GetWirelessSsidsDeviceTypeGroupPoliciesItemDeviceTypePolicy {
        devicePolicy: string;
        deviceType: string;
    }

    export interface GetWirelessSsidsEapOverrideItem {
        /**
         * EAPOL Key settings.
         */
        eapolKey: outputs.networks.GetWirelessSsidsEapOverrideItemEapolKey;
        /**
         * EAP settings for identity requests.
         */
        identity: outputs.networks.GetWirelessSsidsEapOverrideItemIdentity;
        /**
         * Maximum number of general EAP retries.
         */
        maxRetries: number;
        /**
         * General EAP timeout in seconds.
         */
        timeout: number;
    }

    export interface GetWirelessSsidsEapOverrideItemEapolKey {
        /**
         * Maximum number of EAPOL key retries.
         */
        retries: number;
        /**
         * EAPOL Key timeout in milliseconds.
         */
        timeoutInMs: number;
    }

    export interface GetWirelessSsidsEapOverrideItemIdentity {
        /**
         * Maximum number of EAP retries.
         */
        retries: number;
        /**
         * EAP timeout in seconds.
         */
        timeout: number;
    }

    export interface GetWirelessSsidsFirewallL3FirewallRulesItem {
        /**
         * An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule).
         */
        rules: outputs.networks.GetWirelessSsidsFirewallL3FirewallRulesItemRule[];
    }

    export interface GetWirelessSsidsFirewallL3FirewallRulesItemRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
    }

    export interface GetWirelessSsidsFirewallL7FirewallRulesItem {
        /**
         * An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule).
         */
        rules: outputs.networks.GetWirelessSsidsFirewallL7FirewallRulesItemRule[];
    }

    export interface GetWirelessSsidsFirewallL7FirewallRulesItemRule {
        /**
         * 'Deny' traffic specified by this rule
         */
        policy: string;
        /**
         * Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
         */
        type: string;
        /**
         * The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
         */
        value: string;
    }

    export interface GetWirelessSsidsHotspot20Item {
        domains: string[];
        enabled: boolean;
        mccMncs: outputs.networks.GetWirelessSsidsHotspot20ItemMccMnc[];
        naiRealms: outputs.networks.GetWirelessSsidsHotspot20ItemNaiRealm[];
        networkAccessType: string;
        operator: outputs.networks.GetWirelessSsidsHotspot20ItemOperator;
        roamConsortOis: string[];
        venue: outputs.networks.GetWirelessSsidsHotspot20ItemVenue;
    }

    export interface GetWirelessSsidsHotspot20ItemMccMnc {
        mcc: string;
        mnc: string;
    }

    export interface GetWirelessSsidsHotspot20ItemNaiRealm {
        format: string;
        methods: outputs.networks.GetWirelessSsidsHotspot20ItemNaiRealmMethod[];
        name: string;
    }

    export interface GetWirelessSsidsHotspot20ItemNaiRealmMethod {
        authenticationTypes: outputs.networks.GetWirelessSsidsHotspot20ItemNaiRealmMethodAuthenticationTypes;
        id: string;
    }

    export interface GetWirelessSsidsHotspot20ItemNaiRealmMethodAuthenticationTypes {
        credentials: string[];
        eapinnerAuthentications: string[];
        nonEapinnerAuthentications: string[];
        tunneledEapMethodCredentials: string[];
    }

    export interface GetWirelessSsidsHotspot20ItemOperator {
        name: string;
    }

    export interface GetWirelessSsidsHotspot20ItemVenue {
        name: string;
        type: string;
    }

    export interface GetWirelessSsidsIdentityPsksItem {
        /**
         * The email associated with the System's Manager User
         */
        email: string;
        /**
         * Timestamp for when the Identity PSK expires, or 'null' to never expire
         */
        expiresAt: string;
        /**
         * The group policy to be applied to clients
         */
        groupPolicyId: string;
        /**
         * The unique identifier of the Identity PSK
         */
        id: string;
        /**
         * The name of the Identity PSK
         */
        name: string;
        /**
         * The passphrase for client authentication
         */
        passphrase: string;
        /**
         * The WiFi Personal Network unique identifier
         */
        wifiPersonalNetworkId: string;
    }

    export interface GetWirelessSsidsItem {
        /**
         * URL for the admin splash page
         */
        adminSplashUrl: string;
        /**
         * The association control method for the SSID
         */
        authMode: string;
        /**
         * List of tags for this SSID. If availableOnAllAps is false, then the SSID is only broadcast by APs with tags matching any of the tags in this list
         */
        availabilityTags: string[];
        /**
         * Whether all APs broadcast the SSID or if it's restricted to APs matching any availability tags
         */
        availableOnAllAps: boolean;
        /**
         * The client-serving radio frequencies of this SSID in the default indoor RF profile
         */
        bandSelection: string;
        /**
         * Whether or not the SSID is enabled
         */
        enabled: boolean;
        /**
         * The psk encryption mode for the SSID
         */
        encryptionMode: string;
        /**
         * The client IP assignment mode
         */
        ipAssignmentMode: string;
        /**
         * Extended local auth flag for Enterprise NAC
         */
        localAuth: boolean;
        /**
         * Whether clients connecting to this SSID must use the IP address assigned by the DHCP server
         */
        mandatoryDhcpEnabled: boolean;
        /**
         * The minimum bitrate in Mbps of this SSID in the default indoor RF profile
         */
        minBitrate: number;
        /**
         * The name of the SSID
         */
        name: string;
        /**
         * Unique identifier of the SSID
         */
        number: number;
        /**
         * The download bandwidth limit in Kbps. (0 represents no limit.)
         */
        perClientBandwidthLimitDown: number;
        /**
         * The upload bandwidth limit in Kbps. (0 represents no limit.)
         */
        perClientBandwidthLimitUp: number;
        /**
         * The total download bandwidth limit in Kbps (0 represents no limit)
         */
        perSsidBandwidthLimitDown: number;
        /**
         * The total upload bandwidth limit in Kbps (0 represents no limit)
         */
        perSsidBandwidthLimitUp: number;
        /**
         * Whether or not RADIUS accounting is enabled
         */
        radiusAccountingEnabled: boolean;
        /**
         * List of RADIUS accounting 802.1X servers to be used for authentication
         */
        radiusAccountingServers: outputs.networks.GetWirelessSsidsItemRadiusAccountingServer[];
        /**
         * RADIUS attribute used to look up group policies
         */
        radiusAttributeForGroupPolicies: string;
        /**
         * Whether RADIUS authentication is enabled
         */
        radiusEnabled: boolean;
        /**
         * Policy which determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable
         */
        radiusFailoverPolicy: string;
        /**
         * Policy which determines which RADIUS server will be contacted first in an authentication attempt, and the ordering of any necessary retry attempts
         */
        radiusLoadBalancingPolicy: string;
        /**
         * List of RADIUS 802.1X servers to be used for authentication
         */
        radiusServers: outputs.networks.GetWirelessSsidsItemRadiusServer[];
        /**
         * The type of splash page for the SSID
         */
        splashPage: string;
        /**
         * Splash page timeout
         */
        splashTimeout: string;
        /**
         * SSID Administrator access status
         */
        ssidAdminAccessible: boolean;
        /**
         * Whether the SSID is advertised or hidden by the AP
         */
        visible: boolean;
        /**
         * Allow users to access a configurable list of IP ranges prior to sign-on
         */
        walledGardenEnabled: boolean;
        /**
         * Domain names and IP address ranges available in Walled Garden mode
         */
        walledGardenRanges: string[];
        /**
         * The types of WPA encryption
         */
        wpaEncryptionMode: string;
    }

    export interface GetWirelessSsidsItemRadiusAccountingServer {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate: string;
        /**
         * IP address (or FQDN) to which the APs will send RADIUS accounting messages
         */
        host: string;
        /**
         * The ID of the Openroaming Certificate attached to radius server
         */
        openRoamingCertificateId: number;
        /**
         * Port on the RADIUS server that is listening for accounting messages
         */
        port: number;
    }

    export interface GetWirelessSsidsItemRadiusServer {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate: string;
        /**
         * IP address (or FQDN) of your RADIUS server
         */
        host: string;
        /**
         * The ID of the Openroaming Certificate attached to radius server
         */
        openRoamingCertificateId: number;
        /**
         * UDP port the RADIUS server listens on for Access-requests
         */
        port: number;
    }

    export interface GetWirelessSsidsSchedulesItem {
        enabled: boolean;
        ranges: outputs.networks.GetWirelessSsidsSchedulesItemRange[];
    }

    export interface GetWirelessSsidsSchedulesItemRange {
        endDay: string;
        endTime: string;
        startDay: string;
        startTime: string;
    }

    export interface GetWirelessSsidsSplashSettingsItem {
        /**
         * Whether or not to allow simultaneous logins from different devices.
         */
        allowSimultaneousLogins: boolean;
        /**
         * Details associated with billing splash
         */
        billing: outputs.networks.GetWirelessSsidsSplashSettingsItemBilling;
        /**
         * How restricted allowing traffic should be. If true, all traffic types are blocked until the splash page is acknowledged. If false, all non-HTTP traffic is allowed before the splash page is acknowledged.
         */
        blockAllTrafficBeforeSignOn: boolean;
        /**
         * How login attempts should be handled when the controller is unreachable.
         */
        controllerDisconnectionBehavior: string;
        /**
         * Details associated with guest sponsored splash
         */
        guestSponsorship: outputs.networks.GetWirelessSsidsSplashSettingsItemGuestSponsorship;
        /**
         * The custom redirect URL where the users will go after the splash page.
         */
        redirectUrl: string;
        /**
         * Self-registration for splash with Meraki authentication.
         */
        selfRegistration: outputs.networks.GetWirelessSsidsSplashSettingsItemSelfRegistration;
        /**
         * Systems Manager sentry enrollment splash settings.
         */
        sentryEnrollment: outputs.networks.GetWirelessSsidsSplashSettingsItemSentryEnrollment;
        /**
         * The image used in the splash page.
         */
        splashImage: outputs.networks.GetWirelessSsidsSplashSettingsItemSplashImage;
        /**
         * The logo used in the splash page.
         */
        splashLogo: outputs.networks.GetWirelessSsidsSplashSettingsItemSplashLogo;
        /**
         * The type of splash page for this SSID
         */
        splashPage: string;
        /**
         * The prepaid front image used in the splash page.
         */
        splashPrepaidFront: outputs.networks.GetWirelessSsidsSplashSettingsItemSplashPrepaidFront;
        /**
         * Splash timeout in minutes.
         */
        splashTimeout: number;
        /**
         * The custom splash URL of the click-through splash page.
         */
        splashUrl: string;
        /**
         * SSID number
         */
        ssidNumber: number;
        /**
         * The id of the selected splash theme.
         */
        themeId: string;
        /**
         * The Boolean indicating whether the the user will be redirected to the custom redirect URL after the splash page.
         */
        useRedirectUrl: boolean;
        /**
         * Boolean indicating whether the users will be redirected to the custom splash url
         */
        useSplashUrl: boolean;
        /**
         * The welcome message for the users on the splash page.
         */
        welcomeMessage: string;
    }

    export interface GetWirelessSsidsSplashSettingsItemBilling {
        /**
         * Details associated with a free access plan with limits
         */
        freeAccess: outputs.networks.GetWirelessSsidsSplashSettingsItemBillingFreeAccess;
        /**
         * Whether or not billing uses the fast login prepaid access option.
         */
        prepaidAccessFastLoginEnabled: boolean;
        /**
         * The email address that reeceives replies from clients
         */
        replyToEmailAddress: string;
    }

    export interface GetWirelessSsidsSplashSettingsItemBillingFreeAccess {
        /**
         * How long a device can use a network for free.
         */
        durationInMinutes: number;
        /**
         * Whether or not free access is enabled.
         */
        enabled: boolean;
    }

    export interface GetWirelessSsidsSplashSettingsItemGuestSponsorship {
        /**
         * Duration in minutes of sponsored guest authorization.
         */
        durationInMinutes: number;
        /**
         * Whether or not guests can specify how much time they are requesting.
         */
        guestCanRequestTimeframe: boolean;
    }

    export interface GetWirelessSsidsSplashSettingsItemSelfRegistration {
        /**
         * How created user accounts should be authorized.
         */
        authorizationType: string;
        /**
         * Whether or not to allow users to create their own account on the network.
         */
        enabled: boolean;
    }

    export interface GetWirelessSsidsSplashSettingsItemSentryEnrollment {
        /**
         * The system types that the Sentry enforces.
         */
        enforcedSystems: string[];
        /**
         * The strength of the enforcement of selected system types.
         */
        strength: string;
        /**
         * Systems Manager network targeted for sentry enrollment.
         */
        systemsManagerNetwork: outputs.networks.GetWirelessSsidsSplashSettingsItemSentryEnrollmentSystemsManagerNetwork;
    }

    export interface GetWirelessSsidsSplashSettingsItemSentryEnrollmentSystemsManagerNetwork {
        /**
         * The network ID of the Systems Manager network.
         */
        id: string;
    }

    export interface GetWirelessSsidsSplashSettingsItemSplashImage {
        /**
         * The extension of the image file.
         */
        extension: string;
        /**
         * The MD5 value of the image file.
         */
        md5: string;
    }

    export interface GetWirelessSsidsSplashSettingsItemSplashLogo {
        /**
         * The extension of the logo file.
         */
        extension: string;
        /**
         * The MD5 value of the logo file.
         */
        md5: string;
    }

    export interface GetWirelessSsidsSplashSettingsItemSplashPrepaidFront {
        /**
         * The extension of the prepaid front image file.
         */
        extension: string;
        /**
         * The MD5 value of the prepaid front image file.
         */
        md5: string;
    }

    export interface GetWirelessSsidsTrafficShapingRulesItem {
        /**
         * Whether default traffic shaping rules are enabled (true) or disabled (false). There are 4 default rules, which can be seen on your network's traffic shaping page. Note that default rules count against the rule limit of 8.
         */
        defaultRulesEnabled: boolean;
        /**
         * An array of traffic shaping rules. Rules are applied in the order that
         * they are specified in. An empty list (or null) means no rules. Note that
         * you are allowed a maximum of 8 rules.
         */
        rules: outputs.networks.GetWirelessSsidsTrafficShapingRulesItemRule[];
        /**
         * Whether traffic shaping rules are applied to clients on your SSID.
         */
        trafficShapingEnabled: boolean;
    }

    export interface GetWirelessSsidsTrafficShapingRulesItemRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions: outputs.networks.GetWirelessSsidsTrafficShapingRulesItemRuleDefinition[];
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue: number;
        /**
         * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
         * null means 'Do not set PCP tag'.
         */
        pcpTagValue: number;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits: outputs.networks.GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimits;
    }

    export interface GetWirelessSsidsTrafficShapingRulesItemRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type: string;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         * custom ports.
         * If "type" is 'application' or 'applicationCategory', then "value" must be an object
         * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         * endpoint).
         */
        value: string;
    }

    export interface GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits: outputs.networks.GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimits;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface GetWirelessSsidsTrafficShapingRulesItemRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp: number;
    }

    export interface GetWirelessSsidsVpnItem {
        concentrator: outputs.networks.GetWirelessSsidsVpnItemConcentrator;
        failover: outputs.networks.GetWirelessSsidsVpnItemFailover;
        splitTunnel: outputs.networks.GetWirelessSsidsVpnItemSplitTunnel;
    }

    export interface GetWirelessSsidsVpnItemConcentrator {
        name: string;
        networkId: string;
        vlanId: number;
    }

    export interface GetWirelessSsidsVpnItemFailover {
        heartbeatInterval: number;
        idleTimeout: number;
        requestIp: string;
    }

    export interface GetWirelessSsidsVpnItemSplitTunnel {
        enabled: boolean;
        rules: outputs.networks.GetWirelessSsidsVpnItemSplitTunnelRule[];
    }

    export interface GetWirelessSsidsVpnItemSplitTunnelRule {
        comment: string;
        destCidr: string;
        destPort: string;
        policy: string;
        protocol: string;
    }

    export interface GetWirelessUsageHistoryItem {
        /**
         * The end time of the query range
         */
        endTs: string;
        /**
         * Received kilobytes-per-second
         */
        receivedKbps: number;
        /**
         * Sent kilobytes-per-second
         */
        sentKbps: number;
        /**
         * The start time of the query range
         */
        startTs: string;
        /**
         * Total usage in kilobytes-per-second
         */
        totalKbps: number;
    }

    export interface GroupPoliciesBandwidth {
        /**
         * The bandwidth limits object, specifying upload and download speed for clients bound to the group policy. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits: outputs.networks.GroupPoliciesBandwidthBandwidthLimits;
        /**
         * How bandwidth limits are enforced. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface GroupPoliciesBandwidthBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps). null indicates no limit
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps). null indicates no limit
         */
        limitUp: number;
    }

    export interface GroupPoliciesBonjourForwarding {
        /**
         * A list of the Bonjour forwarding rules for your group policy. If 'settings' is set to 'custom', at least one rule must be specified.
         */
        rules: outputs.networks.GroupPoliciesBonjourForwardingRule[];
        /**
         * How Bonjour rules are applied. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface GroupPoliciesBonjourForwardingRule {
        /**
         * A description for your Bonjour forwarding rule. Optional.
         */
        description: string;
        /**
         * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
         */
        services: string[];
        /**
         * The ID of the service VLAN. Required.
         */
        vlanId: string;
    }

    export interface GroupPoliciesContentFiltering {
        /**
         * Settings for allowed URL patterns
         */
        allowedUrlPatterns: outputs.networks.GroupPoliciesContentFilteringAllowedUrlPatterns;
        /**
         * Settings for blocked URL categories
         */
        blockedUrlCategories: outputs.networks.GroupPoliciesContentFilteringBlockedUrlCategories;
        /**
         * Settings for blocked URL patterns
         */
        blockedUrlPatterns: outputs.networks.GroupPoliciesContentFilteringBlockedUrlPatterns;
    }

    export interface GroupPoliciesContentFilteringAllowedUrlPatterns {
        /**
         * A list of URL patterns that are allowed
         */
        patterns: string[];
        /**
         * How URL patterns are applied. Can be 'network default', 'append' or 'override'.
         */
        settings: string;
    }

    export interface GroupPoliciesContentFilteringBlockedUrlCategories {
        /**
         * A list of URL categories to block
         */
        categories: string[];
        /**
         * How URL categories are applied. Can be 'network default', 'append' or 'override'.
         */
        settings: string;
    }

    export interface GroupPoliciesContentFilteringBlockedUrlPatterns {
        /**
         * A list of URL patterns that are blocked
         */
        patterns: string[];
        /**
         * How URL patterns are applied. Can be 'network default', 'append' or 'override'.
         */
        settings: string;
    }

    export interface GroupPoliciesFirewallAndTrafficShaping {
        /**
         * An ordered array of the L3 firewall rules
         */
        l3FirewallRules: outputs.networks.GroupPoliciesFirewallAndTrafficShapingL3FirewallRule[];
        /**
         * An ordered array of L7 firewall rules
         */
        l7FirewallRules: outputs.networks.GroupPoliciesFirewallAndTrafficShapingL7FirewallRule[];
        /**
         * How firewall and traffic shaping rules are enforced. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
        /**
         * An array of traffic shaping rules. Rules are applied in the order that
         * they are specified in. An empty list (or null) means no rules. Note that
         * you are allowed a maximum of 8 rules.
         */
        trafficShapingRules: outputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule[];
    }

    export interface GroupPoliciesFirewallAndTrafficShapingL3FirewallRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Destination IP address (in IP or CIDR notation), a fully-qualified domain name (FQDN, if your network supports it) or 'any'.
         */
        destCidr: string;
        /**
         * Destination port (integer in the range 1-65535), a port range (e.g. 8080-9090), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingL7FirewallRule {
        /**
         * The policy applied to matching traffic. Must be 'deny'.
         */
        policy: string;
        /**
         * Type of the L7 Rule. Must be 'application', 'applicationCategory', 'host', 'port' or 'ipRange'
         */
        type: string;
        /**
         * The 'value' of what you want to block. If 'type' is 'host', 'port' or 'ipRange', 'value' must be a string matching either a hostname (e.g. somewhere.com), a port (e.g. 8080), or an IP range (e.g. 192.1.0.0/16). If 'type' is 'application' or 'applicationCategory', then 'value' must be an object with an ID for the application.
         */
        value: string;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions: outputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition[];
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue: number;
        /**
         * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
         * null means 'Do not set PCP tag'.
         */
        pcpTagValue: number;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits: outputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits;
        /**
         * A string, indicating the priority level for packets bound to your rule.
         * Can be 'low', 'normal' or 'high'.
         */
        priority: string;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type: string;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         * custom ports.
         * If "type" is 'application' or 'applicationCategory', then "value" must be an object
         * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         * endpoint).
         */
        value: string;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits: outputs.networks.GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface GroupPoliciesFirewallAndTrafficShapingTrafficShapingRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp: number;
    }

    export interface GroupPoliciesScheduling {
        /**
         * Whether scheduling is enabled (true) or disabled (false). Defaults to false. If true, the schedule objects for each day of the week (monday - sunday) are parsed.
         */
        enabled: boolean;
        /**
         * The schedule object for Friday.
         */
        friday: outputs.networks.GroupPoliciesSchedulingFriday;
        /**
         * The schedule object for Monday.
         */
        monday: outputs.networks.GroupPoliciesSchedulingMonday;
        /**
         * The schedule object for Saturday.
         */
        saturday: outputs.networks.GroupPoliciesSchedulingSaturday;
        /**
         * The schedule object for Sunday.
         */
        sunday: outputs.networks.GroupPoliciesSchedulingSunday;
        /**
         * The schedule object for Thursday.
         */
        thursday: outputs.networks.GroupPoliciesSchedulingThursday;
        /**
         * The schedule object for Tuesday.
         */
        tuesday: outputs.networks.GroupPoliciesSchedulingTuesday;
        /**
         * The schedule object for Wednesday.
         */
        wednesday: outputs.networks.GroupPoliciesSchedulingWednesday;
    }

    export interface GroupPoliciesSchedulingFriday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GroupPoliciesSchedulingMonday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GroupPoliciesSchedulingSaturday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GroupPoliciesSchedulingSunday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GroupPoliciesSchedulingThursday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GroupPoliciesSchedulingTuesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GroupPoliciesSchedulingWednesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface GroupPoliciesVlanTagging {
        /**
         * How VLAN tagging is applied. Can be 'network default', 'ignore' or 'custom'.
         */
        settings: string;
        /**
         * The ID of the vlan you want to tag. This only applies if 'settings' is set to 'custom'.
         */
        vlanId: string;
    }

    export interface MerakiAuthUsersAuthorization {
        /**
         * User is authorized by the account email address
         */
        authorizedByEmail: string;
        /**
         * User is authorized by the account name
         */
        authorizedByName: string;
        /**
         * Authorized zone of the user
         */
        authorizedZone: string;
        /**
         * Authorization expiration time
         */
        expiresAt: string;
        /**
         * SSID number
         */
        ssidNumber: number;
    }

    export interface MqttBrokersItem {
        /**
         * Authentication settings of the MQTT broker
         */
        authentication: outputs.networks.MqttBrokersItemAuthentication;
        /**
         * Host name/IP address where the MQTT broker runs.
         */
        host: string;
        /**
         * ID of the MQTT Broker.
         */
        id: string;
        /**
         * Name of the MQTT Broker.
         */
        name: string;
        /**
         * Host port though which the MQTT broker can be reached.
         */
        port: number;
        /**
         * Security settings of the MQTT broker.
         */
        security: outputs.networks.MqttBrokersItemSecurity;
    }

    export interface MqttBrokersItemAuthentication {
        /**
         * Username for the MQTT broker.
         */
        username: string;
    }

    export interface MqttBrokersItemSecurity {
        /**
         * Security protocol of the MQTT broker.
         */
        mode: string;
        /**
         * TLS settings of the MQTT broker.
         */
        tls: outputs.networks.MqttBrokersItemSecurityTls;
    }

    export interface MqttBrokersItemSecurityTls {
        /**
         * Indicates whether the CA certificate is set
         */
        hasCaCertificate: boolean;
        /**
         * Whether the TLS hostname verification is enabled for the MQTT broker.
         */
        verifyHostnames: boolean;
    }

    export interface MqttBrokersParameters {
        /**
         * Authentication settings of the MQTT broker
         */
        authentication: outputs.networks.MqttBrokersParametersAuthentication;
        /**
         * Host name/IP address where the MQTT broker runs.
         */
        host: string;
        /**
         * Name of the MQTT broker.
         */
        name: string;
        /**
         * Host port though which the MQTT broker can be reached.
         */
        port: number;
        /**
         * Security settings of the MQTT broker.
         */
        security: outputs.networks.MqttBrokersParametersSecurity;
    }

    export interface MqttBrokersParametersAuthentication {
        /**
         * Password for the MQTT broker.
         */
        password: string;
        /**
         * Username for the MQTT broker.
         */
        username: string;
    }

    export interface MqttBrokersParametersSecurity {
        /**
         * Security protocol of the MQTT broker.
         */
        mode: string;
        /**
         * TLS settings of the MQTT broker.
         */
        tls: outputs.networks.MqttBrokersParametersSecurityTls;
    }

    export interface MqttBrokersParametersSecurityTls {
        /**
         * CA Certificate of the MQTT broker.
         */
        caCertificate: string;
        /**
         * Whether the TLS hostname verification is enabled for the MQTT broker.
         */
        verifyHostnames: boolean;
    }

    export interface SensorAlertsProfilesCondition {
        /**
         * If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
         */
        direction?: string;
        /**
         * Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
         */
        duration?: number;
        /**
         * The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
         */
        metric?: string;
        /**
         * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
         */
        threshold?: outputs.networks.SensorAlertsProfilesConditionThreshold;
    }

    export interface SensorAlertsProfilesConditionThreshold {
        /**
         * Apparent power threshold. 'draw' must be provided.
         */
        apparentPower?: outputs.networks.SensorAlertsProfilesConditionThresholdApparentPower;
        /**
         * Electrical current threshold. 'level' must be provided.
         */
        current?: outputs.networks.SensorAlertsProfilesConditionThresholdCurrent;
        /**
         * Door open threshold. 'open' must be provided and set to true.
         */
        door?: outputs.networks.SensorAlertsProfilesConditionThresholdDoor;
        /**
         * Electrical frequency threshold. 'level' must be provided.
         */
        frequency?: outputs.networks.SensorAlertsProfilesConditionThresholdFrequency;
        /**
         * Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
         */
        humidity?: outputs.networks.SensorAlertsProfilesConditionThresholdHumidity;
        /**
         * Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
         */
        indoorAirQuality?: outputs.networks.SensorAlertsProfilesConditionThresholdIndoorAirQuality;
        /**
         * Noise threshold. 'ambient' must be provided.
         */
        noise?: outputs.networks.SensorAlertsProfilesConditionThresholdNoise;
        /**
         * PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        pm25?: outputs.networks.SensorAlertsProfilesConditionThresholdPm25;
        /**
         * Power factor threshold. 'percentage' must be provided.
         */
        powerFactor?: outputs.networks.SensorAlertsProfilesConditionThresholdPowerFactor;
        /**
         * Real power threshold. 'draw' must be provided.
         */
        realPower?: outputs.networks.SensorAlertsProfilesConditionThresholdRealPower;
        /**
         * Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
         */
        temperature?: outputs.networks.SensorAlertsProfilesConditionThresholdTemperature;
        /**
         * TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        tvoc?: outputs.networks.SensorAlertsProfilesConditionThresholdTvoc;
        /**
         * Upstream power threshold. 'outageDetected' must be provided and set to true.
         */
        upstreamPower?: outputs.networks.SensorAlertsProfilesConditionThresholdUpstreamPower;
        /**
         * Voltage threshold. 'level' must be provided.
         */
        voltage?: outputs.networks.SensorAlertsProfilesConditionThresholdVoltage;
        /**
         * Water detection threshold. 'present' must be provided and set to true.
         */
        water?: outputs.networks.SensorAlertsProfilesConditionThresholdWater;
    }

    export interface SensorAlertsProfilesConditionThresholdApparentPower {
        /**
         * Alerting threshold in volt-amps. Must be between 0 and 3750.
         */
        draw?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdCurrent {
        /**
         * Alerting threshold in amps. Must be between 0 and 15.
         */
        draw?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdDoor {
        /**
         * Alerting threshold for a door open event. Must be set to true.
         */
        open?: boolean;
    }

    export interface SensorAlertsProfilesConditionThresholdFrequency {
        /**
         * Alerting threshold in hertz. Must be between 0 and 60.
         */
        level?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdHumidity {
        /**
         * Alerting threshold as a qualitative humidity level.
         */
        quality?: string;
        /**
         * Alerting threshold in %RH.
         */
        relativePercentage?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdIndoorAirQuality {
        /**
         * Alerting threshold as a qualitative indoor air quality level.
         */
        quality?: string;
        /**
         * Alerting threshold as indoor air quality score.
         */
        score?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdNoise {
        /**
         * Ambient noise threshold. One of 'level' or 'quality' must be provided.
         */
        ambient?: outputs.networks.SensorAlertsProfilesConditionThresholdNoiseAmbient;
    }

    export interface SensorAlertsProfilesConditionThresholdNoiseAmbient {
        /**
         * Alerting threshold as adjusted decibels.
         */
        level?: number;
        /**
         * Alerting threshold as a qualitative ambient noise level.
         */
        quality?: string;
    }

    export interface SensorAlertsProfilesConditionThresholdPm25 {
        /**
         * Alerting threshold as PM2.5 parts per million.
         */
        concentration?: number;
        /**
         * Alerting threshold as a qualitative PM2.5 level.
         */
        quality?: string;
    }

    export interface SensorAlertsProfilesConditionThresholdPowerFactor {
        /**
         * Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
         */
        percentage?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdRealPower {
        /**
         * Alerting threshold in watts. Must be between 0 and 3750.
         */
        draw?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdTemperature {
        /**
         * Alerting threshold in degrees Celsius.
         */
        celsius?: number;
        /**
         * Alerting threshold in degrees Fahrenheit.
         */
        fahrenheit?: number;
        /**
         * Alerting threshold as a qualitative temperature level.
         */
        quality?: string;
    }

    export interface SensorAlertsProfilesConditionThresholdTvoc {
        /**
         * Alerting threshold as TVOC micrograms per cubic meter.
         */
        concentration?: number;
        /**
         * Alerting threshold as a qualitative TVOC level.
         */
        quality?: string;
    }

    export interface SensorAlertsProfilesConditionThresholdUpstreamPower {
        /**
         * Alerting threshold for an upstream power event. Must be set to true.
         */
        outageDetected?: boolean;
    }

    export interface SensorAlertsProfilesConditionThresholdVoltage {
        /**
         * Alerting threshold in volts. Must be between 0 and 250.
         */
        level?: number;
    }

    export interface SensorAlertsProfilesConditionThresholdWater {
        /**
         * Alerting threshold for a water detection event. Must be set to true.
         */
        present?: boolean;
    }

    export interface SensorAlertsProfilesConditionsResponse {
        /**
         * If 'above', an alert will be sent when a sensor reads above the threshold. If 'below', an alert will be sent when a sensor reads below the threshold. Only applicable for temperature, humidity, realPower, apparentPower, powerFactor, voltage, current, and frequency thresholds.
         */
        direction: string;
        /**
         * Length of time in seconds that the triggering state must persist before an alert is sent. Available options are 0 seconds, 1 minute, 2 minutes, 3 minutes, 4 minutes, 5 minutes, 10 minutes, 15 minutes, 30 minutes, 1 hour, 2 hours, 4 hours, and 8 hours. Default is 0.
         */
        duration: number;
        /**
         * The type of sensor metric that will be monitored for changes. Available metrics are apparentPower, co2, current, door, frequency, humidity, indoorAirQuality, noise, pm25, powerFactor, realPower, temperature, tvoc, upstreamPower, voltage, and water.
         */
        metric: string;
        /**
         * Threshold for sensor readings that will cause an alert to be sent. This object should contain a single property key matching the condition's 'metric' value.
         */
        threshold: outputs.networks.SensorAlertsProfilesConditionsResponseThreshold;
    }

    export interface SensorAlertsProfilesConditionsResponseThreshold {
        /**
         * Apparent power threshold. 'draw' must be provided.
         */
        apparentPower: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdApparentPower;
        /**
         * Electrical current threshold. 'level' must be provided.
         */
        current: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdCurrent;
        /**
         * Door open threshold. 'open' must be provided and set to true.
         */
        door: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdDoor;
        /**
         * Electrical frequency threshold. 'level' must be provided.
         */
        frequency: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdFrequency;
        /**
         * Humidity threshold. One of 'relativePercentage' or 'quality' must be provided.
         */
        humidity: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdHumidity;
        /**
         * Indoor air quality score threshold. One of 'score' or 'quality' must be provided.
         */
        indoorAirQuality: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality;
        /**
         * Noise threshold. 'ambient' must be provided.
         */
        noise: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdNoise;
        /**
         * PM2.5 concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        pm25: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdPm25;
        /**
         * Power factor threshold. 'percentage' must be provided.
         */
        powerFactor: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdPowerFactor;
        /**
         * Real power threshold. 'draw' must be provided.
         */
        realPower: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdRealPower;
        /**
         * Temperature threshold. One of 'celsius', 'fahrenheit', or 'quality' must be provided.
         */
        temperature: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdTemperature;
        /**
         * TVOC concentration threshold. One of 'concentration' or 'quality' must be provided.
         */
        tvoc: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdTvoc;
        /**
         * Upstream power threshold. 'outageDetected' must be provided and set to true.
         */
        upstreamPower: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdUpstreamPower;
        /**
         * Voltage threshold. 'level' must be provided.
         */
        voltage: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdVoltage;
        /**
         * Water detection threshold. 'present' must be provided and set to true.
         */
        water: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdWater;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdApparentPower {
        /**
         * Alerting threshold in volt-amps. Must be between 0 and 3750.
         */
        draw: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdCurrent {
        /**
         * Alerting threshold in amps. Must be between 0 and 15.
         */
        draw: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdDoor {
        /**
         * Alerting threshold for a door open event. Must be set to true.
         */
        open: boolean;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdFrequency {
        /**
         * Alerting threshold in hertz. Must be between 0 and 60.
         */
        level: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdHumidity {
        /**
         * Alerting threshold as a qualitative humidity level.
         */
        quality: string;
        /**
         * Alerting threshold in %RH.
         */
        relativePercentage: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdIndoorAirQuality {
        /**
         * Alerting threshold as a qualitative indoor air quality level.
         */
        quality: string;
        /**
         * Alerting threshold as indoor air quality score.
         */
        score: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdNoise {
        /**
         * Ambient noise threshold. One of 'level' or 'quality' must be provided.
         */
        ambient: outputs.networks.SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdNoiseAmbient {
        /**
         * Alerting threshold as adjusted decibels.
         */
        level: number;
        /**
         * Alerting threshold as a qualitative ambient noise level.
         */
        quality: string;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdPm25 {
        /**
         * Alerting threshold as PM2.5 parts per million.
         */
        concentration: number;
        /**
         * Alerting threshold as a qualitative PM2.5 level.
         */
        quality: string;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdPowerFactor {
        /**
         * Alerting threshold as the ratio of active power to apparent power. Must be between 0 and 100.
         */
        percentage: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdRealPower {
        /**
         * Alerting threshold in watts. Must be between 0 and 3750.
         */
        draw: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdTemperature {
        /**
         * Alerting threshold in degrees Celsius.
         */
        celsius: number;
        /**
         * Alerting threshold in degrees Fahrenheit.
         */
        fahrenheit: number;
        /**
         * Alerting threshold as a qualitative temperature level.
         */
        quality: string;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdTvoc {
        /**
         * Alerting threshold as TVOC micrograms per cubic meter.
         */
        concentration: number;
        /**
         * Alerting threshold as a qualitative TVOC level.
         */
        quality: string;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdUpstreamPower {
        /**
         * Alerting threshold for an upstream power event. Must be set to true.
         */
        outageDetected: boolean;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdVoltage {
        /**
         * Alerting threshold in volts. Must be between 0 and 250.
         */
        level: number;
    }

    export interface SensorAlertsProfilesConditionsResponseThresholdWater {
        /**
         * Alerting threshold for a water detection event. Must be set to true.
         */
        present: boolean;
    }

    export interface SensorAlertsProfilesRecipients {
        /**
         * A list of emails that will receive information about the alert.
         */
        emails: string[];
        /**
         * A list of webhook endpoint IDs that will receive information about the alert.
         */
        httpServerIds?: string[];
        /**
         * A list of SMS numbers that will receive information about the alert.
         */
        smsNumbers: string[];
    }

    export interface SensorAlertsProfilesSchedule {
        /**
         * ID of the sensor schedule to use with the alert profile. If not defined, the alert profile will be active at all times.
         */
        id: string;
        /**
         * Name of the sensor schedule to use with the alert profile.
         */
        name: string;
    }

    export interface SettingsFips {
        /**
         * Enables / disables FIPS on the network.
         */
        enabled: boolean;
    }

    export interface SettingsLocalStatusPage {
        /**
         * A hash of Local Status page(s)' authentication options applied to the Network.
         */
        authentication: outputs.networks.SettingsLocalStatusPageAuthentication;
    }

    export interface SettingsLocalStatusPageAuthentication {
        /**
         * Enables / disables the authentication on Local Status page(s).
         */
        enabled: boolean;
        /**
         * The password used for Local Status Page(s). Set this to null to clear the password.
         */
        password?: string;
        /**
         * The username used for Local Status Page(s).
         */
        username: string;
    }

    export interface SettingsNamedVlans {
        /**
         * Enables / disables Named VLANs on the Network.
         */
        enabled: boolean;
    }

    export interface SettingsSecurePort {
        /**
         * Enables / disables SecureConnect on the network. Optional.
         */
        enabled: boolean;
    }

    export interface SmBypassActivationLockAttemptsData {
        status2090938209: outputs.networks.SmBypassActivationLockAttemptsDataStatus2090938209;
        status38290139892: outputs.networks.SmBypassActivationLockAttemptsDataStatus38290139892;
    }

    export interface SmBypassActivationLockAttemptsDataStatus2090938209 {
        errors: string[];
        success: boolean;
    }

    export interface SmBypassActivationLockAttemptsDataStatus38290139892 {
        success: boolean;
    }

    export interface SmDevicesCheckinItem {
        /**
         * The Meraki Ids of the set of devices.
         */
        ids: string[];
    }

    export interface SmDevicesCheckinParameters {
        /**
         * The ids of the devices to be checked-in.
         */
        ids: string[];
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.
         */
        scopes: string[];
        /**
         * The serials of the devices to be checked-in.
         */
        serials: string[];
        /**
         * The wifiMacs of the devices to be checked-in.
         */
        wifiMacs: string[];
    }

    export interface SmDevicesFieldsItem {
        /**
         * The Meraki Id of the device record.
         */
        id: string;
        /**
         * The name of the device.
         */
        name: string;
        /**
         * Notes associated with the device.
         */
        notes: string;
        /**
         * The device serial.
         */
        serial: string;
        /**
         * The MAC of the device.
         */
        wifiMac: string;
    }

    export interface SmDevicesFieldsParameters {
        /**
         * The new fields of the device. Each field of this object is optional.
         */
        deviceFields: outputs.networks.SmDevicesFieldsParametersDeviceFields;
        /**
         * The id of the device to be modified.
         */
        id: string;
        /**
         * The serial of the device to be modified.
         */
        serial: string;
        /**
         * The wifiMac of the device to be modified.
         */
        wifiMac: string;
    }

    export interface SmDevicesFieldsParametersDeviceFields {
        /**
         * New name for the device
         */
        name: string;
        /**
         * New notes for the device
         */
        notes: string;
    }

    export interface SmDevicesInstallAppsParameters {
        /**
         * ids of applications to be installed
         */
        appIds: string[];
        /**
         * By default, installation of an app which is believed to already be present on the device will be skipped. If you'd like to force the installation of the app, set this parameter to true.
         */
        force: boolean;
    }

    export interface SmDevicesLockItem {
        /**
         * The Meraki Ids of the set of devices.
         */
        ids: string[];
    }

    export interface SmDevicesLockParameters {
        /**
         * The ids of the devices to be locked.
         */
        ids: string[];
        /**
         * The pin number for locking macOS devices (a six digit number). Required only for macOS devices.
         */
        pin: number;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.
         */
        scopes: string[];
        /**
         * The serials of the devices to be locked.
         */
        serials: string[];
        /**
         * The wifiMacs of the devices to be locked.
         */
        wifiMacs: string[];
    }

    export interface SmDevicesModifyTagsItem {
        /**
         * The Meraki Id of the device record.
         */
        id: string;
        /**
         * The device serial.
         */
        serial: string;
        /**
         * An array of tags associated with the device.
         */
        tags: string[];
        /**
         * The MAC of the device.
         */
        wifiMac: string;
    }

    export interface SmDevicesModifyTagsParameters {
        /**
         * The ids of the devices to be modified.
         */
        ids: string[];
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.
         */
        scopes: string[];
        /**
         * The serials of the devices to be modified.
         */
        serials: string[];
        /**
         * The tags to be added, deleted, or updated.
         */
        tags: string[];
        /**
         * One of add, delete, or update. Only devices that have been modified will be returned.
         */
        updateAction: string;
        /**
         * The wifiMacs of the devices to be modified.
         */
        wifiMacs: string[];
    }

    export interface SmDevicesMoveItem {
        /**
         * The Meraki Ids of the set of devices.
         */
        ids: string[];
        /**
         * The network to which the devices was moved.
         */
        newNetwork: string;
    }

    export interface SmDevicesMoveParameters {
        /**
         * The ids of the devices to be moved.
         */
        ids: string[];
        /**
         * The new network to which the devices will be moved.
         */
        newNetwork: string;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be moved.
         */
        scopes: string[];
        /**
         * The serials of the devices to be moved.
         */
        serials: string[];
        /**
         * The wifiMacs of the devices to be moved.
         */
        wifiMacs: string[];
    }

    export interface SmDevicesRebootItem {
        /**
         * The Meraki Ids of the set of endpoints.
         */
        ids: string[];
    }

    export interface SmDevicesRebootParameters {
        /**
         * The ids of the endpoints to be rebooted.
         */
        ids: string[];
        /**
         * The KextPaths of the endpoints to be rebooted. Available for macOS 11+
         */
        kextPaths: string[];
        /**
         * Whether or not to notify the user before rebooting the endpoint. Available for macOS 11.3+
         */
        notifyUser: boolean;
        /**
         * Whether or not to rebuild the kernel cache when rebooting the endpoint. Available for macOS 11+
         */
        rebuildKernelCache: boolean;
        /**
         * Whether or not the request requires network tethering. Available for macOS and supervised iOS or tvOS
         */
        requestRequiresNetworkTether: boolean;
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be rebooted.
         */
        scopes: string[];
        /**
         * The serials of the endpoints to be rebooted.
         */
        serials: string[];
        /**
         * The wifiMacs of the endpoints to be rebooted.
         */
        wifiMacs: string[];
    }

    export interface SmDevicesShutdownItem {
        /**
         * The Meraki Ids of the set of endpoints.
         */
        ids: string[];
    }

    export interface SmDevicesShutdownParameters {
        /**
         * The ids of the endpoints to be shutdown.
         */
        ids: string[];
        /**
         * The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the endpoints to be shutdown.
         */
        scopes: string[];
        /**
         * The serials of the endpoints to be shutdown.
         */
        serials: string[];
        /**
         * The wifiMacs of the endpoints to be shutdown.
         */
        wifiMacs: string[];
    }

    export interface SmDevicesUnenrollItem {
        /**
         * Boolean indicating whether the operation was completed successfully.
         */
        success: boolean;
    }

    export interface SmDevicesUninstallAppsParameters {
        /**
         * ids of applications to be uninstalled
         */
        appIds: string[];
    }

    export interface SmDevicesWipeItem {
        /**
         * The Meraki Id of the devices.
         */
        id: string;
    }

    export interface SmDevicesWipeParameters {
        /**
         * The id of the device to be wiped.
         */
        id: string;
        /**
         * The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.
         */
        pin: number;
        /**
         * The serial of the device to be wiped.
         */
        serial: string;
        /**
         * The wifiMac of the device to be wiped.
         */
        wifiMac: string;
    }

    export interface SnmpUser {
        /**
         * The passphrase for the SNMP user.
         */
        passphrase: string;
        /**
         * The username for the SNMP user.
         */
        username: string;
    }

    export interface SplitItem {
        /**
         * Networks after the split
         */
        resultingNetworks: outputs.networks.SplitItemResultingNetwork[];
    }

    export interface SplitItemResultingNetwork {
        /**
         * Enrollment string for the network
         */
        enrollmentString: string;
        /**
         * Network ID
         */
        id: string;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate: boolean;
        /**
         * Network name
         */
        name: string;
        /**
         * Notes for the network
         */
        notes: string;
        /**
         * Organization ID
         */
        organizationId: string;
        /**
         * List of the product types that the network supports
         */
        productTypes: string[];
        /**
         * Network tags
         */
        tags: string[];
        /**
         * Timezone of the network
         */
        timeZone: string;
        /**
         * URL to the network Dashboard UI
         */
        url: string;
    }

    export interface SwitchAccessControlListsRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Destination IP address (in IP or CIDR notation)
         */
        dstCidr: string;
        /**
         * Destination port
         */
        dstPort: string;
        /**
         * IP address version
         */
        ipVersion: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol
         */
        protocol: string;
        /**
         * Source IP address (in IP or CIDR notation)
         */
        srcCidr: string;
        /**
         * Source port
         */
        srcPort: string;
        /**
         * ncoming traffic VLAN
         */
        vlan: string;
    }

    export interface SwitchAccessControlListsRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Destination IP address (in IP or CIDR notation)
         */
        dstCidr: string;
        /**
         * Destination port
         */
        dstPort: string;
        /**
         * IP address version
         */
        ipVersion: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol
         */
        protocol: string;
        /**
         * Source IP address (in IP or CIDR notation)
         */
        srcCidr: string;
        /**
         * Source port
         */
        srcPort: string;
        /**
         * ncoming traffic VLAN
         */
        vlan: string;
    }

    export interface SwitchAccessPoliciesCounts {
        /**
         * Counts associated with ports
         */
        ports: outputs.networks.SwitchAccessPoliciesCountsPorts;
    }

    export interface SwitchAccessPoliciesCountsPorts {
        /**
         * Number of ports in the network with this policy. For template networks, this is the number of template ports (not child ports) with this policy.
         */
        withThisPolicy: number;
    }

    export interface SwitchAccessPoliciesDot1x {
        /**
         * Supports either 'both' or 'inbound'. Set to 'inbound' to allow unauthorized egress on the switchport. Set to 'both' to control both traffic directions with authorization. Defaults to 'both'
         */
        controlDirection: string;
    }

    export interface SwitchAccessPoliciesRadius {
        /**
         * Critical auth settings for when authentication is rejected by the RADIUS server
         */
        criticalAuth: outputs.networks.SwitchAccessPoliciesRadiusCriticalAuth;
        /**
         * VLAN that clients will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        failedAuthVlanId: number;
        /**
         * Re-authentication period in seconds. Will be null if hostMode is Multi-Auth
         */
        reAuthenticationInterval?: number;
    }

    export interface SwitchAccessPoliciesRadiusAccountingServer {
        /**
         * Public IP address of the RADIUS accounting server
         */
        host?: string;
        /**
         * UDP port that the RADIUS Accounting server listens on for access requests
         */
        port?: number;
        /**
         * RADIUS client shared secret
         */
        secret?: string;
    }

    export interface SwitchAccessPoliciesRadiusAccountingServersResponse {
        /**
         * Public IP address of the RADIUS accounting server
         */
        host: string;
        /**
         * UDP port that the RADIUS Accounting server listens on for access requests
         */
        port: number;
        /**
         * RADIUS client shared secret
         */
        secret: string;
    }

    export interface SwitchAccessPoliciesRadiusCriticalAuth {
        /**
         * VLAN that clients who use data will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        dataVlanId: number;
        /**
         * Enable to suspend port bounce when RADIUS servers are unreachable
         */
        suspendPortBounce: boolean;
        /**
         * VLAN that clients who use voice will be placed on when RADIUS authentication fails. Will be null if hostMode is Multi-Auth
         */
        voiceVlanId?: number;
    }

    export interface SwitchAccessPoliciesRadiusServer {
        /**
         * Public IP address of the RADIUS server
         */
        host?: string;
        /**
         * UDP port that the RADIUS server listens on for access requests
         */
        port?: number;
        /**
         * RADIUS client shared secret
         */
        secret?: string;
    }

    export interface SwitchAccessPoliciesRadiusServersResponse {
        /**
         * Public IP address of the RADIUS server
         */
        host: string;
        /**
         * UDP port that the RADIUS server listens on for access requests
         */
        port: number;
        /**
         * RADIUS client shared secret
         */
        secret: string;
    }

    export interface SwitchAlternateManagementInterfaceSwitch {
        /**
         * Switch alternative management IP. To remove a prior IP setting, provide an empty string
         */
        alternateManagementIp: string;
        /**
         * Switch gateway must be in IP format. Only and must be specified for Polaris switches
         */
        gateway: string;
        /**
         * Switch serial number
         */
        serial: string;
        /**
         * Switch subnet mask must be in IP format. Only and must be specified for Polaris switches
         */
        subnetMask: string;
    }

    export interface SwitchDhcpServerPolicyAlerts {
        /**
         * Alert settings for DHCP servers
         */
        email: outputs.networks.SwitchDhcpServerPolicyAlertsEmail;
    }

    export interface SwitchDhcpServerPolicyAlertsEmail {
        /**
         * When enabled, send an email if a new DHCP server is seen. Default value is false.
         */
        enabled: boolean;
    }

    export interface SwitchDhcpServerPolicyArpInspection {
        /**
         * Enable or disable Dynamic ARP Inspection on the network. Default value is false.
         */
        enabled: boolean;
        /**
         * List of switch models that does not support dynamic ARP inspection
         */
        unsupportedModels: string[];
    }

    export interface SwitchDhcpServerPolicyArpInspectionTrustedServersIpv4 {
        /**
         * IPv4 address of the trusted server.
         */
        address: string;
    }

    export interface SwitchDscpToCosMappingsMapping {
        /**
         * The actual layer-2 CoS queue the DSCP value is mapped to. These are not bits set on outgoing frames. Value can be in the range of 0 to 5 inclusive.
         */
        cos: number;
        /**
         * The Differentiated Services Code Point (DSCP) tag in the IP header that will be mapped to a particular Class-of-Service (CoS) queue. Value can be in the range of 0 to 63 inclusive.
         */
        dscp: number;
        /**
         * Label for the mapping (optional).
         */
        title: string;
    }

    export interface SwitchLinkAggregationsSwitchPort {
        /**
         * Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
         */
        portId: string;
        /**
         * Serial number of the switch.
         */
        serial: string;
    }

    export interface SwitchLinkAggregationsSwitchProfilePort {
        /**
         * Port identifier of switch port. For modules, the identifier is "SlotNumber*ModuleType*PortNumber" (Ex: "1*8X10G*1"), otherwise it is just the port number (Ex: "8").
         */
        portId: string;
        /**
         * Profile identifier.
         */
        profile: string;
    }

    export interface SwitchMtuOverride {
        /**
         * MTU size for the switches or switch templates.
         */
        mtuSize: number;
        /**
         * List of switch template IDs. Applicable only for template network.
         */
        switchProfiles: string[];
        /**
         * List of switch serials. Applicable only for switch network.
         */
        switches: string[];
    }

    export interface SwitchPortSchedulesPortSchedule {
        /**
         * The schedule object for Friday.
         */
        friday: outputs.networks.SwitchPortSchedulesPortScheduleFriday;
        /**
         * The schedule object for Monday.
         */
        monday: outputs.networks.SwitchPortSchedulesPortScheduleMonday;
        /**
         * The schedule object for Saturday.
         */
        saturday: outputs.networks.SwitchPortSchedulesPortScheduleSaturday;
        /**
         * The schedule object for Sunday.
         */
        sunday: outputs.networks.SwitchPortSchedulesPortScheduleSunday;
        /**
         * The schedule object for Thursday.
         */
        thursday: outputs.networks.SwitchPortSchedulesPortScheduleThursday;
        /**
         * The schedule object for Tuesday.
         */
        tuesday: outputs.networks.SwitchPortSchedulesPortScheduleTuesday;
        /**
         * The schedule object for Wednesday.
         */
        wednesday: outputs.networks.SwitchPortSchedulesPortScheduleWednesday;
    }

    export interface SwitchPortSchedulesPortScheduleFriday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface SwitchPortSchedulesPortScheduleMonday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface SwitchPortSchedulesPortScheduleSaturday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface SwitchPortSchedulesPortScheduleSunday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface SwitchPortSchedulesPortScheduleThursday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface SwitchPortSchedulesPortScheduleTuesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface SwitchPortSchedulesPortScheduleWednesday {
        /**
         * Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.
         */
        active: boolean;
        /**
         * The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.
         */
        from: string;
        /**
         * The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.
         */
        to: string;
    }

    export interface SwitchRoutingMulticastDefaultSettings {
        /**
         * Flood unknown multicast traffic enabled for the entire network
         */
        floodUnknownMulticastTrafficEnabled: boolean;
        /**
         * IGMP snooping enabled for the entire network
         */
        igmpSnoopingEnabled: boolean;
    }

    export interface SwitchRoutingMulticastOverride {
        /**
         * Flood unknown multicast traffic enabled for switches, switch stacks or switch templates
         */
        floodUnknownMulticastTrafficEnabled: boolean;
        /**
         * IGMP snooping enabled for switches, switch stacks or switch templates
         */
        igmpSnoopingEnabled: boolean;
        /**
         * (optional) List of switch stack ids for non-template network
         */
        stacks: string[];
        /**
         * (optional) List of switch templates ids for template network
         */
        switchProfiles: string[];
        /**
         * (optional) List of switch serials for non-template network
         */
        switches: string[];
    }

    export interface SwitchRoutingOspfArea {
        /**
         * OSPF area ID
         */
        areaId: number;
        /**
         * Name of the OSPF area
         */
        areaName: string;
        /**
         * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
         */
        areaType: string;
    }

    export interface SwitchRoutingOspfMd5AuthenticationKey {
        /**
         * MD5 authentication key index. Key index must be between 1 to 255
         */
        id: number;
        /**
         * MD5 authentication passphrase
         */
        passphrase: string;
    }

    export interface SwitchRoutingOspfV3 {
        /**
         * OSPF v3 areas
         */
        areas: outputs.networks.SwitchRoutingOspfV3Area[];
        /**
         * Time interval to determine when the peer will be declared inactive/dead. Value must be between 1 and 65535
         */
        deadTimerInSeconds: number;
        /**
         * Boolean value to enable or disable V3 OSPF routing. OSPF V3 routing is disabled by default.
         */
        enabled: boolean;
        /**
         * Time interval in seconds at which hello packet will be sent to OSPF neighbors to maintain connectivity. Value must be between 1 and 255. Default is 10 seconds.
         */
        helloTimerInSeconds: number;
    }

    export interface SwitchRoutingOspfV3Area {
        /**
         * OSPF area ID
         */
        areaId: number;
        /**
         * Name of the OSPF area
         */
        areaName: string;
        /**
         * Area types in OSPF. Must be one of: ["normal", "stub", "nssa"]
         */
        areaType: string;
    }

    export interface SwitchSettingsMacBlocklist {
        /**
         * Enable MAC blocklist for switches in the network
         */
        enabled: boolean;
    }

    export interface SwitchSettingsPowerException {
        /**
         * Per switch exception (combined, redundant, useNetworkSetting)
         */
        powerType: string;
        /**
         * Serial number of the switch
         */
        serial: string;
    }

    export interface SwitchSettingsUplinkClientSampling {
        /**
         * Enable client sampling on uplink
         */
        enabled: boolean;
    }

    export interface SwitchStacksAddItem {
        /**
         * ID of the Switch stack
         */
        id: string;
        /**
         * Name of the Switch stack
         */
        name: string;
        /**
         * Serials of the switches in the switch stack
         */
        serials: string[];
    }

    export interface SwitchStacksAddParameters {
        /**
         * The serial of the switch to be added
         */
        serial: string;
    }

    export interface SwitchStacksRemoveItem {
        /**
         * ID of the Switch stack
         */
        id: string;
        /**
         * Name of the Switch stack
         */
        name: string;
        /**
         * Serials of the switches in the switch stack
         */
        serials: string[];
    }

    export interface SwitchStacksRemoveParameters {
        /**
         * The serial of the switch to be removed
         */
        serial: string;
    }

    export interface SwitchStacksRoutingInterfacesDhcpDhcpOption {
        /**
         * The code for DHCP option which should be from 2 to 254
         */
        code: string;
        /**
         * The type of the DHCP option which should be one of ('text', 'ip', 'integer' or 'hex')
         */
        type: string;
        /**
         * The value of the DHCP option
         */
        value: string;
    }

    export interface SwitchStacksRoutingInterfacesDhcpFixedIpAssignment {
        /**
         * The IP address of the client which has fixed IP address assigned to it
         */
        ip: string;
        /**
         * The MAC address of the client which has fixed IP address
         */
        mac: string;
        /**
         * The name of the client which has fixed IP address
         */
        name: string;
    }

    export interface SwitchStacksRoutingInterfacesDhcpReservedIpRange {
        /**
         * The comment for the reserved IP range
         */
        comment: string;
        /**
         * The ending IP address of the reserved IP range
         */
        end: string;
        /**
         * The starting IP address of the reserved IP range
         */
        start: string;
    }

    export interface SwitchStacksRoutingInterfacesIpv6 {
        /**
         * IPv6 address
         */
        address: string;
        /**
         * Assignment mode
         */
        assignmentMode: string;
        /**
         * IPv6 gateway
         */
        gateway: string;
        /**
         * IPv6 subnet
         */
        prefix: string;
    }

    export interface SwitchStacksRoutingInterfacesOspfSettings {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv4 area
         */
        isPassiveEnabled: boolean;
    }

    export interface SwitchStacksRoutingInterfacesOspfV3 {
        /**
         * Area id
         */
        area: string;
        /**
         * OSPF Cost
         */
        cost: number;
        /**
         * Disable sending Hello packets on this interface's IPv6 area
         */
        isPassiveEnabled: boolean;
    }

    export interface SwitchStpStpBridgePriority {
        /**
         * List of stack IDs
         */
        stacks: string[];
        /**
         * STP priority for switch, stacks, or switch profiles
         */
        stpPriority: number;
        /**
         * List of switch profile IDs
         */
        switchProfiles: string[];
        /**
         * List of switch serial numbers
         */
        switches: string[];
    }

    export interface SwitchStpStpBridgePriorityResponse {
        /**
         * List of stack IDs
         */
        stacks: string[];
        /**
         * STP priority for switch, stacks, or switch templates
         */
        stpPriority: number;
        /**
         * List of switch template IDs
         */
        switchProfiles: string[];
        /**
         * List of switch serial numbers
         */
        switches: string[];
    }

    export interface SyslogServersServer {
        /**
         * The IP address of the syslog server
         */
        host: string;
        /**
         * The port of the syslog server
         */
        port: number;
        /**
         * A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'
         */
        roles: string[];
    }

    export interface TrafficAnalysisCustomPieChartItem {
        /**
         * The name of the custom pie chart item.
         */
        name: string;
        /**
         * The signature type for the custom pie chart item. Can be one of 'host', 'port' or 'ipRange'.
         */
        type: string;
        /**
         * The value of the custom pie chart item. Valid syntax depends on the signature type of the chart item
         * (see sample request/response for more details).
         */
        value: string;
    }

    export interface UnbindItem {
        /**
         * Enrollment string for the network
         */
        enrollmentString: string;
        /**
         * Network ID
         */
        id: string;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate: boolean;
        /**
         * Network name
         */
        name: string;
        /**
         * Notes for the network
         */
        notes: string;
        /**
         * Organization ID
         */
        organizationId: string;
        /**
         * List of the product types that the network supports
         */
        productTypes: string[];
        /**
         * Network tags
         */
        tags: string[];
        /**
         * Timezone of the network
         */
        timeZone: string;
        /**
         * URL to the network Dashboard UI
         */
        url: string;
    }

    export interface UnbindParameters {
        /**
         * Optional boolean to retain all the current configs given by the template.
         */
        retainConfigs: boolean;
    }

    export interface VlanProfilesAssignmentsReassignItem {
        /**
         * Array of Device Serials
         */
        serials: string[];
        /**
         * Array of Switch Stack IDs
         */
        stackIds: string[];
        /**
         * The VLAN Profile
         */
        vlanProfile: outputs.networks.VlanProfilesAssignmentsReassignItemVlanProfile;
    }

    export interface VlanProfilesAssignmentsReassignItemVlanProfile {
        /**
         * IName of the VLAN Profile
         */
        iname: string;
        /**
         * Name of the VLAN Profile
         */
        name: string;
    }

    export interface VlanProfilesAssignmentsReassignParameters {
        /**
         * Array of Device Serials
         */
        serials: string[];
        /**
         * Array of Switch Stack IDs
         */
        stackIds: string[];
        /**
         * The VLAN Profile
         */
        vlanProfile: outputs.networks.VlanProfilesAssignmentsReassignParametersVlanProfile;
    }

    export interface VlanProfilesAssignmentsReassignParametersVlanProfile {
        /**
         * IName of the VLAN Profile
         */
        iname: string;
    }

    export interface VlanProfilesVlanGroup {
        /**
         * Name of the VLAN, string length must be from 1 to 32 characters
         */
        name: string;
        /**
         * Comma-separated VLAN IDs or ID ranges
         */
        vlanIds: string;
    }

    export interface VlanProfilesVlanName {
        /**
         * Adaptive Policy Group assigned to Vlan ID
         */
        adaptivePolicyGroup: outputs.networks.VlanProfilesVlanNameAdaptivePolicyGroup;
        /**
         * Name of the VLAN, string length must be from 1 to 32 characters
         */
        name?: string;
        /**
         * VLAN ID
         */
        vlanId: string;
    }

    export interface VlanProfilesVlanNameAdaptivePolicyGroup {
        /**
         * Adaptive Policy Group ID
         */
        id: string;
        /**
         * Adaptive Policy Group name
         */
        name: string;
    }

    export interface WebhooksHttpServersPayloadTemplate {
        /**
         * The name of the payload template.
         */
        name: string;
        /**
         * The ID of the payload template.
         */
        payloadTemplateId: string;
    }

    export interface WebhooksPayloadTemplatesHeader {
        /**
         * The name of the header attribute
         */
        name: string;
        /**
         * The value returned in the header attribute, in liquid template
         */
        template: string;
    }

    export interface WebhooksPayloadTemplatesSharing {
        /**
         * Information on network access to the template
         */
        byNetwork: outputs.networks.WebhooksPayloadTemplatesSharingByNetwork;
    }

    export interface WebhooksPayloadTemplatesSharingByNetwork {
        /**
         * Indicates whether network admins may modify this template
         */
        adminsCanModify: boolean;
    }

    export interface WirelessAlternateManagementInterfaceAccessPoint {
        /**
         * Wireless alternate management interface device IP. Provide an empty string to remove alternate management IP assignment
         */
        alternateManagementIp: string;
        /**
         * Primary DNS must be in IP format
         */
        dns1: string;
        /**
         * Optional secondary DNS must be in IP format
         */
        dns2: string;
        /**
         * Gateway must be in IP format
         */
        gateway: string;
        /**
         * Serial number of access point to be configured with alternate management IP
         */
        serial: string;
        /**
         * Subnet mask must be in IP format
         */
        subnetMask: string;
    }

    export interface WirelessBillingPlan {
        /**
         * The uplink bandwidth settings for the pricing plan.
         */
        bandwidthLimits: outputs.networks.WirelessBillingPlanBandwidthLimits;
        /**
         * The id of the pricing plan to update.
         */
        id: string;
        /**
         * The price of the billing plan.
         */
        price: number;
        /**
         * The time limit of the pricing plan in minutes.
         */
        timeLimit: string;
    }

    export interface WirelessBillingPlanBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp: number;
    }

    export interface WirelessEthernetPortsProfilesAssignItem {
        /**
         * AP profile ID
         */
        profileId: string;
        /**
         * List of updated AP serials
         */
        serials: string[];
    }

    export interface WirelessEthernetPortsProfilesAssignParameters {
        /**
         * AP profile ID
         */
        profileId: string;
        /**
         * List of AP serials
         */
        serials: string[];
    }

    export interface WirelessEthernetPortsProfilesPort {
        /**
         * Enabled
         */
        enabled: boolean;
        /**
         * Name
         */
        name: string;
        /**
         * Number
         */
        number: number;
        /**
         * PSK Group number
         */
        pskGroupId: string;
        /**
         * Ssid number
         */
        ssid: number;
    }

    export interface WirelessEthernetPortsProfilesSetDefaultItem {
        /**
         * AP profile ID
         */
        profileId: string;
    }

    export interface WirelessEthernetPortsProfilesSetDefaultParameters {
        /**
         * AP profile ID
         */
        profileId: string;
    }

    export interface WirelessEthernetPortsProfilesUsbPort {
        /**
         * Enabled
         */
        enabled: boolean;
        /**
         * Name
         */
        name: string;
        /**
         * Ssid number
         */
        ssid: number;
    }

    export interface WirelessRfProfilesApBandSettings {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'. Defaults to dual.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band. Can be either true or false. Defaults to true.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesApBandSettingsBands;
    }

    export interface WirelessRfProfilesApBandSettingsBands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesFiveGhzSettings {
        /**
         * Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.
         */
        channelWidth: string;
        /**
         * Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower: number;
        /**
         * Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
         */
        minBitrate: number;
        /**
         * Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.
         */
        minPower: number;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop: number;
        /**
         * Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].
         */
        validAutoChannels: number[];
    }

    export interface WirelessRfProfilesFlexRadios {
        /**
         * Flex radios by model.
         */
        byModels?: outputs.networks.WirelessRfProfilesFlexRadiosByModel[];
    }

    export interface WirelessRfProfilesFlexRadiosByModel {
        /**
         * Band to use for each flex radio. For example, ['6'] will set the AP's first flex radio to 6 GHz
         */
        bands?: string[];
        /**
         * Model of the AP
         */
        model?: string;
    }

    export interface WirelessRfProfilesPerSsidSettings {
        /**
         * Settings for SSID 0
         */
        status0: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus0;
        /**
         * Settings for SSID 1
         */
        status1: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus1;
        /**
         * Settings for SSID 10
         */
        status10: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus10;
        /**
         * Settings for SSID 11
         */
        status11: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus11;
        /**
         * Settings for SSID 12
         */
        status12: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus12;
        /**
         * Settings for SSID 13
         */
        status13: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus13;
        /**
         * Settings for SSID 14
         */
        status14: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus14;
        /**
         * Settings for SSID 2
         */
        status2: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus2;
        /**
         * Settings for SSID 3
         */
        status3: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus3;
        /**
         * Settings for SSID 4
         */
        status4: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus4;
        /**
         * Settings for SSID 5
         */
        status5: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus5;
        /**
         * Settings for SSID 6
         */
        status6: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus6;
        /**
         * Settings for SSID 7
         */
        status7: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus7;
        /**
         * Settings for SSID 8
         */
        status8: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus8;
        /**
         * Settings for SSID 9
         */
        status9: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus9;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus0 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus0Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus0Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus1 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus1Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus10 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus10Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus10Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus11 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus11Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus11Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus12 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus12Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus12Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus13 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus13Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus13Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus14 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus14Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus14Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus1Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus2 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus2Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus2Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus3 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus3Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus3Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus4 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus4Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus4Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus5 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus5Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus5Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus6 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus6Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus6Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus7 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus7Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus7Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus8 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus8Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus8Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus9 {
        /**
         * Choice between 'dual', '2.4ghz', '5ghz', '6ghz' or 'multi'.
         */
        bandOperationMode: string;
        /**
         * Steers client to most open band between 2.4 GHz and 5 GHz. Can be either true or false.
         */
        bandSteeringEnabled: boolean;
        /**
         * Settings related to all bands
         */
        bands: outputs.networks.WirelessRfProfilesPerSsidSettingsStatus9Bands;
        /**
         * Sets min bitrate (Mbps) of this SSID. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.
         */
        minBitrate: number;
        /**
         * Name of SSID
         */
        name: string;
    }

    export interface WirelessRfProfilesPerSsidSettingsStatus9Bands {
        /**
         * List of enabled bands. Can include ["2.4", "5", "6", "disabled"
         */
        enableds: string[];
    }

    export interface WirelessRfProfilesSixGhzSettings {
        /**
         * Sets channel width (MHz) for 6Ghz band. Can be one of '0', '20', '40', '80' or '160'. Defaults to auto.
         */
        channelWidth: string;
        /**
         * Sets max power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower: number;
        /**
         * Sets min bitrate (Mbps) of 6Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.
         */
        minBitrate: number;
        /**
         * Sets min power (dBm) of 6Ghz band. Can be integer between 2 and 30. Defaults to 8.
         */
        minPower: number;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop: number;
        /**
         * Sets valid auto channels for 6Ghz band. Can be one of '1', '5', '9', '13', '17', '21', '25', '29', '33', '37', '41', '45', '49', '53', '57', '61', '65', '69', '73', '77', '81', '85', '89', '93', '97', '101', '105', '109', '113', '117', '121', '125', '129', '133', '137', '141', '145', '149', '153', '157', '161', '165', '169', '173', '177', '181', '185', '189', '193', '197', '201', '205', '209', '213', '217', '221', '225', '229' or '233'. Defaults to auto.
         */
        validAutoChannels: number[];
    }

    export interface WirelessRfProfilesTransmission {
        /**
         * Toggle for radio transmission. When false, radios will not transmit at all.
         */
        enabled: boolean;
    }

    export interface WirelessRfProfilesTwoFourGhzSettings {
        /**
         * Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.
         */
        axEnabled: boolean;
        /**
         * Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.
         */
        maxPower: number;
        /**
         * Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.
         */
        minBitrate: number;
        /**
         * Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.
         */
        minPower: number;
        /**
         * The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.
         */
        rxsop: number;
        /**
         * Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].
         */
        validAutoChannels: number[];
    }

    export interface WirelessSettingsNamedVlans {
        /**
         * Named VLAN Pool DHCP Monitoring settings.
         */
        poolDhcpMonitoring: outputs.networks.WirelessSettingsNamedVlansPoolDhcpMonitoring;
    }

    export interface WirelessSettingsNamedVlansPoolDhcpMonitoring {
        /**
         * The duration in minutes that devices will refrain from using dirty VLANs before adding them back to the pool.
         */
        duration: number;
        /**
         * Whether or not devices using named VLAN pools should remove dirty VLANs from the pool, thereby preventing clients from being assigned to VLANs where they would be unable to obtain an IP address via DHCP
         */
        enabled: boolean;
    }

    export interface WirelessSettingsRegulatoryDomain {
        /**
         * The country code of the regulatory domain.
         */
        countryCode: string;
        /**
         * The name of the regulatory domain for this network.
         */
        name: string;
        /**
         * Whether or not the regulatory domain for this network permits Wifi 6E.
         */
        permits6e: boolean;
    }

    export interface WirelessSsidsActiveDirectory {
        /**
         * (Optional) The credentials of the user account to be used by the AP to bind to your Active Directory server. The Active Directory account should have permissions on all your Active Directory servers. Only valid if the splashPage is 'Password-protected with Active Directory'.
         */
        credentials: outputs.networks.WirelessSsidsActiveDirectoryCredentials;
        /**
         * The Active Directory servers to be used for authentication.
         */
        servers: outputs.networks.WirelessSsidsActiveDirectoryServer[];
    }

    export interface WirelessSsidsActiveDirectoryCredentials {
        /**
         * The logon name of the Active Directory account.
         */
        logonName: string;
        /**
         * The password to the Active Directory user account.
         */
        password: string;
    }

    export interface WirelessSsidsActiveDirectoryServer {
        /**
         * IP address (or FQDN) of your Active Directory server.
         */
        host: string;
        /**
         * (Optional) UDP port the Active Directory server listens on. By default, uses port 3268.
         */
        port: number;
    }

    export interface WirelessSsidsApTagsAndVlanId {
        /**
         * Array of AP tags
         */
        tags: string[];
        /**
         * Numerical identifier that is assigned to the VLAN
         */
        vlanId: number;
    }

    export interface WirelessSsidsBonjourForwardingException {
        /**
         * If true, Bonjour forwarding exception is enabled on this SSID. Exception is required to enable L2 isolation and Bonjour forwarding to work together.
         */
        enabled: boolean;
    }

    export interface WirelessSsidsBonjourForwardingRule {
        /**
         * Desctiption of the bonjour forwarding rule
         */
        description: string;
        /**
         * A list of Bonjour services. At least one service must be specified. Available services are 'All Services', 'AirPlay', 'AFP', 'BitTorrent', 'FTP', 'iChat', 'iTunes', 'Printers', 'Samba', 'Scanners' and 'SSH'
         */
        services: string[];
        /**
         * The ID of the service VLAN. Required
         */
        vlanId: string;
    }

    export interface WirelessSsidsDeviceTypeGroupPoliciesDeviceTypePolicy {
        /**
         * The device policy. Can be one of 'Allowed', 'Blocked' or 'Group policy'
         */
        devicePolicy: string;
        /**
         * The device type. Can be one of 'Android', 'BlackBerry', 'Chrome OS', 'iPad', 'iPhone', 'iPod', 'Mac OS X', 'Windows', 'Windows Phone', 'B&N Nook' or 'Other OS'
         */
        deviceType: string;
        /**
         * ID of the group policy object.
         */
        groupPolicyId: number;
    }

    export interface WirelessSsidsDnsRewrite {
        /**
         * User specified DNS servers (up to two servers)
         */
        dnsCustomNameservers: string[];
        /**
         * Boolean indicating whether or not DNS server rewrite is enabled. If disabled, upstream DNS will be used
         */
        enabled: boolean;
    }

    export interface WirelessSsidsDot11r {
        /**
         * (Optional) Whether 802.11r is adaptive or not.
         */
        adaptive?: boolean;
        /**
         * Whether 802.11r is enabled or not.
         */
        enabled?: boolean;
    }

    export interface WirelessSsidsDot11w {
        /**
         * Whether 802.11w is enabled or not.
         */
        enabled?: boolean;
        /**
         * (Optional) Whether 802.11w is required or not.
         */
        required?: boolean;
    }

    export interface WirelessSsidsEapOverrideEapolKey {
        /**
         * Maximum number of EAPOL key retries.
         */
        retries: number;
        /**
         * EAPOL Key timeout in milliseconds.
         */
        timeoutInMs: number;
    }

    export interface WirelessSsidsEapOverrideIdentity {
        /**
         * Maximum number of EAP retries.
         */
        retries: number;
        /**
         * EAP timeout in seconds.
         */
        timeout: number;
    }

    export interface WirelessSsidsFirewallL3FirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * Ip Ver
         */
        ipVer: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
    }

    export interface WirelessSsidsFirewallL3FirewallRulesRulesResponse {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * Ip Version
         */
        ipVer: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
    }

    export interface WirelessSsidsFirewallL7FirewallRulesRule {
        /**
         * 'Deny' traffic specified by this rule
         */
        policy: string;
        /**
         * Type of the L7 firewall rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'
         */
        type: string;
        /**
         * The value of what needs to get blocked. Format of the value varies depending on type of the firewall rule selected.
         */
        value: string;
        /**
         * The 'value_list' of what you want to block. Send a list in request
         */
        valueLists?: string[];
        /**
         * The 'value_obj' of what you want to block. Send a dict in request
         */
        valueObj?: outputs.networks.WirelessSsidsFirewallL7FirewallRulesRuleValueObj;
    }

    export interface WirelessSsidsFirewallL7FirewallRulesRuleValueObj {
        id?: string;
        name?: string;
    }

    export interface WirelessSsidsGre {
        /**
         * The EoGRE concentrator's settings
         */
        concentrator: outputs.networks.WirelessSsidsGreConcentrator;
        /**
         * Optional numerical identifier that will add the GRE key field to the GRE header. Used to identify an individual traffic flow within a tunnel.
         */
        key: number;
    }

    export interface WirelessSsidsGreConcentrator {
        /**
         * The EoGRE concentrator's IP or FQDN. This param is required when ipAssignmentMode is 'Ethernet over GRE'.
         */
        host: string;
    }

    export interface WirelessSsidsHotspot20MccMnc {
        /**
         * MCC value
         */
        mcc: string;
        /**
         * MNC value
         */
        mnc: string;
    }

    export interface WirelessSsidsHotspot20NaiRealm {
        /**
         * The format for the realm ('1' or '0')
         */
        format: string;
        /**
         * An array of EAP methods for the realm.
         */
        methods: outputs.networks.WirelessSsidsHotspot20NaiRealmMethod[];
        name: string;
        /**
         * The name of the realm
         */
        realm: string;
    }

    export interface WirelessSsidsHotspot20NaiRealmMethod {
        /**
         * The authentication types for the method. These should be formatted as an object with the EAP method category in camelcase as the key and the list of types as the value (nonEapInnerAuthentication: Reserved, PAP, CHAP, MSCHAP, MSCHAPV2; eapInnerAuthentication: EAP-TLS, EAP-SIM, EAP-AKA, EAP-TTLS with MSCHAPv2; credentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, none, Reserved, Vendor Specific; tunneledEapMethodCredentials: SIM, USIM, NFC Secure Element, Hardware Token, Softoken, Certificate, username/password, Reserved, Anonymous, Vendor Specific)
         */
        authenticationTypes: outputs.networks.WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes;
        /**
         * ID of method
         */
        id: string;
    }

    export interface WirelessSsidsHotspot20NaiRealmMethodAuthenticationTypes {
        credentials: string[];
        eapinnerAuthentications: string[];
        nonEapinnerAuthentications: string[];
        tunneledEapMethodCredentials: string[];
    }

    export interface WirelessSsidsHotspot20Operator {
        /**
         * Operator name
         */
        name: string;
    }

    export interface WirelessSsidsHotspot20Venue {
        /**
         * Venue name
         */
        name: string;
        /**
         * Venue type ('Unspecified', 'Unspecified Assembly', 'Arena', 'Stadium', 'Passenger Terminal', 'Amphitheater', 'Amusement Park', 'Place of Worship', 'Convention Center', 'Library', 'Museum', 'Restaurant', 'Theater', 'Bar', 'Coffee Shop', 'Zoo or Aquarium', 'Emergency Coordination Center', 'Unspecified Business', 'Doctor or Dentist office', 'Bank', 'Fire Station', 'Police Station', 'Post Office', 'Professional Office', 'Research and Development Facility', 'Attorney Office', 'Unspecified Educational', 'School, Primary', 'School, Secondary', 'University or College', 'Unspecified Factory and Industrial', 'Factory', 'Unspecified Institutional', 'Hospital', 'Long-Term Care Facility', 'Alcohol and Drug Rehabilitation Center', 'Group Home', 'Prison or Jail', 'Unspecified Mercantile', 'Retail Store', 'Grocery Market', 'Automotive Service Station', 'Shopping Mall', 'Gas Station', 'Unspecified Residential', 'Private Residence', 'Hotel or Motel', 'Dormitory', 'Boarding House', 'Unspecified Storage', 'Unspecified Utility and Miscellaneous', 'Unspecified Vehicular', 'Automobile or Truck', 'Airplane', 'Bus', 'Ferry', 'Ship or Boat', 'Train', 'Motor Bike', 'Unspecified Outdoor', 'Muni-mesh Network', 'City Park', 'Rest Area', 'Traffic Control', 'Bus Stop', 'Kiosk')
         */
        type: string;
    }

    export interface WirelessSsidsLdap {
        /**
         * The base distinguished name of users on the LDAP server.
         */
        baseDistinguishedName: string;
        /**
         * (Optional) The credentials of the user account to be used by the AP to bind to your LDAP server. The LDAP account should have permissions on all your LDAP servers.
         */
        credentials: outputs.networks.WirelessSsidsLdapCredentials;
        /**
         * The CA certificate used to sign the LDAP server's key.
         */
        serverCaCertificate: outputs.networks.WirelessSsidsLdapServerCaCertificate;
        /**
         * The LDAP servers to be used for authentication.
         */
        servers: outputs.networks.WirelessSsidsLdapServer[];
    }

    export interface WirelessSsidsLdapCredentials {
        /**
         * The distinguished name of the LDAP user account (example: cn=user,dc=meraki,dc=com).
         */
        distinguishedName: string;
        /**
         * The password of the LDAP user account.
         */
        password: string;
    }

    export interface WirelessSsidsLdapServer {
        /**
         * IP address (or FQDN) of your LDAP server.
         */
        host: string;
        /**
         * UDP port the LDAP server listens on.
         */
        port: number;
    }

    export interface WirelessSsidsLdapServerCaCertificate {
        /**
         * The contents of the CA certificate. Must be in PEM or DER format.
         */
        contents: string;
    }

    export interface WirelessSsidsLocalRadius {
        /**
         * The duration (in seconds) for which LDAP and OCSP lookups are cached.
         */
        cacheTimeout: number;
        /**
         * The current setting for certificate verification.
         */
        certificateAuthentication: outputs.networks.WirelessSsidsLocalRadiusCertificateAuthentication;
        /**
         * The current setting for password-based authentication.
         */
        passwordAuthentication: outputs.networks.WirelessSsidsLocalRadiusPasswordAuthentication;
    }

    export interface WirelessSsidsLocalRadiusCertificateAuthentication {
        /**
         * The Client CA Certificate used to sign the client certificate.
         */
        clientRootCaCertificate: outputs.networks.WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate;
        /**
         * Whether or not to use EAP-TLS certificate-based authentication to validate wireless clients.
         */
        enabled: boolean;
        /**
         * (Optional) The URL of the OCSP responder to verify client certificate status.
         */
        ocspResponderUrl: string;
        /**
         * Whether or not to verify the certificate with LDAP.
         */
        useLdap: boolean;
        /**
         * Whether or not to verify the certificate with OCSP.
         */
        useOcsp: boolean;
    }

    export interface WirelessSsidsLocalRadiusCertificateAuthenticationClientRootCaCertificate {
        /**
         * The contents of the Client CA Certificate. Must be in PEM or DER format.
         */
        contents: string;
    }

    export interface WirelessSsidsLocalRadiusPasswordAuthentication {
        /**
         * Whether or not to use EAP-TTLS/PAP or PEAP-GTC password-based authentication via LDAP lookup.
         */
        enabled: boolean;
    }

    export interface WirelessSsidsNamedVlans {
        /**
         * RADIUS settings. This param is only valid when authMode is 'open-with-radius' and ipAssignmentMode is not 'NAT mode'.
         */
        radius: outputs.networks.WirelessSsidsNamedVlansRadius;
        /**
         * VLAN tagging settings. This param is only valid when ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'.
         */
        tagging: outputs.networks.WirelessSsidsNamedVlansTagging;
    }

    export interface WirelessSsidsNamedVlansRadius {
        /**
         * Guest VLAN settings. Used to direct traffic to a guest VLAN when none of the RADIUS servers are reachable or a client receives access-reject from the RADIUS server.
         */
        guestVlan: outputs.networks.WirelessSsidsNamedVlansRadiusGuestVlan;
    }

    export interface WirelessSsidsNamedVlansRadiusGuestVlan {
        /**
         * Whether or not RADIUS guest named VLAN is enabled.
         */
        enabled: boolean;
        /**
         * RADIUS guest VLAN name.
         */
        name: string;
    }

    export interface WirelessSsidsNamedVlansTagging {
        /**
         * The list of AP tags and VLAN names used for named VLAN tagging. If an AP has a tag matching one in the list, then traffic on this SSID will be directed to use the VLAN name associated to the tag.
         */
        byApTags: outputs.networks.WirelessSsidsNamedVlansTaggingByApTag[];
        /**
         * The default VLAN name used to tag traffic in the absence of a matching AP tag.
         */
        defaultVlanName: string;
        /**
         * Whether or not traffic should be directed to use specific VLAN names.
         */
        enabled: boolean;
    }

    export interface WirelessSsidsNamedVlansTaggingByApTag {
        /**
         * List of AP tags.
         */
        tags: string[];
        /**
         * VLAN name that will be used to tag traffic.
         */
        vlanName: string;
    }

    export interface WirelessSsidsOauth {
        /**
         * (Optional) The list of domains allowed access to the network.
         */
        allowedDomains: string[];
    }

    export interface WirelessSsidsRadiusAccountingServer {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate?: string;
        /**
         * IP address (or FQDN) to which the APs will send RADIUS accounting messages
         */
        host?: string;
        /**
         * The ID of the Openroaming Certificate attached to radius server
         */
        openRoamingCertificateId?: number;
        /**
         * Port on the RADIUS server that is listening for accounting messages
         */
        port?: number;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
         */
        radsecEnabled?: boolean;
        /**
         * Shared key used to authenticate messages between the APs and RADIUS server
         */
        secret?: string;
    }

    export interface WirelessSsidsRadiusAccountingServersResponse {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate: string;
        /**
         * IP address (or FQDN) to which the APs will send RADIUS accounting messages
         */
        host: string;
        /**
         * The ID of the Openroaming Certificate attached to radius server
         */
        openRoamingCertificateId: number;
        /**
         * Port on the RADIUS server that is listening for accounting messages
         */
        port: number;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS accounting server. Requires radiusProxyEnabled.
         */
        radsecEnabled: boolean;
        /**
         * Shared key used to authenticate messages between the APs and RADIUS server
         */
        secret: string;
    }

    export interface WirelessSsidsRadiusServer {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate?: string;
        /**
         * IP address of your RADIUS server
         */
        host?: string;
        /**
         * The ID of the Openroaming Certificate attached to radius server.
         */
        openRoamingCertificateId?: number;
        /**
         * UDP port the RADIUS server listens on for Access-requests
         */
        port?: number;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
         */
        radsecEnabled?: boolean;
        /**
         * RADIUS client shared secret
         */
        secret?: string;
    }

    export interface WirelessSsidsRadiusServersResponse {
        /**
         * Certificate used for authorization for the RADSEC Server
         */
        caCertificate: string;
        /**
         * IP address of your RADIUS server
         */
        host: string;
        /**
         * The ID of the Openroaming Certificate attached to radius server.
         */
        openRoamingCertificateId: number;
        /**
         * UDP port the RADIUS server listens on for Access-requests
         */
        port: number;
        /**
         * Use RADSEC (TLS over TCP) to connect to this RADIUS server. Requires radiusProxyEnabled.
         */
        radsecEnabled: boolean;
        /**
         * RADIUS client shared secret
         */
        secret: string;
    }

    export interface WirelessSsidsSchedulesRange {
        /**
         * Day of when the outage ends. Can be either full day name, or three letter abbreviation
         */
        endDay: string;
        /**
         * 24 hour time when the outage ends.
         */
        endTime: string;
        /**
         * Day of when the outage starts. Can be either full day name, or three letter abbreviation.
         */
        startDay: string;
        /**
         * 24 hour time when the outage starts.
         */
        startTime: string;
    }

    export interface WirelessSsidsSchedulesRangesInSecond {
        /**
         * Seconds since Sunday at midnight when that outage range ends.
         */
        end: number;
        /**
         * Seconds since Sunday at midnight when the outage range starts.
         */
        start: number;
    }

    export interface WirelessSsidsSpeedBurst {
        /**
         * Boolean indicating whether or not to allow users to temporarily exceed the bandwidth limit for short periods while still keeping them under the bandwidth limit over time.
         */
        enabled: boolean;
    }

    export interface WirelessSsidsSplashSettingsBilling {
        /**
         * Details associated with a free access plan with limits
         */
        freeAccess: outputs.networks.WirelessSsidsSplashSettingsBillingFreeAccess;
        /**
         * Whether or not billing uses the fast login prepaid access option.
         */
        prepaidAccessFastLoginEnabled: boolean;
        /**
         * The email address that reeceives replies from clients
         */
        replyToEmailAddress: string;
    }

    export interface WirelessSsidsSplashSettingsBillingFreeAccess {
        /**
         * How long a device can use a network for free.
         */
        durationInMinutes: number;
        /**
         * Whether or not free access is enabled.
         */
        enabled: boolean;
    }

    export interface WirelessSsidsSplashSettingsGuestSponsorship {
        /**
         * Duration in minutes of sponsored guest authorization.
         */
        durationInMinutes: number;
        /**
         * Whether or not guests can specify how much time they are requesting.
         */
        guestCanRequestTimeframe: boolean;
    }

    export interface WirelessSsidsSplashSettingsSelfRegistration {
        /**
         * How created user accounts should be authorized.
         */
        authorizationType: string;
        /**
         * Whether or not to allow users to create their own account on the network.
         */
        enabled: boolean;
    }

    export interface WirelessSsidsSplashSettingsSentryEnrollment {
        /**
         * The system types that the Sentry enforces.
         */
        enforcedSystems: string[];
        /**
         * The strength of the enforcement of selected system types.
         */
        strength: string;
        /**
         * Systems Manager network targeted for sentry enrollment.
         */
        systemsManagerNetwork: outputs.networks.WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork;
    }

    export interface WirelessSsidsSplashSettingsSentryEnrollmentSystemsManagerNetwork {
        /**
         * The network ID of the Systems Manager network.
         */
        id: string;
    }

    export interface WirelessSsidsSplashSettingsSplashImage {
        /**
         * The extension of the image file.
         */
        extension: string;
        /**
         * Properties for setting a new image.
         */
        image: outputs.networks.WirelessSsidsSplashSettingsSplashImageImage;
        /**
         * The MD5 value of the image file.
         */
        md5: string;
    }

    export interface WirelessSsidsSplashSettingsSplashImageImage {
        /**
         * The file contents (a base 64 encoded string) of your new image.
         */
        contents: string;
        /**
         * The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
         */
        format: string;
    }

    export interface WirelessSsidsSplashSettingsSplashLogo {
        /**
         * The extension of the logo file.
         */
        extension: string;
        /**
         * Properties for setting a new image.
         */
        image: outputs.networks.WirelessSsidsSplashSettingsSplashLogoImage;
        /**
         * The MD5 value of the logo file.
         */
        md5: string;
    }

    export interface WirelessSsidsSplashSettingsSplashLogoImage {
        /**
         * The file contents (a base 64 encoded string) of your new logo.
         */
        contents: string;
        /**
         * The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
         */
        format: string;
    }

    export interface WirelessSsidsSplashSettingsSplashPrepaidFront {
        /**
         * The extension of the prepaid front image file.
         */
        extension: string;
        /**
         * Properties for setting a new image.
         */
        image: outputs.networks.WirelessSsidsSplashSettingsSplashPrepaidFrontImage;
        /**
         * The MD5 value of the prepaid front image file.
         */
        md5: string;
    }

    export interface WirelessSsidsSplashSettingsSplashPrepaidFrontImage {
        /**
         * The file contents (a base 64 encoded string) of your new prepaid front.
         */
        contents: string;
        /**
         * The format of the encoded contents. Supported formats are 'png', 'gif', and jpg'.
         */
        format: string;
    }

    export interface WirelessSsidsTrafficShapingRulesRule {
        /**
         * A list of objects describing the definitions of your traffic shaping rule. At least one definition is required.
         */
        definitions: outputs.networks.WirelessSsidsTrafficShapingRulesRuleDefinition[];
        /**
         * The DSCP tag applied by your rule. null means 'Do not change DSCP tag'.
         * For a list of possible tag values, use the trafficShaping/dscpTaggingOptions endpoint.
         */
        dscpTagValue: number;
        /**
         * The PCP tag applied by your rule. Can be 0 (lowest priority) through 7 (highest priority).
         * null means 'Do not set PCP tag'.
         */
        pcpTagValue: number;
        /**
         * An object describing the bandwidth settings for your rule.
         */
        perClientBandwidthLimits: outputs.networks.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits;
    }

    export interface WirelessSsidsTrafficShapingRulesRuleDefinition {
        /**
         * The type of definition. Can be one of 'application', 'applicationCategory', 'host', 'port', 'ipRange' or 'localNet'.
         */
        type: string;
        /**
         * If "type" is 'host', 'port', 'ipRange' or 'localNet', then "value" must be a string, matching either
         * a hostname (e.g. "somesite.com"), a port (e.g. 8080), or an IP range ("192.1.0.0",
         * "192.1.0.0/16", or "10.1.0.0/16:80"). 'localNet' also supports CIDR notation, excluding
         * custom ports.
         * If "type" is 'application' or 'applicationCategory', then "value" must be an object
         * with the structure { "id": "meraki:layer7/..." }, where "id" is the application category or
         * application ID (for a list of IDs for your network, use the trafficShaping/applicationCategories
         * endpoint).
         */
        value: string;
    }

    export interface WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimits {
        /**
         * The bandwidth limits object, specifying the upload ('limitUp') and download ('limitDown') speed in Kbps. These are only enforced if 'settings' is set to 'custom'.
         */
        bandwidthLimits: outputs.networks.WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits;
        /**
         * How bandwidth limits are applied by your rule. Can be one of 'network default', 'ignore' or 'custom'.
         */
        settings: string;
    }

    export interface WirelessSsidsTrafficShapingRulesRulePerClientBandwidthLimitsBandwidthLimits {
        /**
         * The maximum download limit (integer, in Kbps).
         */
        limitDown: number;
        /**
         * The maximum upload limit (integer, in Kbps).
         */
        limitUp: number;
    }

    export interface WirelessSsidsVpnConcentrator {
        name: string;
        /**
         * The NAT ID of the concentrator that should be set.
         */
        networkId: string;
        /**
         * The VLAN that should be tagged for the concentrator.
         */
        vlanId: number;
    }

    export interface WirelessSsidsVpnFailover {
        /**
         * Idle timer interval in seconds.
         */
        heartbeatInterval: number;
        /**
         * Idle timer timeout in seconds.
         */
        idleTimeout: number;
        /**
         * IP addressed reserved on DHCP server where SSID will terminate.
         */
        requestIp: string;
    }

    export interface WirelessSsidsVpnSplitTunnel {
        /**
         * If true, VPN split tunnel is enabled.
         */
        enabled: boolean;
        /**
         * List of VPN split tunnel rules.
         */
        rules: outputs.networks.WirelessSsidsVpnSplitTunnelRule[];
    }

    export interface WirelessSsidsVpnSplitTunnelRule {
        /**
         * Description for this split tunnel rule (optional).
         */
        comment: string;
        /**
         * Destination for this split tunnel rule. IP address, fully-qualified domain names (FQDN) or 'any'.
         */
        destCidr: string;
        /**
         * Destination port for this split tunnel rule, (integer in the range 1-65535), or 'any'.
         */
        destPort: string;
        /**
         * Traffic policy specified for this split tunnel rule, 'allow' or 'deny'.
         */
        policy: string;
        /**
         * Protocol for this split tunnel rule.
         */
        protocol: string;
    }

}

export namespace organizations {
    export interface ActionBatchesAction {
        /**
         * Data provided in the body of the Action. Contents depend on the Action type
         */
        body: string;
        /**
         * The operation to be used by this action
         */
        operation: string;
        /**
         * Unique identifier for the resource to be acted on
         */
        resource: string;
    }

    export interface ActionBatchesCallback {
        /**
         * The webhook receiver used for the callback webhook.
         */
        httpServer: outputs.organizations.ActionBatchesCallbackHttpServer;
        /**
         * The ID of the callback. To check the status of the callback, use this ID in a request to /webhooks/callbacks/statuses/{id}
         */
        id: string;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.organizations.ActionBatchesCallbackPayloadTemplate;
        /**
         * A shared secret that will be included in the requests sent to the callback URL. It can be used to verify that the request was sent by Meraki. If using this field, please also specify an url.
         */
        sharedSecret: string;
        /**
         * The status of the callback
         */
        status: string;
        /**
         * The callback URL for the webhook target. This was either provided in the original request or comes from a configured webhook receiver
         */
        url: string;
    }

    export interface ActionBatchesCallbackHttpServer {
        /**
         * The webhook receiver ID that will receive information. If specifying this, please leave the url and sharedSecret fields blank.
         */
        id: string;
    }

    export interface ActionBatchesCallbackPayloadTemplate {
        /**
         * The ID of the payload template. Defaults to 'wpt_00005' for the Callback (included) template.
         */
        id: string;
    }

    export interface ActionBatchesStatus {
        /**
         * Flag describing whether all actions in the action batch have completed
         */
        completed: boolean;
        /**
         * Resources created as a result of this action batch
         */
        createdResources: outputs.organizations.ActionBatchesStatusCreatedResource[];
        /**
         * List of errors encountered when running actions in the action batch
         */
        errors: string[];
        /**
         * Flag describing whether any actions in the action batch failed
         */
        failed: boolean;
    }

    export interface ActionBatchesStatusCreatedResource {
        /**
         * ID of the created resource
         */
        id: string;
        /**
         * URI, not including base, of the created resource
         */
        uri: string;
    }

    export interface AdaptivePolicyAclsRule {
        /**
         * Destination port
         */
        dstPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol
         */
        protocol: string;
        /**
         * Source port
         */
        srcPort: string;
    }

    export interface AdaptivePolicyGroupsPolicyObject {
        /**
         * The ID of the policy object
         */
        id: string;
        /**
         * The name of the policy object
         */
        name: string;
    }

    export interface AdaptivePolicyPoliciesAcl {
        /**
         * The ID of the adaptive policy ACL
         */
        id: string;
        /**
         * The name of the adaptive policy ACL
         */
        name: string;
    }

    export interface AdaptivePolicyPoliciesDestinationGroup {
        /**
         * The ID of the destination adaptive policy group
         */
        id: string;
        /**
         * The name of the destination adaptive policy group
         */
        name: string;
        /**
         * The SGT of the destination adaptive policy group
         */
        sgt: number;
    }

    export interface AdaptivePolicyPoliciesSourceGroup {
        /**
         * The ID of the source adaptive policy group
         */
        id: string;
        /**
         * The name of the source adaptive policy group
         */
        name: string;
        /**
         * The SGT of the source adaptive policy group
         */
        sgt: number;
    }

    export interface AdminsNetwork {
        /**
         * Admin's level of access to the network
         */
        access: string;
        /**
         * Network ID
         */
        id: string;
    }

    export interface AdminsTag {
        /**
         * Access level for the tag
         */
        access: string;
        /**
         * Tag value
         */
        tag: string;
    }

    export interface AlertsProfilesAlertCondition {
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
         */
        bitRateBps: number;
        /**
         * The total duration in seconds that the threshold should be crossed before alerting
         */
        duration: number;
        /**
         * The uplink observed for the alert
         */
        interface: string;
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for VoIP Jitter alerts.
         */
        jitterMs: number;
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for WAN Latency alerts.
         */
        latencyMs: number;
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for Packet Loss alerts.
         */
        lossRatio: number;
        /**
         * The threshold the metric must drop below to be valid for alerting. Used only for VoIP MOS alerts.
         */
        mos: number;
        /**
         * The look back period in seconds for sensing the alert
         */
        window: number;
    }

    export interface AlertsProfilesRecipients {
        /**
         * A list of emails that will receive information about the alert
         */
        emails: string[];
        /**
         * A list base64 encoded urls of webhook endpoints that will receive information about the alert
         */
        httpServerIds: string[];
    }

    export interface ApplianceSecurityIntrusionAllowedRule {
        /**
         * Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET
         */
        message: string;
        /**
         * A rule identifier of the format meraki:intrusion/snort/GID/\n\n/SID/\n\n. gid and sid can be obtained from either [https://www.snort.org/rule-docs](https://www.snort.org/rule-docs) or as ruleIds from the security events in /organization/[orgId]/securityEvents
         */
        ruleId: string;
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeer {
        /**
         * [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
         */
        ikeVersion?: string;
        /**
         * Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
         */
        ipsecPolicies?: outputs.organizations.ApplianceVpnThirdPartyVpnpeersPeerIpsecPolicies;
        /**
         * One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
         */
        ipsecPoliciesPreset?: string;
        /**
         * [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
         */
        localId?: string;
        /**
         * The name of the VPN peer
         */
        name?: string;
        /**
         * A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
         */
        networkTags?: string[];
        /**
         * The list of the private subnets of the VPN peer
         */
        privateSubnets?: string[];
        /**
         * [optional] The public IP of the VPN peer
         */
        publicIp?: string;
        /**
         * [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
         */
        remoteId?: string;
        /**
         * The shared secret with the VPN peer
         */
        secret?: string;
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeerIpsecPolicies {
        /**
         * This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        childAuthAlgos: string[];
        /**
         * This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
         */
        childCipherAlgos: string[];
        /**
         * The lifetime of the Phase 2 SA in seconds.
         */
        childLifetime?: number;
        /**
         * This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
         */
        childPfsGroups: string[];
        /**
         * This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        ikeAuthAlgos: string[];
        /**
         * This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
         */
        ikeCipherAlgos: string[];
        /**
         * This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
         */
        ikeDiffieHellmanGroups: string[];
        /**
         * The lifetime of the Phase 1 SA in seconds.
         */
        ikeLifetime?: number;
        /**
         * [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
         */
        ikePrfAlgos: string[];
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeersResponse {
        /**
         * [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
         */
        ikeVersion: string;
        /**
         * Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
         */
        ipsecPolicies: outputs.organizations.ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPolicies;
        /**
         * One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
         */
        ipsecPoliciesPreset: string;
        /**
         * [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
         */
        localId: string;
        /**
         * The name of the VPN peer
         */
        name: string;
        /**
         * A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
         */
        networkTags: string[];
        /**
         * The list of the private subnets of the VPN peer
         */
        privateSubnets: string[];
        /**
         * [optional] The public IP of the VPN peer
         */
        publicIp: string;
        /**
         * [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
         */
        remoteId: string;
        /**
         * The shared secret with the VPN peer
         */
        secret: string;
    }

    export interface ApplianceVpnThirdPartyVpnpeersPeersResponseIpsecPolicies {
        /**
         * This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        childAuthAlgos: string[];
        /**
         * This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
         */
        childCipherAlgos: string[];
        /**
         * The lifetime of the Phase 2 SA in seconds.
         */
        childLifetime: number;
        /**
         * This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
         */
        childPfsGroups: string[];
        /**
         * This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        ikeAuthAlgos: string[];
        /**
         * This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
         */
        ikeCipherAlgos: string[];
        /**
         * This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
         */
        ikeDiffieHellmanGroups: string[];
        /**
         * The lifetime of the Phase 1 SA in seconds.
         */
        ikeLifetime: number;
        /**
         * [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
         */
        ikePrfAlgos: string[];
    }

    export interface ApplianceVpnVpnFirewallRulesRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled: boolean;
    }

    export interface BaseApi {
        /**
         * Enable API access
         */
        enabled: boolean;
    }

    export interface BaseCloud {
        /**
         * Region info
         */
        region: outputs.organizations.BaseCloudRegion;
    }

    export interface BaseCloudRegion {
        /**
         * Name of region
         */
        name: string;
    }

    export interface BaseLicensing {
        /**
         * Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
         */
        model: string;
    }

    export interface BaseManagement {
        /**
         * Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
         */
        details: outputs.organizations.BaseManagementDetail[];
    }

    export interface BaseManagementDetail {
        /**
         * Name of management data
         */
        name: string;
        /**
         * Value of management data
         */
        value: string;
    }

    export interface BrandingPoliciesAdminSettings {
        /**
         * Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
         */
        appliesTo: string;
        /**
         * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
         * entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
         * networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
         * specify an array of tag names.
         */
        values: string[];
    }

    export interface BrandingPoliciesCustomLogo {
        /**
         * Whether or not there is a custom logo enabled.
         */
        enabled: boolean;
        /**
         * Properties of the image.
         */
        image: outputs.organizations.BrandingPoliciesCustomLogoImage;
    }

    export interface BrandingPoliciesCustomLogoImage {
        /**
         * The file contents (a base 64 encoded string) of your new logo.
         */
        contents: string;
        /**
         * The format of the encoded contents.  Supported formats are 'png', 'gif', and jpg'.
         */
        format: string;
        /**
         * Preview of the image
         */
        preview: outputs.organizations.BrandingPoliciesCustomLogoImagePreview;
    }

    export interface BrandingPoliciesCustomLogoImagePreview {
        /**
         * Timestamp of the preview image
         */
        expiresAt: string;
        /**
         * Url of the preview image
         */
        url: string;
    }

    export interface BrandingPoliciesHelpSettings {
        /**
         * The 'Help > API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
         * 'default or inherit', 'hide' or 'show'.
         */
        apiDocsSubtab: string;
        /**
         * The 'Help > Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
         * of 'default or inherit', 'hide' or 'show'.
         */
        casesSubtab: string;
        /**
         * The 'Product Manuals' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        ciscoMerakiProductDocumentation: string;
        /**
         * The 'Help > Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        communitySubtab: string;
        /**
         * The 'Help > Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
         * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        dataProtectionRequestsSubtab: string;
        /**
         * The 'Help > Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
         * listed. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        firewallInfoSubtab: string;
        /**
         * The 'Help > Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
         * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
         * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        getHelpSubtab: string;
        /**
         * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        getHelpSubtabKnowledgeBaseSearch: string;
        /**
         * The 'Help > Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
         * 'default or inherit', 'hide' or 'show'.
         */
        hardwareReplacementsSubtab: string;
        /**
         * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
         * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        helpTab: string;
        /**
         * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
         * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        helpWidget: string;
        /**
         * The 'Help > New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        newFeaturesSubtab: string;
        /**
         * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
         * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        smForums: string;
        /**
         * The 'Contact Meraki Support' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        supportContactInfo: string;
        /**
         * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
         * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        universalSearchKnowledgeBaseSearch: string;
    }

    export interface CameraCustomAnalyticsArtifactsStatus {
        /**
         * Status message
         */
        message: string;
        /**
         * Status type
         */
        type: string;
    }

    export interface CameraRolesAppliedOnDevice {
        /**
         * Device id.
         */
        id: string;
        /**
         * Network id scope
         */
        inNetworksWithId: string;
        /**
         * Network tag scope
         */
        inNetworksWithTag: string;
        permissionLevel: string;
        permissionScope: string;
        /**
         * Permission scope id
         */
        permissionScopeId: string;
        /**
         * Device tag.
         */
        tag: string;
    }

    export interface CameraRolesAppliedOnNetwork {
        /**
         * Network id.
         */
        id: string;
        permissionLevel: string;
        permissionScope: string;
        /**
         * Permission scope id
         */
        permissionScopeId: string;
        /**
         * Network tag
         */
        tag: string;
    }

    export interface CameraRolesAppliedOrgWide {
        permissionLevel: string;
        permissionScope: string;
        /**
         * Permission scope id
         */
        permissionScopeId: string;
        tag: string;
    }

    export interface ClaimItem {
        /**
         * The licenses claimed
         */
        licenses: outputs.organizations.ClaimItemLicense[];
        /**
         * The numbers of the orders claimed
         */
        orders: string[];
        /**
         * The serials of the devices claimed
         */
        serials: string[];
    }

    export interface ClaimItemLicense {
        /**
         * The key of the license
         */
        key: string;
        /**
         * The mode of the license
         */
        mode: string;
    }

    export interface ClaimParameters {
        /**
         * The licenses that should be claimed
         */
        licenses: outputs.organizations.ClaimParametersLicense[];
        /**
         * The numbers of the orders that should be claimed
         */
        orders: string[];
        /**
         * The serials of the devices that should be claimed
         */
        serials: string[];
    }

    export interface ClaimParametersLicense {
        /**
         * The key of the license
         */
        key: string;
        /**
         * Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.
         */
        mode: string;
    }

    export interface CloneItem {
        /**
         * API related settings
         */
        api: outputs.organizations.CloneItemApi;
        /**
         * Data for this organization
         */
        cloud: outputs.organizations.CloneItemCloud;
        /**
         * Organization ID
         */
        id: string;
        /**
         * Licensing related settings
         */
        licensing: outputs.organizations.CloneItemLicensing;
        /**
         * Information about the organization's management system
         */
        management: outputs.organizations.CloneItemManagement;
        /**
         * Organization name
         */
        name: string;
        /**
         * Organization URL
         */
        url: string;
    }

    export interface CloneItemApi {
        /**
         * Enable API access
         */
        enabled: boolean;
    }

    export interface CloneItemCloud {
        /**
         * Region info
         */
        region: outputs.organizations.CloneItemCloudRegion;
    }

    export interface CloneItemCloudRegion {
        /**
         * Name of region
         */
        name: string;
    }

    export interface CloneItemLicensing {
        /**
         * Organization licensing model. Can be 'co-term', 'per-device', or 'subscription'.
         */
        model: string;
    }

    export interface CloneItemManagement {
        /**
         * Details related to organization management, possibly empty. Details may be named 'MSP ID', 'IP restriction mode for API', or 'IP restriction mode for dashboard', if the organization admin has configured any.
         */
        details: outputs.organizations.CloneItemManagementDetail[];
    }

    export interface CloneItemManagementDetail {
        /**
         * Name of management data
         */
        name: string;
        /**
         * Value of management data
         */
        value: string;
    }

    export interface CloneParameters {
        /**
         * The name of the new organization
         */
        name: string;
    }

    export interface ConfigTemplatesSwitchProfilesPortsMirror {
        /**
         * The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
         */
        mode: string;
    }

    export interface ConfigTemplatesSwitchProfilesPortsModule {
        /**
         * The model of the expansion module.
         */
        model: string;
    }

    export interface ConfigTemplatesSwitchProfilesPortsProfile {
        /**
         * When enabled, override this port's configuration with a port profile.
         */
        enabled: boolean;
        /**
         * When enabled, the ID of the port profile used to override the port's configuration.
         */
        id: string;
        /**
         * When enabled, the IName of the profile.
         */
        iname: string;
    }

    export interface GetActionBatchesItem {
        /**
         * A set of changes made as part of this action (\n\nmore details\n\n)
         */
        actions: outputs.organizations.GetActionBatchesItemAction[];
        /**
         * Flag describing whether the action should be previewed before executing or not
         */
        confirmed: boolean;
        /**
         * ID of the action batch. Can be used to check the status of the action batch at /organizations/{organizationId}/actionBatches/{actionBatchId}
         */
        id: string;
        /**
         * ID of the organization this action batch belongs to
         */
        organizationId: string;
        /**
         * Status of action batch
         */
        status: outputs.organizations.GetActionBatchesItemStatus;
        /**
         * Flag describing whether actions should run synchronously or asynchronously
         */
        synchronous: boolean;
    }

    export interface GetActionBatchesItemAction {
        /**
         * Data provided in the body of the Action. Contents depend on the Action type
         */
        body: string;
        /**
         * The operation to be used by this action
         */
        operation: string;
        /**
         * Unique identifier for the resource to be acted on
         */
        resource: string;
    }

    export interface GetActionBatchesItemStatus {
        /**
         * Flag describing whether all actions in the action batch have completed
         */
        completed: boolean;
        /**
         * Resources created as a result of this action batch
         */
        createdResources: outputs.organizations.GetActionBatchesItemStatusCreatedResource[];
        /**
         * List of errors encountered when running actions in the action batch
         */
        errors: string[];
        /**
         * Flag describing whether any actions in the action batch failed
         */
        failed: boolean;
    }

    export interface GetActionBatchesItemStatusCreatedResource {
        /**
         * ID of the created resource
         */
        id: string;
        /**
         * URI, not including base, of the created resource
         */
        uri: string;
    }

    export interface GetAdaptivePolicyAclsItem {
        /**
         * ID of the adaptive policy ACL
         */
        aclId: string;
        /**
         * When the adaptive policy ACL was created
         */
        createdAt: string;
        /**
         * Description of the adaptive policy ACL
         */
        description: string;
        /**
         * IP version of adpative policy ACL
         */
        ipVersion: string;
        /**
         * Name of the adaptive policy ACL
         */
        name: string;
        /**
         * An ordered array of the adaptive policy ACL rules
         */
        rules: outputs.organizations.GetAdaptivePolicyAclsItemRule[];
        /**
         * When the adaptive policy ACL was last updated
         */
        updatedAt: string;
    }

    export interface GetAdaptivePolicyAclsItemRule {
        /**
         * Destination port
         */
        dstPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol
         */
        protocol: string;
        /**
         * Source port
         */
        srcPort: string;
    }

    export interface GetAdaptivePolicyGroupsItem {
        createdAt: string;
        description: string;
        groupId: string;
        isDefaultGroup: boolean;
        name: string;
        policyObjects: outputs.organizations.GetAdaptivePolicyGroupsItemPolicyObject[];
        requiredIpMappings: string[];
        sgt: number;
        updatedAt: string;
    }

    export interface GetAdaptivePolicyGroupsItemPolicyObject {
        id: string;
        name: string;
    }

    export interface GetAdaptivePolicyOverviewItem {
        /**
         * The current amount of various adaptive policy objects.
         */
        counts: outputs.organizations.GetAdaptivePolicyOverviewItemCounts;
        /**
         * The current limits of various adaptive policy objects.
         */
        limits: outputs.organizations.GetAdaptivePolicyOverviewItemLimits;
    }

    export interface GetAdaptivePolicyOverviewItemCounts {
        /**
         * Number of adaptive policies currently in the organization that allow all traffic.
         */
        allowPolicies: number;
        /**
         * Number of user-created adaptive policy ACLs currently in the organization.
         */
        customAcls: number;
        /**
         * Number of user-created adaptive policy groups currently in the organization.
         */
        customGroups: number;
        /**
         * Number of adaptive policies currently in the organization that deny all traffic.
         */
        denyPolicies: number;
        /**
         * Number of adaptive policy groups currently in the organization.
         */
        groups: number;
        /**
         * Number of adaptive policies currently in the organization.
         */
        policies: number;
        /**
         * Number of policy objects (with the adaptive policy type) currently in the organization.
         */
        policyObjects: number;
    }

    export interface GetAdaptivePolicyOverviewItemLimits {
        /**
         * Maximum number of adaptive policy ACLs that can be assigned to an adaptive policy in the organization.
         */
        aclsInAPolicy: number;
        /**
         * Maximum number of user-created adaptive policy groups allowed in the organization.
         */
        customGroups: number;
        /**
         * Maximum number of policy objects (with the adaptive policy type) allowed in the organization.
         */
        policyObjects: number;
        /**
         * Maximum number of rules allowed in an adaptive policy ACL in the organization.
         */
        rulesInAnAcl: number;
    }

    export interface GetAdaptivePolicyPoliciesItem {
        acls: outputs.organizations.GetAdaptivePolicyPoliciesItemAcl[];
        adaptivePolicyId: string;
        createdAt: string;
        destinationGroup: outputs.organizations.GetAdaptivePolicyPoliciesItemDestinationGroup;
        lastEntryRule: string;
        sourceGroup: outputs.organizations.GetAdaptivePolicyPoliciesItemSourceGroup;
        updatedAt: string;
    }

    export interface GetAdaptivePolicyPoliciesItemAcl {
        id: string;
        name: string;
    }

    export interface GetAdaptivePolicyPoliciesItemDestinationGroup {
        id: string;
        name: string;
        sgt: number;
    }

    export interface GetAdaptivePolicyPoliciesItemSourceGroup {
        id: string;
        name: string;
        sgt: number;
    }

    export interface GetAdaptivePolicySettingsItem {
        enabledNetworks: string[];
    }

    export interface GetAdminsItem {
        /**
         * Status of the admin's account
         */
        accountStatus: string;
        /**
         * Admin's authentication method
         */
        authenticationMethod: string;
        /**
         * Admin's email address
         */
        email: string;
        /**
         * Indicates whether the admin has an API key
         */
        hasApiKey: boolean;
        /**
         * Admin's ID
         */
        id: string;
        /**
         * Time when the admin was last active
         */
        lastActive: string;
        /**
         * Admin's username
         */
        name: string;
        /**
         * Admin network access information
         */
        networks: outputs.organizations.GetAdminsItemNetwork[];
        /**
         * Admin's level of access to the organization
         */
        orgAccess: string;
        /**
         * Admin tag information
         */
        tags: outputs.organizations.GetAdminsItemTag[];
        /**
         * Indicates whether two-factor authentication is enabled
         */
        twoFactorAuthEnabled: boolean;
    }

    export interface GetAdminsItemNetwork {
        /**
         * Admin's level of access to the network
         */
        access: string;
        /**
         * Network ID
         */
        id: string;
    }

    export interface GetAdminsItemTag {
        /**
         * Access level for the tag
         */
        access: string;
        /**
         * Tag value
         */
        tag: string;
    }

    export interface GetAlertsProfilesItem {
        /**
         * The conditions that determine if the alert triggers
         */
        alertCondition: outputs.organizations.GetAlertsProfilesItemAlertCondition;
        /**
         * User supplied description of the alert
         */
        description: string;
        /**
         * Is the alert config enabled
         */
        enabled: boolean;
        /**
         * The alert config ID
         */
        id: string;
        /**
         * Networks with these tags will be monitored for the alert
         */
        networkTags: string[];
        /**
         * List of recipients that will recieve the alert.
         */
        recipients: outputs.organizations.GetAlertsProfilesItemRecipients;
        /**
         * The alert type
         */
        type: string;
    }

    export interface GetAlertsProfilesItemAlertCondition {
        /**
         * The threshold the metric must cross to be valid for alerting. Used only for WAN Utilization alerts.
         */
        bitRateBps: number;
        /**
         * The total duration in seconds that the threshold should be crossed before alerting
         */
        duration: number;
        /**
         * The uplink observed for the alert
         */
        interface: string;
        /**
         * The look back period in seconds for sensing the alert
         */
        window: number;
    }

    export interface GetAlertsProfilesItemRecipients {
        /**
         * A list of emails that will receive information about the alert
         */
        emails: string[];
        /**
         * A list base64 encoded urls of webhook endpoints that will receive information about the alert
         */
        httpServerIds: string[];
    }

    export interface GetApiRequestsItem {
        /**
         * Database ID for the admin user who made the API request.
         */
        adminId: string;
        /**
         * The host which the API request was directed at.
         */
        host: string;
        /**
         * HTTP method used in the API request.
         */
        method: string;
        /**
         * Operation ID for the endpoint.
         */
        operationId: string;
        /**
         * The API request path.
         */
        path: string;
        /**
         * The query string sent with the API request.
         */
        queryString: string;
        /**
         * API request response code.
         */
        responseCode: number;
        /**
         * Public IP address from which the API request was made.
         */
        sourceIp: string;
        /**
         * Timestamp, in iso8601 format, indicating when the API request was made.
         */
        ts: string;
        /**
         * The API request user agent.
         */
        userAgent: string;
        /**
         * API version of the endpoint.
         */
        version: number;
    }

    export interface GetApiRequestsOverviewItem {
        /**
         * object of all supported HTTP response code
         */
        responseCodeCounts: outputs.organizations.GetApiRequestsOverviewItemResponseCodeCounts;
    }

    export interface GetApiRequestsOverviewItemResponseCodeCounts {
        /**
         * HTTP 200 response code count.
         */
        status200: number;
        /**
         * HTTP 201 response code count.
         */
        status201: number;
        /**
         * HTTP 202 response code count.
         */
        status202: number;
        /**
         * HTTP 203 response code count.
         */
        status203: number;
        /**
         * HTTP 204 response code count.
         */
        status204: number;
        /**
         * HTTP 205 response code count.
         */
        status205: number;
        /**
         * HTTP 206 response code count.
         */
        status206: number;
        /**
         * HTTP 207 response code count.
         */
        status207: number;
        /**
         * HTTP 208 response code count.
         */
        status208: number;
        /**
         * HTTP 226 response code count.
         */
        status226: number;
        /**
         * HTTP 300 response code count.
         */
        status300: number;
        /**
         * HTTP 301 response code count.
         */
        status301: number;
        /**
         * HTTP 302 response code count.
         */
        status302: number;
        /**
         * HTTP 303 response code count.
         */
        status303: number;
        /**
         * HTTP 304 response code count.
         */
        status304: number;
        /**
         * HTTP 305 response code count.
         */
        status305: number;
        /**
         * HTTP 306 response code count.
         */
        status306: number;
        /**
         * HTTP 307 response code count.
         */
        status307: number;
        /**
         * HTTP 308 response code count.
         */
        status308: number;
        /**
         * HTTP 400 response code count.
         */
        status400: number;
        /**
         * HTTP 401 response code count.
         */
        status401: number;
        /**
         * HTTP 402 response code count.
         */
        status402: number;
        /**
         * HTTP 403 response code count.
         */
        status403: number;
        /**
         * HTTP 404 response code count.
         */
        status404: number;
        /**
         * HTTP 405 response code count.
         */
        status405: number;
        /**
         * HTTP 406 response code count.
         */
        status406: number;
        /**
         * HTTP 407 response code count.
         */
        status407: number;
        /**
         * HTTP 408 response code count.
         */
        status408: number;
        /**
         * HTTP 409 response code count.
         */
        status409: number;
        /**
         * HTTP 410 response code count.
         */
        status410: number;
        /**
         * HTTP 411 response code count.
         */
        status411: number;
        /**
         * HTTP 412 response code count.
         */
        status412: number;
        /**
         * HTTP 413 response code count.
         */
        status413: number;
        /**
         * HTTP 414 response code count.
         */
        status414: number;
        /**
         * HTTP 415 response code count.
         */
        status415: number;
        /**
         * HTTP 416 response code count.
         */
        status416: number;
        /**
         * HTTP 417 response code count.
         */
        status417: number;
        /**
         * HTTP 421 response code count.
         */
        status421: number;
        /**
         * HTTP 422 response code count.
         */
        status422: number;
        /**
         * HTTP 423 response code count.
         */
        status423: number;
        /**
         * HTTP 424 response code count.
         */
        status424: number;
        /**
         * HTTP 425 response code count.
         */
        status425: number;
        /**
         * HTTP 426 response code count.
         */
        status426: number;
        /**
         * HTTP 428 response code count.
         */
        status428: number;
        /**
         * HTTP 429 response code count.
         */
        status429: number;
        /**
         * HTTP 431 response code count.
         */
        status431: number;
        /**
         * HTTP 451 response code count.
         */
        status451: number;
        /**
         * HTTP 500 response code count.
         */
        status500: number;
        /**
         * HTTP 501 response code count.
         */
        status501: number;
        /**
         * HTTP 502 response code count.
         */
        status502: number;
        /**
         * HTTP 503 response code count.
         */
        status503: number;
        /**
         * HTTP 504 response code count.
         */
        status504: number;
        /**
         * HTTP 505 response code count.
         */
        status505: number;
        /**
         * HTTP 506 response code count.
         */
        status506: number;
        /**
         * HTTP 507 response code count.
         */
        status507: number;
        /**
         * HTTP 508 response code count.
         */
        status508: number;
        /**
         * HTTP 509 response code count.
         */
        status509: number;
        /**
         * HTTP 510 response code count.
         */
        status510: number;
        /**
         * HTTP 511 response code count.
         */
        status511: number;
    }

    export interface GetApiRequestsOverviewResponseCodesByIntervalItem {
        /**
         * list of response codes and a count of how many requests had that code in the given time period
         */
        counts: outputs.organizations.GetApiRequestsOverviewResponseCodesByIntervalItemCount[];
        /**
         * The end time of the access period
         */
        endTs: string;
        /**
         * The start time of the access period
         */
        startTs: string;
    }

    export interface GetApiRequestsOverviewResponseCodesByIntervalItemCount {
        /**
         * Response status code of the API response
         */
        code: number;
        /**
         * Number of records that match the status code
         */
        count: number;
    }

    export interface GetApplianceSecurityIntrusionItem {
        allowedRules: outputs.organizations.GetApplianceSecurityIntrusionItemAllowedRule[];
    }

    export interface GetApplianceSecurityIntrusionItemAllowedRule {
        message: string;
        ruleId: string;
    }

    export interface GetApplianceTrafficShapingVpnExclusionsByNetworkItem {
        /**
         * VPN exclusion rules by network
         */
        items: outputs.organizations.GetApplianceTrafficShapingVpnExclusionsByNetworkItemItem[];
    }

    export interface GetApplianceTrafficShapingVpnExclusionsByNetworkItemItem {
        /**
         * Custom VPN exclusion rules.
         */
        customs: outputs.organizations.GetApplianceTrafficShapingVpnExclusionsByNetworkItemItemCustom[];
        /**
         * Major Application based VPN exclusion rules.
         */
        majorApplications: outputs.organizations.GetApplianceTrafficShapingVpnExclusionsByNetworkItemItemMajorApplication[];
        /**
         * ID of the network whose VPN exclusion rules are returned.
         */
        networkId: string;
        /**
         * Name of the network whose VPN exclusion rules are returned.
         */
        networkName: string;
    }

    export interface GetApplianceTrafficShapingVpnExclusionsByNetworkItemItemCustom {
        /**
         * Destination address; hostname required for DNS, IPv4 otherwise.
         */
        destination: string;
        /**
         * Destination port.
         */
        port: string;
        /**
         * Protocol.
         */
        protocol: string;
    }

    export interface GetApplianceTrafficShapingVpnExclusionsByNetworkItemItemMajorApplication {
        /**
         * Application's Meraki ID.
         */
        id: string;
        /**
         * Application's name.
         */
        name: string;
    }

    export interface GetApplianceUplinksStatusesOverviewItem {
        /**
         * counts
         */
        counts: outputs.organizations.GetApplianceUplinksStatusesOverviewItemCounts;
    }

    export interface GetApplianceUplinksStatusesOverviewItemCounts {
        /**
         * byStatus
         */
        byStatus: outputs.organizations.GetApplianceUplinksStatusesOverviewItemCountsByStatus;
    }

    export interface GetApplianceUplinksStatusesOverviewItemCountsByStatus {
        /**
         * number of uplinks that are active and working
         */
        active: number;
        /**
         * number of uplinks currently connecting
         */
        connecting: number;
        /**
         * number of uplinks that were working but have failed
         */
        failed: number;
        /**
         * number of uplinks currently where nothing is plugged in
         */
        notConnected: number;
        /**
         * number of uplinks that are working but on standby
         */
        ready: number;
    }

    export interface GetApplianceUplinksUsageByNetworkItem {
        /**
         * Uplink usage
         */
        byUplinks: outputs.organizations.GetApplianceUplinksUsageByNetworkItemByUplink[];
        /**
         * Network name
         */
        name: string;
        /**
         * Network identifier
         */
        networkId: string;
    }

    export interface GetApplianceUplinksUsageByNetworkItemByUplink {
        /**
         * Uplink name
         */
        interface: string;
        /**
         * Bytes received
         */
        received: number;
        /**
         * Bytes sent
         */
        sent: number;
        /**
         * Uplink serial
         */
        serial: string;
    }

    export interface GetApplianceVpnThirdPartyVpnpeersItem {
        /**
         * The list of VPN peers
         */
        peers: outputs.organizations.GetApplianceVpnThirdPartyVpnpeersItemPeer[];
    }

    export interface GetApplianceVpnThirdPartyVpnpeersItemPeer {
        /**
         * [optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.
         */
        ikeVersion: string;
        /**
         * Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.
         */
        ipsecPolicies: outputs.organizations.GetApplianceVpnThirdPartyVpnpeersItemPeerIpsecPolicies;
        /**
         * One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.
         */
        ipsecPoliciesPreset: string;
        /**
         * [optional] The local ID is used to identify the MX to the peer. This will apply to all MXs this peer applies to.
         */
        localId: string;
        /**
         * The name of the VPN peer
         */
        name: string;
        /**
         * A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].
         */
        networkTags: string[];
        /**
         * The list of the private subnets of the VPN peer
         */
        privateSubnets: string[];
        /**
         * [optional] The public IP of the VPN peer
         */
        publicIp: string;
        /**
         * [optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.
         */
        remoteId: string;
        /**
         * The shared secret with the VPN peer
         */
        secret: string;
    }

    export interface GetApplianceVpnThirdPartyVpnpeersItemPeerIpsecPolicies {
        /**
         * This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        childAuthAlgos: string[];
        /**
         * This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'
         */
        childCipherAlgos: string[];
        /**
         * The lifetime of the Phase 2 SA in seconds.
         */
        childLifetime: number;
        /**
         * This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'
         */
        childPfsGroups: string[];
        /**
         * This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'
         */
        ikeAuthAlgos: string[];
        /**
         * This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'
         */
        ikeCipherAlgos: string[];
        /**
         * This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'
         */
        ikeDiffieHellmanGroups: string[];
        /**
         * The lifetime of the Phase 1 SA in seconds.
         */
        ikeLifetime: number;
        /**
         * [optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.
         */
        ikePrfAlgos: string[];
    }

    export interface GetApplianceVpnVpnFirewallRulesItem {
        /**
         * An ordered array of the firewall rules (not including the default rule)
         */
        rules: outputs.organizations.GetApplianceVpnVpnFirewallRulesItemRule[];
    }

    export interface GetApplianceVpnVpnFirewallRulesItemRule {
        /**
         * Description of the rule (optional)
         */
        comment: string;
        /**
         * Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'
         */
        destCidr: string;
        /**
         * Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'
         */
        destPort: string;
        /**
         * 'allow' or 'deny' traffic specified by this rule
         */
        policy: string;
        /**
         * The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')
         */
        protocol: string;
        /**
         * Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)
         */
        srcCidr: string;
        /**
         * Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'
         */
        srcPort: string;
        /**
         * Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)
         */
        syslogEnabled: boolean;
    }

    export interface GetBrandingPoliciesItem {
        /**
         * Settings for describing which kinds of admins this policy applies to.
         */
        adminSettings: outputs.organizations.GetBrandingPoliciesItemAdminSettings;
        /**
         * Properties describing the custom logo attached to the branding policy.
         */
        customLogo: outputs.organizations.GetBrandingPoliciesItemCustomLogo;
        /**
         * Boolean indicating whether this policy is enabled.
         */
        enabled: boolean;
        /**
         * Settings for describing the modifications to various Help page features. Each property in this object accepts one of
         * 'default or inherit' (do not modify functionality), 'hide' (remove the section from Dashboard), or 'show' (always show
         * the section on Dashboard). Some properties in this object also accept custom HTML used to replace the section on
         * Dashboard; see the documentation for each property to see the allowed values.
         */
        helpSettings: outputs.organizations.GetBrandingPoliciesItemHelpSettings;
        /**
         * Name of the Dashboard branding policy.
         */
        name: string;
    }

    export interface GetBrandingPoliciesItemAdminSettings {
        /**
         * Which kinds of admins this policy applies to. Can be one of 'All organization admins', 'All enterprise admins', 'All network admins', 'All admins of networks...', 'All admins of networks tagged...', 'Specific admins...', 'All admins' or 'All SAML admins'.
         */
        appliesTo: string;
        /**
         * If 'appliesTo' is set to one of 'Specific admins...', 'All admins of networks...' or 'All admins of networks tagged...', then you must specify this 'values' property to provide the set of
         * entities to apply the branding policy to. For 'Specific admins...', specify an array of admin IDs. For 'All admins of
         * networks...', specify an array of network IDs and/or configuration template IDs. For 'All admins of networks tagged...',
         * specify an array of tag names.
         */
        values: string[];
    }

    export interface GetBrandingPoliciesItemCustomLogo {
        /**
         * Whether or not there is a custom logo enabled.
         */
        enabled: boolean;
        /**
         * Properties of the image.
         */
        image: outputs.organizations.GetBrandingPoliciesItemCustomLogoImage;
    }

    export interface GetBrandingPoliciesItemCustomLogoImage {
        /**
         * Preview of the image
         */
        preview: outputs.organizations.GetBrandingPoliciesItemCustomLogoImagePreview;
    }

    export interface GetBrandingPoliciesItemCustomLogoImagePreview {
        /**
         * Timestamp of the preview image
         */
        expiresAt: string;
        /**
         * Url of the preview image
         */
        url: string;
    }

    export interface GetBrandingPoliciesItemHelpSettings {
        /**
         * The 'Help > API docs' subtab where a detailed description of the Dashboard API is listed. Can be one of
         * 'default or inherit', 'hide' or 'show'.
         */
        apiDocsSubtab: string;
        /**
         * The 'Help > Cases' Dashboard subtab on which Cisco Meraki support cases for this organization can be managed. Can be one
         * of 'default or inherit', 'hide' or 'show'.
         */
        casesSubtab: string;
        /**
         * The 'Product Manuals' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        ciscoMerakiProductDocumentation: string;
        /**
         * The 'Help > Community' subtab which provides a link to Meraki Community. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        communitySubtab: string;
        /**
         * The 'Help > Data protection requests' Dashboard subtab on which requests to delete, restrict, or export end-user data can
         * be audited. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        dataProtectionRequestsSubtab: string;
        /**
         * The 'Help > Firewall info' subtab where necessary upstream firewall rules for communication to the Cisco Meraki cloud are
         * listed. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        firewallInfoSubtab: string;
        /**
         * The 'Help > Get Help' subtab on which Cisco Meraki KB, Product Manuals, and Support/Case Information are displayed. Note
         * that if this subtab is hidden, branding customizations for the KB on 'Get help', Cisco Meraki product documentation,
         * and support contact info will not be visible. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        getHelpSubtab: string;
        /**
         * The KB search box which appears on the Help page. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        getHelpSubtabKnowledgeBaseSearch: string;
        /**
         * The 'Help > Replacement info' subtab where important information regarding device replacements is detailed. Can be one of
         * 'default or inherit', 'hide' or 'show'.
         */
        hardwareReplacementsSubtab: string;
        /**
         * The Help tab, under which all support information resides. If this tab is hidden, no other 'Help' branding
         * customizations will be visible. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        helpTab: string;
        /**
         * The 'Help Widget' is a support widget which provides access to live chat, documentation links, Sales contact info,
         * and other contact avenues to reach Meraki Support. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        helpWidget: string;
        /**
         * The 'Help > New features' subtab where new Dashboard features are detailed. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        newFeaturesSubtab: string;
        /**
         * The 'SM Forums' subtab which links to community-based support for Cisco Meraki Systems Manager. Only configurable for
         * organizations that contain Systems Manager networks. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        smForums: string;
        /**
         * The 'Contact Meraki Support' section of the 'Help > Get Help' subtab. Can be one of 'default or inherit', 'hide', 'show', or a replacement custom HTML string.
         */
        supportContactInfo: string;
        /**
         * The universal search box always visible on Dashboard will, by default, present results from the Meraki KB. This configures
         * whether these Meraki KB results should be returned. Can be one of 'default or inherit', 'hide' or 'show'.
         */
        universalSearchKnowledgeBaseSearch: string;
    }

    export interface GetBrandingPoliciesPrioritiesItem {
        /**
         * An ordered list of branding policy IDs that determines the priority order of how to apply the policies
         */
        brandingPolicyIds: string[];
    }

    export interface GetCameraBoundariesAreasByDeviceItem {
        /**
         * Configured area boundaries of the camera
         */
        boundaries: outputs.organizations.GetCameraBoundariesAreasByDeviceItemBoundaries;
        /**
         * The network id of the camera
         */
        networkId: string;
        /**
         * The serial number of the camera
         */
        serial: string;
    }

    export interface GetCameraBoundariesAreasByDeviceItemBoundaries {
        /**
         * The area boundary id
         */
        id: string;
        /**
         * The area boundary name
         */
        name: string;
        /**
         * The area boundary type
         */
        type: string;
        /**
         * The area boundary vertices
         */
        vertices: outputs.organizations.GetCameraBoundariesAreasByDeviceItemBoundariesVertex[];
    }

    export interface GetCameraBoundariesAreasByDeviceItemBoundariesVertex {
        /**
         * The vertex x coordinate
         */
        x: number;
        /**
         * The vertex y coordinate
         */
        y: number;
    }

    export interface GetCameraBoundariesLinesByDeviceItem {
        /**
         * Configured line boundaries of the camera
         */
        boundaries: outputs.organizations.GetCameraBoundariesLinesByDeviceItemBoundaries;
        /**
         * The network id of the camera
         */
        networkId: string;
        /**
         * The serial number of the camera
         */
        serial: string;
    }

    export interface GetCameraBoundariesLinesByDeviceItemBoundaries {
        /**
         * The line boundary crossing direction vertex
         */
        directionVertex: outputs.organizations.GetCameraBoundariesLinesByDeviceItemBoundariesDirectionVertex;
        /**
         * The line boundary id
         */
        id: string;
        /**
         * The line boundary name
         */
        name: string;
        /**
         * The line boundary type
         */
        type: string;
        /**
         * The line boundary vertices
         */
        vertices: outputs.organizations.GetCameraBoundariesLinesByDeviceItemBoundariesVertex[];
    }

    export interface GetCameraBoundariesLinesByDeviceItemBoundariesDirectionVertex {
        /**
         * The vertex x coordinate
         */
        x: number;
        /**
         * The vertex y coordinate
         */
        y: number;
    }

    export interface GetCameraBoundariesLinesByDeviceItemBoundariesVertex {
        /**
         * The vertex x coordinate
         */
        x: number;
        /**
         * The vertex y coordinate
         */
        y: number;
    }

    export interface GetCameraCustomAnalyticsArtifactsItem {
        /**
         * Custom analytics artifact ID
         */
        artifactId: string;
        /**
         * Custom analytics artifact name
         */
        name: string;
        /**
         * Organization ID
         */
        organizationId: string;
        /**
         * Custom analytics artifact status
         */
        status: outputs.organizations.GetCameraCustomAnalyticsArtifactsItemStatus;
    }

    export interface GetCameraCustomAnalyticsArtifactsItemStatus {
        /**
         * Status message
         */
        message: string;
        /**
         * Status type
         */
        type: string;
    }

    export interface GetCameraDetectionsHistoryByBoundaryByIntervalItem {
        /**
         * The boundary id
         */
        boundaryId: string;
        /**
         * The analytics data
         */
        results: outputs.organizations.GetCameraDetectionsHistoryByBoundaryByIntervalItemResults;
        /**
         * The boundary type
         */
        type: string;
    }

    export interface GetCameraDetectionsHistoryByBoundaryByIntervalItemResults {
        /**
         * The period end time
         */
        endTime: string;
        /**
         * The number of detections entered
         */
        in: number;
        /**
         * The detection type
         */
        objectType: string;
        /**
         * The number of detections exited
         */
        out: number;
        /**
         * The period start time
         */
        startTime: string;
    }

    export interface GetCameraPermissionsItem {
        /**
         * Permission scope id
         */
        id: string;
        /**
         * Permission scope level
         */
        level: string;
        /**
         * Name of permission scope
         */
        name: string;
    }

    export interface GetCameraRolesItem {
        appliedOnDevices: outputs.organizations.GetCameraRolesItemAppliedOnDevice[];
        appliedOnNetworks: outputs.organizations.GetCameraRolesItemAppliedOnNetwork[];
        appliedOrgWides: outputs.organizations.GetCameraRolesItemAppliedOrgWide[];
        name: string;
    }

    export interface GetCameraRolesItemAppliedOnDevice {
        id: string;
        permissionLevel: string;
        permissionScope: string;
        permissionScopeId: string;
        tag: string;
    }

    export interface GetCameraRolesItemAppliedOnNetwork {
        id: string;
        permissionLevel: string;
        permissionScope: string;
        permissionScopeId: string;
        tag: string;
    }

    export interface GetCameraRolesItemAppliedOrgWide {
        permissionLevel: string;
        permissionScope: string;
        permissionScopeId: string;
        tag: string;
    }

    export interface GetCellularGatewayUplinkStatusesItem {
        /**
         * Last reported time for the device
         */
        lastReportedAt: string;
        /**
         * Device model
         */
        model: string;
        /**
         * Network Id
         */
        networkId: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * Uplinks info
         */
        uplinks: outputs.organizations.GetCellularGatewayUplinkStatusesItemUplink[];
    }

    export interface GetCellularGatewayUplinkStatusesItemUplink {
        /**
         * Access Point Name
         */
        apn: string;
        /**
         * Connection Type
         */
        connectionType: string;
        /**
         * Primary DNS IP
         */
        dns1: string;
        /**
         * Secondary DNS IP
         */
        dns2: string;
        /**
         * Gateway IP
         */
        gateway: string;
        /**
         * Integrated Circuit Card Identification Number
         */
        iccid: string;
        /**
         * Uplink interface
         */
        interface: string;
        /**
         * Uplink IP
         */
        ip: string;
        /**
         * Uplink model
         */
        model: string;
        /**
         * Network Provider
         */
        provider: string;
        /**
         * Public IP
         */
        publicIp: string;
        /**
         * Tower Signal Status
         */
        signalStat: outputs.organizations.GetCellularGatewayUplinkStatusesItemUplinkSignalStat;
        /**
         * Signal Type
         */
        signalType: string;
        /**
         * Uplink status
         */
        status: string;
    }

    export interface GetCellularGatewayUplinkStatusesItemUplinkSignalStat {
        /**
         * Reference Signal Received Power
         */
        rsrp: string;
        /**
         * Reference Signal Received Quality
         */
        rsrq: string;
    }

    export interface GetClientsBandwidthUsageHistoryItem {
        /**
         * Downloaded data, in mbps.
         */
        downstream: number;
        /**
         * Total bandwidth usage, in mbps.
         */
        total: number;
        /**
         * Timestamp for the bandwidth usage snapshot.
         */
        ts: string;
        /**
         * Uploaded data, in mbps.
         */
        upstream: number;
    }

    export interface GetClientsOverviewItem {
        /**
         * Client count information
         */
        counts: outputs.organizations.GetClientsOverviewItemCounts;
        /**
         * Usage information of all clients across organization
         */
        usage: outputs.organizations.GetClientsOverviewItemUsage;
    }

    export interface GetClientsOverviewItemCounts {
        /**
         * Total number of clients with data usage in organization
         */
        total: number;
    }

    export interface GetClientsOverviewItemUsage {
        /**
         * Average data usage (in kb) of each client in organization
         */
        average: number;
        /**
         * Overall data usage of all clients across organization
         */
        overall: outputs.organizations.GetClientsOverviewItemUsageOverall;
    }

    export interface GetClientsOverviewItemUsageOverall {
        /**
         * Downstream data usage (in kb) of all clients across organization
         */
        downstream: number;
        /**
         * Total data usage (in kb) of all clients across organization
         */
        total: number;
        /**
         * Upstream data usage (in kb) of all clients across organization
         */
        upstream: number;
    }

    export interface GetClientsSearchItem {
        clientId: string;
        mac: string;
        manufacturer: string;
        records: outputs.organizations.GetClientsSearchItemRecord[];
    }

    export interface GetClientsSearchItemRecord {
        cdp: string;
        clientVpnConnections: outputs.organizations.GetClientsSearchItemRecordClientVpnConnection[];
        description: string;
        firstSeen: number;
        ip: string;
        ip6: string;
        lastSeen: number;
        lldps: string[];
        network: outputs.organizations.GetClientsSearchItemRecordNetwork;
        os: string;
        smInstalled: boolean;
        ssid: string;
        status: string;
        switchport: string;
        user: string;
        vlan: string;
        wirelessCapabilities: string;
    }

    export interface GetClientsSearchItemRecordClientVpnConnection {
        connectedAt: number;
        disconnectedAt: number;
        remoteIp: string;
    }

    export interface GetClientsSearchItemRecordNetwork {
        enrollmentString: string;
        id: string;
        isBoundToConfigTemplate: boolean;
        name: string;
        notes: string;
        organizationId: string;
        productTypes: string[];
        tags: string[];
        timeZone: string;
    }

    export interface GetConfigTemplatesItem {
        /**
         * The ID of the network or config template to copy configuration from
         */
        id: string;
        /**
         * The name of the configuration template
         */
        name: string;
        /**
         * The product types of the configuration template
         */
        productTypes: string[];
        /**
         * The timezone of the configuration template. For a list of allowed timezones, please see the 'TZ' column in the table in \n\nthis article\n\n. Not applicable if copying from existing network or template
         */
        timeZone: string;
    }

    export interface GetConfigTemplatesSwitchProfilesItem {
        /**
         * Switch model
         */
        model: string;
        /**
         * Switch template name
         */
        name: string;
        /**
         * Switch template id
         */
        switchProfileId: string;
    }

    export interface GetConfigTemplatesSwitchProfilesPortsItem {
        /**
         * The number of a custom access policy to configure on the switch template port. Only applicable when 'accessPolicyType' is 'Custom access policy'.
         */
        accessPolicyNumber: number;
        /**
         * The type of the access policy of the switch template port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
         */
        accessPolicyType: string;
        /**
         * The VLANs allowed on the switch template port. Only applicable to trunk ports.
         */
        allowedVlans: string;
        /**
         * If true, ARP packets for this port will be considered trusted, and Dynamic ARP Inspection will allow the traffic.
         */
        daiTrusted: boolean;
        /**
         * The status of the switch template port.
         */
        enabled: boolean;
        /**
         * For supported switches (e.g. MS420/MS425), whether or not the port has flexible stacking enabled.
         */
        flexibleStackingEnabled: boolean;
        /**
         * The isolation status of the switch template port.
         */
        isolationEnabled: boolean;
        /**
         * The link speed for the switch template port.
         */
        linkNegotiation: string;
        /**
         * Available link speeds for the switch template port.
         */
        linkNegotiationCapabilities: string[];
        /**
         * Only devices with MAC addresses specified in this list will have access to this port. Up to 20 MAC addresses can be defined. Only applicable when 'accessPolicyType' is 'MAC allow list'.
         */
        macAllowLists: string[];
        /**
         * Port mirror
         */
        mirror: outputs.organizations.GetConfigTemplatesSwitchProfilesPortsItemMirror;
        /**
         * Expansion module
         */
        module: outputs.organizations.GetConfigTemplatesSwitchProfilesPortsItemModule;
        /**
         * The name of the switch template port.
         */
        name: string;
        /**
         * The PoE status of the switch template port.
         */
        poeEnabled: boolean;
        /**
         * The identifier of the switch template port.
         */
        portId: string;
        /**
         * The ID of the port schedule. A value of null will clear the port schedule.
         */
        portScheduleId: string;
        /**
         * Profile attributes
         */
        profile: outputs.organizations.GetConfigTemplatesSwitchProfilesPortsItemProfile;
        /**
         * The rapid spanning tree protocol status.
         */
        rstpEnabled: boolean;
        /**
         * The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
         */
        stickyMacAllowListLimit: number;
        /**
         * The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
         */
        stickyMacAllowLists: string[];
        /**
         * The storm control status of the switch template port.
         */
        stormControlEnabled: boolean;
        /**
         * The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
         */
        stpGuard: string;
        /**
         * The list of tags of the switch template port.
         */
        tags: string[];
        /**
         * The type of the switch template port ('trunk' or 'access').
         */
        type: string;
        /**
         * The action to take when Unidirectional Link is detected (Alert only, Enforce). Default configuration is Alert only.
         */
        udld: string;
        /**
         * The VLAN of the switch template port. For a trunk port, this is the native VLAN. A null value will clear the value set for trunk ports.
         */
        vlan: number;
        /**
         * The voice VLAN of the switch template port. Only applicable to access ports.
         */
        voiceVlan: number;
    }

    export interface GetConfigTemplatesSwitchProfilesPortsItemMirror {
        /**
         * The port mirror mode. Can be one of ('Destination port', 'Source port' or 'Not mirroring traffic').
         */
        mode: string;
    }

    export interface GetConfigTemplatesSwitchProfilesPortsItemModule {
        /**
         * The model of the expansion module.
         */
        model: string;
    }

    export interface GetConfigTemplatesSwitchProfilesPortsItemProfile {
        /**
         * When enabled, override this port's configuration with a port profile.
         */
        enabled: boolean;
        /**
         * When enabled, the ID of the port profile used to override the port's configuration.
         */
        id: string;
        /**
         * When enabled, the IName of the profile.
         */
        iname: string;
    }

    export interface GetDevicesAvailabilitiesChangeHistoryItem {
        /**
         * Details about the status changes
         */
        details: outputs.organizations.GetDevicesAvailabilitiesChangeHistoryItemDetails;
        /**
         * Device information
         */
        device: outputs.organizations.GetDevicesAvailabilitiesChangeHistoryItemDevice;
        /**
         * Network information
         */
        network: outputs.organizations.GetDevicesAvailabilitiesChangeHistoryItemNetwork;
        /**
         * Timestamp, in iso8601 format, at which the event happened
         */
        ts: string;
    }

    export interface GetDevicesAvailabilitiesChangeHistoryItemDetails {
        /**
         * Details about the new status
         */
        news: outputs.organizations.GetDevicesAvailabilitiesChangeHistoryItemDetailsNews[];
        /**
         * Details about the old status
         */
        olds: outputs.organizations.GetDevicesAvailabilitiesChangeHistoryItemDetailsOld[];
    }

    export interface GetDevicesAvailabilitiesChangeHistoryItemDetailsNews {
        /**
         * Name of the detail
         */
        name: string;
        /**
         * Value of the detail
         */
        value: string;
    }

    export interface GetDevicesAvailabilitiesChangeHistoryItemDetailsOld {
        /**
         * Name of the detail
         */
        name: string;
        /**
         * Value of the detail
         */
        value: string;
    }

    export interface GetDevicesAvailabilitiesChangeHistoryItemDevice {
        /**
         * Device model
         */
        model: string;
        /**
         * Device name
         */
        name: string;
        /**
         * Device product type.
         */
        productType: string;
        /**
         * Device serial number
         */
        serial: string;
    }

    export interface GetDevicesAvailabilitiesChangeHistoryItemNetwork {
        /**
         * Network id
         */
        id: string;
        /**
         * Network name
         */
        name: string;
        /**
         * Network tags
         */
        tags: string[];
        /**
         * Network dashboard url
         */
        url: string;
    }

    export interface GetDevicesAvailabilitiesItem {
        /**
         * The device MAC address.
         */
        mac: string;
        /**
         * The device name.
         */
        name: string;
        /**
         * Network info.
         */
        network: outputs.organizations.GetDevicesAvailabilitiesItemNetwork;
        /**
         * Device product type.
         */
        productType: string;
        /**
         * The device serial number.
         */
        serial: string;
        /**
         * Status of the device. Possible values are: online, alerting, offline, dormant.
         */
        status: string;
        /**
         * List of custom tags for the device.
         */
        tags: string[];
    }

    export interface GetDevicesAvailabilitiesItemNetwork {
        /**
         * ID for the network containing the device.
         */
        id: string;
    }

    export interface GetDevicesBootsHistoryItem {
        /**
         * Device network
         */
        network: outputs.organizations.GetDevicesBootsHistoryItemNetwork;
        /**
         * Device serial number
         */
        serial: string;
        /**
         * Device power up
         */
        start: outputs.organizations.GetDevicesBootsHistoryItemStart;
    }

    export interface GetDevicesBootsHistoryItemNetwork {
        /**
         * API-formatted network ID
         */
        id: string;
    }

    export interface GetDevicesBootsHistoryItemStart {
        /**
         * Indicates when the device booted
         */
        bootedAt: string;
    }

    export interface GetDevicesItem {
        /**
         * Physical address of the device
         */
        address: string;
        /**
         * Additional device information
         */
        details: outputs.organizations.GetDevicesItemDetail[];
        /**
         * Firmware version of the device
         */
        firmware: string;
        /**
         * IMEI of the device, if applicable
         */
        imei: number;
        /**
         * LAN IP address of the device
         */
        lanIp: string;
        /**
         * Latitude of the device
         */
        lat: number;
        /**
         * Longitude of the device
         */
        lng: number;
        /**
         * MAC address of the device
         */
        mac: string;
        /**
         * Model of the device
         */
        model: string;
        /**
         * Name of the device
         */
        name: string;
        /**
         * ID of the network the device belongs to
         */
        networkId: string;
        /**
         * Notes for the device, limited to 255 characters
         */
        notes: string;
        /**
         * Product type of the device
         */
        productType: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * List of tags assigned to the device
         */
        tags: string[];
    }

    export interface GetDevicesItemDetail {
        /**
         * Additional property name
         */
        name: string;
        /**
         * Additional property value
         */
        value: string;
    }

    export interface GetDevicesPowerModulesStatusesByDeviceItem {
        /**
         * The device MAC address.
         */
        mac: string;
        /**
         * The device name.
         */
        name: string;
        /**
         * Network info.
         */
        network: outputs.organizations.GetDevicesPowerModulesStatusesByDeviceItemNetwork;
        /**
         * Device product type.
         */
        productType: string;
        /**
         * The device serial number.
         */
        serial: string;
        /**
         * Information for the device's AC power supplies.
         */
        slots: outputs.organizations.GetDevicesPowerModulesStatusesByDeviceItemSlot[];
        /**
         * List of custom tags for the device.
         */
        tags: string[];
    }

    export interface GetDevicesPowerModulesStatusesByDeviceItemNetwork {
        /**
         * ID for the network that the device is associated with.
         */
        id: string;
    }

    export interface GetDevicesPowerModulesStatusesByDeviceItemSlot {
        /**
         * The power supply unit model.
         */
        model: string;
        /**
         * Which slot the AC power supply occupies. Possible values are: 0, 1, 2.
         */
        number: number;
        /**
         * The power supply unit serial number.
         */
        serial: string;
        /**
         * Status of the power supply unit. Possible values are: connected, not connected, powering.
         */
        status: string;
    }

    export interface GetDevicesProvisioningStatusesItem {
        /**
         * The device MAC address.
         */
        mac: string;
        /**
         * The device name.
         */
        name: string;
        /**
         * Network info.
         */
        network: outputs.organizations.GetDevicesProvisioningStatusesItemNetwork;
        /**
         * Device product type.
         */
        productType: string;
        /**
         * The device serial number.
         */
        serial: string;
        /**
         * The device provisioning status. Possible statuses: unprovisioned, incomplete, complete.
         */
        status: string;
        /**
         * List of custom tags for the device.
         */
        tags: string[];
    }

    export interface GetDevicesProvisioningStatusesItemNetwork {
        /**
         * ID for the network containing the device.
         */
        id: string;
    }

    export interface GetDevicesStatusesItem {
        /**
         * Components
         */
        components: outputs.organizations.GetDevicesStatusesItemComponents;
        /**
         * IP Gateway
         */
        gateway: string;
        /**
         * IP Type
         */
        ipType: string;
        /**
         * LAN IP Address
         */
        lanIp: string;
        /**
         * Device Last Reported Location
         */
        lastReportedAt: string;
        /**
         * MAC Address
         */
        mac: string;
        /**
         * Model
         */
        model: string;
        /**
         * Device Name
         */
        name: string;
        /**
         * Network ID
         */
        networkId: string;
        /**
         * Primary DNS
         */
        primaryDns: string;
        /**
         * Product Type
         */
        productType: string;
        /**
         * Public IP Address
         */
        publicIp: string;
        /**
         * Secondary DNS
         */
        secondaryDns: string;
        /**
         * Device Serial Number
         */
        serial: string;
        /**
         * Device Status
         */
        status: string;
        /**
         * Tags
         */
        tags: string[];
    }

    export interface GetDevicesStatusesItemComponents {
        /**
         * Power Supplies
         */
        powerSupplies: outputs.organizations.GetDevicesStatusesItemComponentsPowerSupply[];
    }

    export interface GetDevicesStatusesItemComponentsPowerSupply {
        /**
         * Model of the power supply
         */
        model: string;
        /**
         * PoE info of the power supply
         */
        poe: outputs.organizations.GetDevicesStatusesItemComponentsPowerSupplyPoe;
        /**
         * Serial of the power supply
         */
        serial: string;
        /**
         * Slot the power supply is in
         */
        slot: number;
        /**
         * Status of the power supply
         */
        status: string;
    }

    export interface GetDevicesStatusesItemComponentsPowerSupplyPoe {
        /**
         * Maximum PoE this power supply can provide when connected to the current switch model
         */
        maximum: number;
        /**
         * Unit of the PoE maximum
         */
        unit: string;
    }

    export interface GetDevicesStatusesOverviewItem {
        /**
         * counts
         */
        counts: outputs.organizations.GetDevicesStatusesOverviewItemCounts;
    }

    export interface GetDevicesStatusesOverviewItemCounts {
        /**
         * byStatus
         */
        byStatus: outputs.organizations.GetDevicesStatusesOverviewItemCountsByStatus;
    }

    export interface GetDevicesStatusesOverviewItemCountsByStatus {
        /**
         * alerting count
         */
        alerting: number;
        /**
         * dormant count
         */
        dormant: number;
        /**
         * offline count
         */
        offline: number;
        /**
         * online count
         */
        online: number;
    }

    export interface GetDevicesUplinksAddressesByDeviceItem {
        /**
         * The device MAC address.
         */
        mac: string;
        /**
         * The device name.
         */
        name: string;
        /**
         * Network info.
         */
        network: outputs.organizations.GetDevicesUplinksAddressesByDeviceItemNetwork;
        /**
         * Device product type.
         */
        productType: string;
        /**
         * The device serial number.
         */
        serial: string;
        /**
         * List of custom tags for the device.
         */
        tags: string[];
        /**
         * List of device uplink addresses information.
         */
        uplinks: outputs.organizations.GetDevicesUplinksAddressesByDeviceItemUplink[];
    }

    export interface GetDevicesUplinksAddressesByDeviceItemNetwork {
        /**
         * ID for the network containing the device.
         */
        id: string;
    }

    export interface GetDevicesUplinksAddressesByDeviceItemUplink {
        /**
         * Available addresses for the interface.
         */
        addresses: outputs.organizations.GetDevicesUplinksAddressesByDeviceItemUplinkAddress[];
        /**
         * Interface for the device uplink. Available options are: cellular, man1, man2, wan1, wan2
         */
        interface: string;
    }

    export interface GetDevicesUplinksAddressesByDeviceItemUplinkAddress {
        /**
         * Device uplink address.
         */
        address: string;
        /**
         * Indicates how the device uplink address is assigned. Available options are: static, dynamic.
         */
        assignmentMode: string;
        /**
         * Device uplink gateway address.
         */
        gateway: string;
        /**
         * Type of address for the device uplink. Available options are: ipv4, ipv6.
         */
        protocol: string;
        /**
         * Public interface information.
         */
        public: outputs.organizations.GetDevicesUplinksAddressesByDeviceItemUplinkAddressPublic;
    }

    export interface GetDevicesUplinksAddressesByDeviceItemUplinkAddressPublic {
        /**
         * The device uplink public IP address.
         */
        address: string;
    }

    export interface GetDevicesUplinksLossAndLatencyItem {
        /**
         * IP address of uplink
         */
        ip: string;
        /**
         * Network ID
         */
        networkId: string;
        /**
         * Serial of MX device
         */
        serial: string;
        /**
         * Loss and latency timeseries data
         */
        timeSeries: outputs.organizations.GetDevicesUplinksLossAndLatencyItemTimeSeries[];
        /**
         * Uplink interface (wan1, wan2, or cellular)
         */
        uplink: string;
    }

    export interface GetDevicesUplinksLossAndLatencyItemTimeSeries {
        /**
         * Latency in milliseconds
         */
        latencyMs: number;
        /**
         * Loss percentage
         */
        lossPercent: number;
        /**
         * Timestamp for this data point
         */
        ts: string;
    }

    export interface GetEarlyAccessFeaturesItem {
        /**
         * Descriptions of the early access feature
         */
        descriptions: outputs.organizations.GetEarlyAccessFeaturesItemDescriptions;
        /**
         * Link to the documentation of this early access feature
         */
        documentationLink: string;
        /**
         * If this early access feature can only be opted in for the entire organization
         */
        isOrgScopedOnly: boolean;
        /**
         * Name of the early access feature
         */
        name: string;
        /**
         * Short name of the early access feature
         */
        shortName: string;
        /**
         * Link to get support for this early access feature
         */
        supportLink: string;
        /**
         * Topic of the early access feature
         */
        topic: string;
    }

    export interface GetEarlyAccessFeaturesItemDescriptions {
        /**
         * Long description
         */
        long: string;
        /**
         * Short description
         */
        short: string;
    }

    export interface GetEarlyAccessFeaturesOptInsItem {
        /**
         * Time when Early Access Feature was created
         */
        createdAt: string;
        /**
         * ID of Early Access Feature
         */
        id: string;
        /**
         * Networks assigned to the Early Access Feature
         */
        limitScopeToNetworks: outputs.organizations.GetEarlyAccessFeaturesOptInsItemLimitScopeToNetwork[];
        /**
         * Name of Early Access Feature
         */
        shortName: string;
    }

    export interface GetEarlyAccessFeaturesOptInsItemLimitScopeToNetwork {
        /**
         * ID of Network
         */
        id: string;
        /**
         * Name of Network
         */
        name: string;
    }

    export interface GetFirmwareUpgradesByDeviceItem {
        /**
         * Status of the device upgrade
         */
        deviceStatus: string;
        /**
         * Name assigned to the device
         */
        name: string;
        /**
         * Serial of the device
         */
        serial: string;
        /**
         * The devices upgrade details and status
         */
        upgrade: outputs.organizations.GetFirmwareUpgradesByDeviceItemUpgrade;
    }

    export interface GetFirmwareUpgradesByDeviceItemUpgrade {
        /**
         * The initial version of the device
         */
        fromVersion: outputs.organizations.GetFirmwareUpgradesByDeviceItemUpgradeFromVersion;
        /**
         * ID of the upgrade
         */
        id: string;
        /**
         * Staged upgrade
         */
        staged: outputs.organizations.GetFirmwareUpgradesByDeviceItemUpgradeStaged;
        /**
         * Status of the upgrade
         */
        status: string;
        /**
         * Start time of the upgrade
         */
        time: string;
        /**
         * Version the device is upgrading to
         */
        toVersion: outputs.organizations.GetFirmwareUpgradesByDeviceItemUpgradeToVersion;
        /**
         * ID of the upgrade batch
         */
        upgradeBatchId: string;
    }

    export interface GetFirmwareUpgradesByDeviceItemUpgradeFromVersion {
        /**
         * ID of the initial firmware version
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesByDeviceItemUpgradeStaged {
        /**
         * The staged upgrade group
         */
        group: outputs.organizations.GetFirmwareUpgradesByDeviceItemUpgradeStagedGroup;
    }

    export interface GetFirmwareUpgradesByDeviceItemUpgradeStagedGroup {
        /**
         * Id of the staged upgrade group
         */
        id: string;
    }

    export interface GetFirmwareUpgradesByDeviceItemUpgradeToVersion {
        /**
         * ID of the initial firmware version
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItem {
        /**
         * Timestamp when upgrade completed. Null if status pending.
         */
        completedAt: string;
        /**
         * ID of the upgrade's starting version
         */
        fromVersion: outputs.organizations.GetFirmwareUpgradesItemFromVersion;
        /**
         * Network of the upgrade
         */
        network: outputs.organizations.GetFirmwareUpgradesItemNetwork;
        /**
         * product upgraded [wireless, appliance, switch, systemsManager, camera, cellularGateway, sensor]
         */
        productTypes: string;
        /**
         * Status of upgrade event: [Cancelled, Completed]
         */
        status: string;
        /**
         * Scheduled start time
         */
        time: string;
        /**
         * ID of the upgrade's target version
         */
        toVersion: outputs.organizations.GetFirmwareUpgradesItemToVersion;
        /**
         * The upgrade batch
         */
        upgradeBatchId: string;
        /**
         * The upgrade
         */
        upgradeId: string;
    }

    export interface GetFirmwareUpgradesItemFromVersion {
        /**
         * Firmware name
         */
        firmware: string;
        /**
         * Firmware version ID
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetFirmwareUpgradesItemNetwork {
        /**
         * ID of network
         */
        id: string;
        /**
         * The network
         */
        name: string;
    }

    export interface GetFirmwareUpgradesItemToVersion {
        /**
         * Firmware name
         */
        firmware: string;
        /**
         * Firmware version ID
         */
        id: string;
        /**
         * Release date of the firmware version
         */
        releaseDate: string;
        /**
         * Release type of the firmware version
         */
        releaseType: string;
        /**
         * Firmware version short name
         */
        shortName: string;
    }

    export interface GetInsightApplicationsItem {
        /**
         * Application identifier
         */
        applicationId: string;
        /**
         * Application name
         */
        name: string;
        /**
         * Thresholds defined by a user or Meraki models for each application
         */
        thresholds: outputs.organizations.GetInsightApplicationsItemThresholds;
    }

    export interface GetInsightApplicationsItemThresholds {
        /**
         * Threshold for each network
         */
        byNetworks: outputs.organizations.GetInsightApplicationsItemThresholdsByNetwork[];
        /**
         * Threshold type (static or smart)
         */
        type: string;
    }

    export interface GetInsightApplicationsItemThresholdsByNetwork {
        /**
         * Number of useful information bits delivered over a network per unit of time
         */
        goodput: number;
        /**
         * Network identifier
         */
        networkId: string;
        /**
         * Duration of the response, in milliseconds
         */
        responseDuration: number;
    }

    export interface GetInsightMonitoredMediaServersItem {
        /**
         * The IP address (IPv4 only) or hostname of the media server to monitor
         */
        address: string;
        /**
         * Indicates that if the media server doesn't respond to ICMP pings, the nearest hop will be used in its stead
         */
        bestEffortMonitoringEnabled: boolean;
        /**
         * Monitored media server id
         */
        id: string;
        /**
         * The name of the VoIP provider
         */
        name: string;
    }

    export interface GetInventoryDevicesItem {
        /**
         * Claimed time of the device
         */
        claimedAt: string;
        /**
         * Country/region code from device, network, or store order
         */
        countryCode: string;
        /**
         * Additional device information
         */
        details: outputs.organizations.GetInventoryDevicesItemDetail[];
        /**
         * License expiration date of the device
         */
        licenseExpirationDate: string;
        /**
         * MAC address of the device
         */
        mac: string;
        /**
         * Model type of the device
         */
        model: string;
        /**
         * Name of the device
         */
        name: string;
        /**
         * Network Id of the device
         */
        networkId: string;
        /**
         * Order number of the device
         */
        orderNumber: string;
        /**
         * Product type of the device
         */
        productType: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * Device tags
         */
        tags: string[];
    }

    export interface GetInventoryDevicesItemDetail {
        /**
         * Additional property name
         */
        name: string;
        /**
         * Additional property value
         */
        value: string;
    }

    export interface GetInventoryOnboardingCloudMonitoringImportsItem {
        /**
         * Represents the details of an imported device.
         */
        device: outputs.organizations.GetInventoryOnboardingCloudMonitoringImportsItemDevice;
        /**
         * Database ID for the new entity entry.
         */
        importId: string;
    }

    export interface GetInventoryOnboardingCloudMonitoringImportsItemDevice {
        /**
         * Whether or not the device was successfully created in dashboard.
         */
        created: boolean;
        /**
         * Represents the current state of importing the device.
         */
        status: string;
        /**
         * The url to the device details page within dashboard.
         */
        url: string;
    }

    export interface GetInventoryOnboardingCloudMonitoringNetworksItem {
        /**
         * Enrollment string for the network
         */
        enrollmentString: string;
        /**
         * Network ID
         */
        id: string;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate: boolean;
        /**
         * Network name
         */
        name: string;
        /**
         * Notes for the network
         */
        notes: string;
        /**
         * Organization ID
         */
        organizationId: string;
        /**
         * List of the product types that the network supports
         */
        productTypes: string[];
        /**
         * Network tags
         */
        tags: string[];
        /**
         * Timezone of the network
         */
        timeZone: string;
        /**
         * URL to the network Dashboard UI
         */
        url: string;
    }

    export interface GetLicensesItem {
        /**
         * The date the license started burning
         */
        activationDate: string;
        /**
         * The date the license was claimed into the organization
         */
        claimDate: string;
        /**
         * Serial number of the device the license is assigned to
         */
        deviceSerial: string;
        /**
         * The duration of the individual license
         */
        durationInDays: number;
        /**
         * The date the license will expire
         */
        expirationDate: string;
        /**
         * The id of the head license this license is queued behind. If there is no head license, it returns nil.
         */
        headLicenseId: string;
        /**
         * License ID
         */
        id: string;
        /**
         * License key
         */
        licenseKey: string;
        /**
         * License type
         */
        licenseType: string;
        /**
         * ID of the network the license is assigned to
         */
        networkId: string;
        /**
         * Order number
         */
        orderNumber: string;
        /**
         * DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
         */
        permanentlyQueuedLicenses: outputs.organizations.GetLicensesItemPermanentlyQueuedLicense[];
        /**
         * The number of seats of the license. Only applicable to SM licenses.
         */
        seatCount: number;
        /**
         * The state of the license. All queued licenses have a status of *recentlyQueued*.
         */
        state: string;
        /**
         * The duration of the license plus all permanently queued licenses associated with it
         */
        totalDurationInDays: number;
    }

    export interface GetLicensesItemPermanentlyQueuedLicense {
        /**
         * The duration of the individual license
         */
        durationInDays: number;
        /**
         * Permanently queued license ID
         */
        id: string;
        /**
         * License key
         */
        licenseKey: string;
        /**
         * License type
         */
        licenseType: string;
        /**
         * Order number
         */
        orderNumber: string;
    }

    export interface GetLicensesOverviewItem {
        /**
         * License expiration date (Co-termination licensing only)
         */
        expirationDate: string;
        /**
         * Total number of licenses (Per-device licensing only)
         */
        licenseCount: number;
        /**
         * Data by license type (Per-device licensing only)
         */
        licenseTypes: outputs.organizations.GetLicensesOverviewItemLicenseType[];
        /**
         * License counts (Co-termination licensing only)
         */
        licensedDeviceCounts: string;
        /**
         * Aggregated data for licenses by state (Per-device licensing only)
         */
        states: outputs.organizations.GetLicensesOverviewItemStates;
        /**
         * License status (Co-termination licensing only)
         */
        status: string;
        /**
         * Aggregated data for Systems Manager licenses (Per-device licensing only)
         */
        systemsManager: outputs.organizations.GetLicensesOverviewItemSystemsManager;
    }

    export interface GetLicensesOverviewItemLicenseType {
        /**
         * Aggregated count data for the license type
         */
        counts: outputs.organizations.GetLicensesOverviewItemLicenseTypeCounts;
        /**
         * License type
         */
        licenseType: string;
    }

    export interface GetLicensesOverviewItemLicenseTypeCounts {
        /**
         * The number of unassigned licenses
         */
        unassigned: number;
    }

    export interface GetLicensesOverviewItemStates {
        /**
         * Data for active licenses
         */
        active: outputs.organizations.GetLicensesOverviewItemStatesActive;
        /**
         * Data for expired licenses
         */
        expired: outputs.organizations.GetLicensesOverviewItemStatesExpired;
        /**
         * Data for expiring licenses
         */
        expiring: outputs.organizations.GetLicensesOverviewItemStatesExpiring;
        /**
         * Data for recently queued licenses
         */
        recentlyQueued: outputs.organizations.GetLicensesOverviewItemStatesRecentlyQueued;
        /**
         * Data for unused licenses
         */
        unused: outputs.organizations.GetLicensesOverviewItemStatesUnused;
        /**
         * Data for unused, active licenses
         */
        unusedActive: outputs.organizations.GetLicensesOverviewItemStatesUnusedActive;
    }

    export interface GetLicensesOverviewItemStatesActive {
        /**
         * The number of active licenses
         */
        count: number;
    }

    export interface GetLicensesOverviewItemStatesExpired {
        /**
         * The number of expired licenses
         */
        count: number;
    }

    export interface GetLicensesOverviewItemStatesExpiring {
        /**
         * The number of expiring licenses
         */
        count: number;
        /**
         * Data for the critical threshold
         */
        critical: outputs.organizations.GetLicensesOverviewItemStatesExpiringCritical;
        /**
         * Data for the warning threshold
         */
        warning: outputs.organizations.GetLicensesOverviewItemStatesExpiringWarning;
    }

    export interface GetLicensesOverviewItemStatesExpiringCritical {
        /**
         * The number of licenses that will expire in this window
         */
        expiringCount: number;
        /**
         * The number of days from now denoting the critical threshold for an expiring license
         */
        thresholdInDays: number;
    }

    export interface GetLicensesOverviewItemStatesExpiringWarning {
        /**
         * The number of licenses that will expire in this window
         */
        expiringCount: number;
        /**
         * The number of days from now denoting the warning threshold for an expiring license
         */
        thresholdInDays: number;
    }

    export interface GetLicensesOverviewItemStatesRecentlyQueued {
        /**
         * The number of recently queued licenses
         */
        count: number;
    }

    export interface GetLicensesOverviewItemStatesUnused {
        /**
         * The number of unused licenses
         */
        count: number;
        /**
         * Information about the soonest forthcoming license activation
         */
        soonestActivation: outputs.organizations.GetLicensesOverviewItemStatesUnusedSoonestActivation;
    }

    export interface GetLicensesOverviewItemStatesUnusedActive {
        /**
         * The number of unused, active licenses
         */
        count: number;
        /**
         * Information about the oldest historical license activation
         */
        oldestActivation: outputs.organizations.GetLicensesOverviewItemStatesUnusedActiveOldestActivation;
    }

    export interface GetLicensesOverviewItemStatesUnusedActiveOldestActivation {
        /**
         * The oldest license activation date
         */
        activationDate: string;
        /**
         * The number of licenses that activated on this date
         */
        activeCount: number;
    }

    export interface GetLicensesOverviewItemStatesUnusedSoonestActivation {
        /**
         * The soonest license activation date
         */
        activationDate: string;
        /**
         * The number of licenses that will activate on this date
         */
        toActivateCount: number;
    }

    export interface GetLicensesOverviewItemSystemsManager {
        /**
         * Aggregated license count data for Systems Manager
         */
        counts: outputs.organizations.GetLicensesOverviewItemSystemsManagerCounts;
    }

    export interface GetLicensesOverviewItemSystemsManagerCounts {
        /**
         * The number of Systems Manager seats in use
         */
        activeSeats: number;
        /**
         * The total number of enrolled Systems Manager devices
         */
        orgwideEnrolledDevices: number;
        /**
         * The total number of Systems Manager seats
         */
        totalSeats: number;
        /**
         * The number of unused Systems Manager seats
         */
        unassignedSeats: number;
    }

    export interface GetLicensingCotermLicensesItem {
        /**
         * When the license was claimed into the organization
         */
        claimedAt: string;
        /**
         * The counts of the license by model type
         */
        counts: outputs.organizations.GetLicensingCotermLicensesItemCount[];
        /**
         * The duration (term length) of the license, measured in days
         */
        duration: number;
        /**
         * The editions of the license for each relevant product type
         */
        editions: outputs.organizations.GetLicensingCotermLicensesItemEdition[];
        /**
         * Flag to indicate if the license is expired
         */
        expired: boolean;
        /**
         * Flag to indicated that the license is invalidated
         */
        invalidated: boolean;
        /**
         * When the license was invalidated. Will be null for active licenses
         */
        invalidatedAt: string;
        /**
         * The key of the license
         */
        key: string;
        /**
         * The operation mode of the license when it was claimed
         */
        mode: string;
        /**
         * The ID of the organization that the license is claimed in
         */
        organizationId: string;
        /**
         * When the license's term began (approximately the date when the license was created)
         */
        startedAt: string;
    }

    export interface GetLicensingCotermLicensesItemCount {
        /**
         * The number of counts the license contains of this model
         */
        count: number;
        /**
         * The license model type
         */
        model: string;
    }

    export interface GetLicensingCotermLicensesItemEdition {
        /**
         * The name of the license edition
         */
        edition: string;
        /**
         * The product type of the license edition
         */
        productType: string;
    }

    export interface GetLoginSecurityItem {
        /**
         * Number of consecutive failed login attempts after which users' accounts will be locked.
         */
        accountLockoutAttempts: number;
        /**
         * Details for indicating whether organization will restrict access to API (but not Dashboard) to certain IP addresses.
         */
        apiAuthentication: outputs.organizations.GetLoginSecurityItemApiAuthentication;
        /**
         * Boolean indicating whether users' Dashboard accounts will be locked out after a specified number of consecutive failed login attempts.
         */
        enforceAccountLockout: boolean;
        /**
         * Boolean indicating whether users, when setting a new password, are forced to choose a new password that is different from any past passwords.
         */
        enforceDifferentPasswords: boolean;
        /**
         * Boolean indicating whether users will be logged out after being idle for the specified number of minutes.
         */
        enforceIdleTimeout: boolean;
        /**
         * Boolean indicating whether organization will restrict access to Dashboard (including the API) from certain IP addresses.
         */
        enforceLoginIpRanges: boolean;
        /**
         * Boolean indicating whether users are forced to change their password every X number of days.
         */
        enforcePasswordExpiration: boolean;
        /**
         * Boolean indicating whether users will be forced to choose strong passwords for their accounts. Strong passwords are at least 8 characters that contain 3 of the following: number, uppercase letter, lowercase letter, and symbol
         */
        enforceStrongPasswords: boolean;
        /**
         * Boolean indicating whether users in this organization will be required to use an extra verification code when logging in to Dashboard. This code will be sent to their mobile phone via SMS, or can be generated by the authenticator application.
         */
        enforceTwoFactorAuth: boolean;
        /**
         * Number of minutes users can remain idle before being logged out of their accounts.
         */
        idleTimeoutMinutes: number;
        /**
         * List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
         */
        loginIpRanges: string[];
        /**
         * Number of recent passwords that new password must be distinct from.
         */
        numDifferentPasswords: number;
        /**
         * Number of days after which users will be forced to change their password.
         */
        passwordExpirationDays: number;
    }

    export interface GetLoginSecurityItemApiAuthentication {
        /**
         * Details for API-only IP restrictions.
         */
        ipRestrictionsForKeys: outputs.organizations.GetLoginSecurityItemApiAuthenticationIpRestrictionsForKeys;
    }

    export interface GetLoginSecurityItemApiAuthenticationIpRestrictionsForKeys {
        /**
         * Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
         */
        enabled: boolean;
        /**
         * List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
         */
        ranges: string[];
    }

    export interface GetOpenapiSpecItem {
        info: outputs.organizations.GetOpenapiSpecItemInfo;
        openapi: string;
        paths: outputs.organizations.GetOpenapiSpecItemPaths;
    }

    export interface GetOpenapiSpecItemInfo {
        description: string;
        title: string;
        version: string;
    }

    export interface GetOpenapiSpecItemPaths {
        organizations: outputs.organizations.GetOpenapiSpecItemPathsOrganizations;
    }

    export interface GetOpenapiSpecItemPathsOrganizations {
        get: outputs.organizations.GetOpenapiSpecItemPathsOrganizationsGet;
    }

    export interface GetOpenapiSpecItemPathsOrganizationsGet {
        description: string;
        operationId: string;
        responses: outputs.organizations.GetOpenapiSpecItemPathsOrganizationsGetResponses;
    }

    export interface GetOpenapiSpecItemPathsOrganizationsGetResponses {
        status200: outputs.organizations.GetOpenapiSpecItemPathsOrganizationsGetResponsesStatus200;
    }

    export interface GetOpenapiSpecItemPathsOrganizationsGetResponsesStatus200 {
        description: string;
        examples: outputs.organizations.GetOpenapiSpecItemPathsOrganizationsGetResponsesStatus200Examples;
    }

    export interface GetOpenapiSpecItemPathsOrganizationsGetResponsesStatus200Examples {
        applicationJsons: outputs.organizations.GetOpenapiSpecItemPathsOrganizationsGetResponsesStatus200ExamplesApplicationJson[];
    }

    export interface GetOpenapiSpecItemPathsOrganizationsGetResponsesStatus200ExamplesApplicationJson {
        id: string;
        name: string;
    }

    export interface GetPolicyObjectsGroupsItem {
        /**
         * Type of object groups. (NetworkObjectGroup, GeoLocationGroup, PortObjectGroup, ApplicationGroup)
         */
        category: string;
        /**
         * Time Stamp of policy object creation.
         */
        createdAt: string;
        /**
         * Policy object ID
         */
        id: string;
        /**
         * Name of the Policy object group.
         */
        name: string;
        /**
         * Network ID's associated with the policy objects.
         */
        networkIds: string[];
        /**
         * Policy objects associated with Network Object Group or Port Object Group
         */
        objectIds: string[];
        /**
         * Time Stamp of policy object updation.
         */
        updatedAt: string;
    }

    export interface GetPolicyObjectsItem {
        /**
         * Category of a policy object (one of: adaptivePolicy, network)
         */
        category: string;
        /**
         * CIDR Value of a policy object
         */
        cidr: string;
        /**
         * Time Stamp of policy object creation.
         */
        createdAt: string;
        /**
         * The IDs of policy object groups the policy object belongs to.
         */
        groupIds: string[];
        /**
         * Policy object ID
         */
        id: string;
        /**
         * Name of policy object (alphanumeric, space, dash, or underscore characters only).
         */
        name: string;
        /**
         * The IDs of the networks that use the policy object.
         */
        networkIds: string[];
        /**
         * Type of a policy object (one of: adaptivePolicyIpv4Cidr, cidr, fqdn, ipAndMask)
         */
        type: string;
        /**
         * Time Stamp of policy object updation.
         */
        updatedAt: string;
    }

    export interface GetSamlIdpsItem {
        /**
         * URL that is consuming SAML Identity Provider (IdP)
         */
        consumerUrl: string;
        /**
         * ID associated with the SAML Identity Provider (IdP)
         */
        idpId: string;
        /**
         * Dashboard will redirect users to this URL when they sign out.
         */
        sloLogoutUrl: string;
        /**
         * Fingerprint (SHA1) of the SAML certificate provided by your Identity Provider (IdP). This will be used for encryption / validation.
         */
        x509certSha1Fingerprint: string;
    }

    export interface GetSamlItem {
        /**
         * Toggle depicting if SAML SSO settings are enabled
         */
        enabled: boolean;
    }

    export interface GetSamlRolesItem {
        /**
         * The list of camera access privileges for SAML administrator
         */
        cameras: outputs.organizations.GetSamlRolesItemCamera[];
        /**
         * ID associated with the SAML role
         */
        id: string;
        /**
         * The list of networks that the SAML administrator has privileges on
         */
        networks: outputs.organizations.GetSamlRolesItemNetwork[];
        /**
         * The privilege of the SAML administrator on the organization
         */
        orgAccess: string;
        /**
         * The role of the SAML administrator
         */
        role: string;
        /**
         * The list of tags that the SAML administrator has privleges on
         */
        tags: outputs.organizations.GetSamlRolesItemTag[];
    }

    export interface GetSamlRolesItemCamera {
        /**
         * Camera access ability
         */
        access: string;
        /**
         * Whether or not SAML administrator has org-wide access
         */
        orgWide: boolean;
    }

    export interface GetSamlRolesItemNetwork {
        /**
         * The privilege of the SAML administrator on the network
         */
        access: string;
        /**
         * The network ID
         */
        id: string;
    }

    export interface GetSamlRolesItemTag {
        /**
         * The privilege of the SAML administrator on the tag
         */
        access: string;
        /**
         * The name of the tag
         */
        tag: string;
    }

    export interface GetSensorReadingsHistoryItem {
        /**
         * Reading for the 'apparentPower' metric. This will only be present if the 'metric' property equals 'apparentPower'.
         */
        apparentPower: outputs.organizations.GetSensorReadingsHistoryItemApparentPower;
        /**
         * Reading for the 'battery' metric. This will only be present if the 'metric' property equals 'battery'.
         */
        battery: outputs.organizations.GetSensorReadingsHistoryItemBattery;
        /**
         * Reading for the 'button' metric. This will only be present if the 'metric' property equals 'button'.
         */
        button: outputs.organizations.GetSensorReadingsHistoryItemButton;
        /**
         * Reading for the 'co2' metric. This will only be present if the 'metric' property equals 'co2'.
         */
        co2: outputs.organizations.GetSensorReadingsHistoryItemCo2;
        /**
         * Reading for the 'current' metric. This will only be present if the 'metric' property equals 'current'.
         */
        current: outputs.organizations.GetSensorReadingsHistoryItemCurrent;
        /**
         * Reading for the 'door' metric. This will only be present if the 'metric' property equals 'door'.
         */
        door: outputs.organizations.GetSensorReadingsHistoryItemDoor;
        /**
         * Reading for the 'downstreamPower' metric. This will only be present if the 'metric' property equals 'downstreamPower'.
         */
        downstreamPower: outputs.organizations.GetSensorReadingsHistoryItemDownstreamPower;
        /**
         * Reading for the 'frequency' metric. This will only be present if the 'metric' property equals 'frequency'.
         */
        frequency: outputs.organizations.GetSensorReadingsHistoryItemFrequency;
        /**
         * Reading for the 'humidity' metric. This will only be present if the 'metric' property equals 'humidity'.
         */
        humidity: outputs.organizations.GetSensorReadingsHistoryItemHumidity;
        /**
         * Reading for the 'indoorAirQuality' metric. This will only be present if the 'metric' property equals 'indoorAirQuality'.
         */
        indoorAirQuality: outputs.organizations.GetSensorReadingsHistoryItemIndoorAirQuality;
        /**
         * Type of sensor reading.
         */
        metric: string;
        /**
         * Network to which the sensor belongs.
         */
        network: outputs.organizations.GetSensorReadingsHistoryItemNetwork;
        /**
         * Reading for the 'noise' metric. This will only be present if the 'metric' property equals 'noise'.
         */
        noise: outputs.organizations.GetSensorReadingsHistoryItemNoise;
        /**
         * Reading for the 'pm25' metric. This will only be present if the 'metric' property equals 'pm25'.
         */
        pm25: outputs.organizations.GetSensorReadingsHistoryItemPm25;
        /**
         * Reading for the 'powerFactor' metric. This will only be present if the 'metric' property equals 'powerFactor'.
         */
        powerFactor: outputs.organizations.GetSensorReadingsHistoryItemPowerFactor;
        /**
         * Reading for the 'realPower' metric. This will only be present if the 'metric' property equals 'realPower'.
         */
        realPower: outputs.organizations.GetSensorReadingsHistoryItemRealPower;
        /**
         * Reading for the 'remoteLockoutSwitch' metric. This will only be present if the 'metric' property equals 'remoteLockoutSwitch'.
         */
        remoteLockoutSwitch: outputs.organizations.GetSensorReadingsHistoryItemRemoteLockoutSwitch;
        /**
         * Serial number of the sensor that took the reading.
         */
        serial: string;
        /**
         * Reading for the 'temperature' metric. This will only be present if the 'metric' property equals 'temperature'.
         */
        temperature: outputs.organizations.GetSensorReadingsHistoryItemTemperature;
        /**
         * Time at which the reading occurred, in ISO8601 format.
         */
        ts: string;
        /**
         * Reading for the 'tvoc' metric. This will only be present if the 'metric' property equals 'tvoc'.
         */
        tvoc: outputs.organizations.GetSensorReadingsHistoryItemTvoc;
        /**
         * Reading for the 'voltage' metric. This will only be present if the 'metric' property equals 'voltage'.
         */
        voltage: outputs.organizations.GetSensorReadingsHistoryItemVoltage;
        /**
         * Reading for the 'water' metric. This will only be present if the 'metric' property equals 'water'.
         */
        water: outputs.organizations.GetSensorReadingsHistoryItemWater;
    }

    export interface GetSensorReadingsHistoryItemApparentPower {
        /**
         * Apparent power reading in volt-amperes.
         */
        draw: number;
    }

    export interface GetSensorReadingsHistoryItemBattery {
        /**
         * Remaining battery life.
         */
        percentage: number;
    }

    export interface GetSensorReadingsHistoryItemButton {
        /**
         * Type of button press that occurred.
         */
        pressType: string;
    }

    export interface GetSensorReadingsHistoryItemCo2 {
        /**
         * CO2 reading in parts per million.
         */
        concentration: number;
    }

    export interface GetSensorReadingsHistoryItemCurrent {
        /**
         * Electrical current reading in amperes.
         */
        draw: number;
    }

    export interface GetSensorReadingsHistoryItemDoor {
        /**
         * True if the door is open.
         */
        open: boolean;
    }

    export interface GetSensorReadingsHistoryItemDownstreamPower {
        /**
         * True if power is turned on to the device that is connected downstream of the MT40 power monitor.
         */
        enabled: boolean;
    }

    export interface GetSensorReadingsHistoryItemFrequency {
        /**
         * Electrical current frequency reading in hertz.
         */
        level: number;
    }

    export interface GetSensorReadingsHistoryItemHumidity {
        /**
         * Humidity reading in %RH.
         */
        relativePercentage: number;
    }

    export interface GetSensorReadingsHistoryItemIndoorAirQuality {
        /**
         * Indoor air quality score between 0 and 100.
         */
        score: number;
    }

    export interface GetSensorReadingsHistoryItemNetwork {
        /**
         * ID of the network.
         */
        id: string;
        /**
         * Name of the network.
         */
        name: string;
    }

    export interface GetSensorReadingsHistoryItemNoise {
        /**
         * Ambient noise reading.
         */
        ambient: outputs.organizations.GetSensorReadingsHistoryItemNoiseAmbient;
    }

    export interface GetSensorReadingsHistoryItemNoiseAmbient {
        /**
         * Ambient noise reading in adjusted decibels.
         */
        level: number;
    }

    export interface GetSensorReadingsHistoryItemPm25 {
        /**
         * PM2.5 reading in micrograms per cubic meter.
         */
        concentration: number;
    }

    export interface GetSensorReadingsHistoryItemPowerFactor {
        /**
         * Power factor reading as a percentage.
         */
        percentage: number;
    }

    export interface GetSensorReadingsHistoryItemRealPower {
        /**
         * Real power reading in watts.
         */
        draw: number;
    }

    export interface GetSensorReadingsHistoryItemRemoteLockoutSwitch {
        /**
         * True if power controls are disabled via the MT40's physical remote lockout switch.
         */
        locked: boolean;
    }

    export interface GetSensorReadingsHistoryItemTemperature {
        /**
         * Temperature reading in degrees Celsius.
         */
        celsius: number;
        /**
         * Temperature reading in degrees Fahrenheit.
         */
        fahrenheit: number;
    }

    export interface GetSensorReadingsHistoryItemTvoc {
        /**
         * TVOC reading in micrograms per cubic meter.
         */
        concentration: number;
    }

    export interface GetSensorReadingsHistoryItemVoltage {
        /**
         * Voltage reading in volts.
         */
        level: number;
    }

    export interface GetSensorReadingsHistoryItemWater {
        /**
         * True if water is detected.
         */
        present: boolean;
    }

    export interface GetSensorReadingsLatestItem {
        /**
         * Network to which the sensor belongs.
         */
        network: outputs.organizations.GetSensorReadingsLatestItemNetwork;
        /**
         * Array of latest readings from the sensor. Each object represents a single reading for a single metric.
         */
        readings: outputs.organizations.GetSensorReadingsLatestItemReading[];
        /**
         * Serial number of the sensor that took the readings.
         */
        serial: string;
    }

    export interface GetSensorReadingsLatestItemNetwork {
        /**
         * ID of the network.
         */
        id: string;
        /**
         * Name of the network.
         */
        name: string;
    }

    export interface GetSensorReadingsLatestItemReading {
        /**
         * Reading for the 'apparentPower' metric. This will only be present if the 'metric' property equals 'apparentPower'.
         */
        apparentPower: outputs.organizations.GetSensorReadingsLatestItemReadingApparentPower;
        /**
         * Reading for the 'battery' metric. This will only be present if the 'metric' property equals 'battery'.
         */
        battery: outputs.organizations.GetSensorReadingsLatestItemReadingBattery;
        /**
         * Reading for the 'button' metric. This will only be present if the 'metric' property equals 'button'.
         */
        button: outputs.organizations.GetSensorReadingsLatestItemReadingButton;
        /**
         * Reading for the 'co2' metric. This will only be present if the 'metric' property equals 'co2'.
         */
        co2: outputs.organizations.GetSensorReadingsLatestItemReadingCo2;
        /**
         * Reading for the 'current' metric. This will only be present if the 'metric' property equals 'current'.
         */
        current: outputs.organizations.GetSensorReadingsLatestItemReadingCurrent;
        /**
         * Reading for the 'door' metric. This will only be present if the 'metric' property equals 'door'.
         */
        door: outputs.organizations.GetSensorReadingsLatestItemReadingDoor;
        /**
         * Reading for the 'downstreamPower' metric. This will only be present if the 'metric' property equals 'downstreamPower'.
         */
        downstreamPower: outputs.organizations.GetSensorReadingsLatestItemReadingDownstreamPower;
        /**
         * Reading for the 'frequency' metric. This will only be present if the 'metric' property equals 'frequency'.
         */
        frequency: outputs.organizations.GetSensorReadingsLatestItemReadingFrequency;
        /**
         * Reading for the 'humidity' metric. This will only be present if the 'metric' property equals 'humidity'.
         */
        humidity: outputs.organizations.GetSensorReadingsLatestItemReadingHumidity;
        /**
         * Reading for the 'indoorAirQuality' metric. This will only be present if the 'metric' property equals 'indoorAirQuality'.
         */
        indoorAirQuality: outputs.organizations.GetSensorReadingsLatestItemReadingIndoorAirQuality;
        /**
         * Type of sensor reading.
         */
        metric: string;
        /**
         * Reading for the 'noise' metric. This will only be present if the 'metric' property equals 'noise'.
         */
        noise: outputs.organizations.GetSensorReadingsLatestItemReadingNoise;
        /**
         * Reading for the 'pm25' metric. This will only be present if the 'metric' property equals 'pm25'.
         */
        pm25: outputs.organizations.GetSensorReadingsLatestItemReadingPm25;
        /**
         * Reading for the 'powerFactor' metric. This will only be present if the 'metric' property equals 'powerFactor'.
         */
        powerFactor: outputs.organizations.GetSensorReadingsLatestItemReadingPowerFactor;
        /**
         * Reading for the 'realPower' metric. This will only be present if the 'metric' property equals 'realPower'.
         */
        realPower: outputs.organizations.GetSensorReadingsLatestItemReadingRealPower;
        /**
         * Reading for the 'remoteLockoutSwitch' metric. This will only be present if the 'metric' property equals 'remoteLockoutSwitch'.
         */
        remoteLockoutSwitch: outputs.organizations.GetSensorReadingsLatestItemReadingRemoteLockoutSwitch;
        /**
         * Reading for the 'temperature' metric. This will only be present if the 'metric' property equals 'temperature'.
         */
        temperature: outputs.organizations.GetSensorReadingsLatestItemReadingTemperature;
        /**
         * Time at which the reading occurred, in ISO8601 format.
         */
        ts: string;
        /**
         * Reading for the 'tvoc' metric. This will only be present if the 'metric' property equals 'tvoc'.
         */
        tvoc: outputs.organizations.GetSensorReadingsLatestItemReadingTvoc;
        /**
         * Reading for the 'voltage' metric. This will only be present if the 'metric' property equals 'voltage'.
         */
        voltage: outputs.organizations.GetSensorReadingsLatestItemReadingVoltage;
        /**
         * Reading for the 'water' metric. This will only be present if the 'metric' property equals 'water'.
         */
        water: outputs.organizations.GetSensorReadingsLatestItemReadingWater;
    }

    export interface GetSensorReadingsLatestItemReadingApparentPower {
        /**
         * Apparent power reading in volt-amperes.
         */
        draw: number;
    }

    export interface GetSensorReadingsLatestItemReadingBattery {
        /**
         * Remaining battery life.
         */
        percentage: number;
    }

    export interface GetSensorReadingsLatestItemReadingButton {
        /**
         * Type of button press that occurred.
         */
        pressType: string;
    }

    export interface GetSensorReadingsLatestItemReadingCo2 {
        /**
         * CO2 reading in parts per million.
         */
        concentration: number;
    }

    export interface GetSensorReadingsLatestItemReadingCurrent {
        /**
         * Electrical current reading in amperes.
         */
        draw: number;
    }

    export interface GetSensorReadingsLatestItemReadingDoor {
        /**
         * True if the door is open.
         */
        open: boolean;
    }

    export interface GetSensorReadingsLatestItemReadingDownstreamPower {
        /**
         * True if power is turned on to the device that is connected downstream of the MT40 power monitor.
         */
        enabled: boolean;
    }

    export interface GetSensorReadingsLatestItemReadingFrequency {
        /**
         * Electrical current frequency reading in hertz.
         */
        level: number;
    }

    export interface GetSensorReadingsLatestItemReadingHumidity {
        /**
         * Humidity reading in %RH.
         */
        relativePercentage: number;
    }

    export interface GetSensorReadingsLatestItemReadingIndoorAirQuality {
        /**
         * Indoor air quality score between 0 and 100.
         */
        score: number;
    }

    export interface GetSensorReadingsLatestItemReadingNoise {
        /**
         * Ambient noise reading.
         */
        ambient: outputs.organizations.GetSensorReadingsLatestItemReadingNoiseAmbient;
    }

    export interface GetSensorReadingsLatestItemReadingNoiseAmbient {
        /**
         * Ambient noise reading in adjusted decibels.
         */
        level: number;
    }

    export interface GetSensorReadingsLatestItemReadingPm25 {
        /**
         * PM2.5 reading in micrograms per cubic meter.
         */
        concentration: number;
    }

    export interface GetSensorReadingsLatestItemReadingPowerFactor {
        /**
         * Power factor reading as a percentage.
         */
        percentage: number;
    }

    export interface GetSensorReadingsLatestItemReadingRealPower {
        /**
         * Real power reading in watts.
         */
        draw: number;
    }

    export interface GetSensorReadingsLatestItemReadingRemoteLockoutSwitch {
        /**
         * True if power controls are disabled via the MT40's physical remote lockout switch.
         */
        locked: boolean;
    }

    export interface GetSensorReadingsLatestItemReadingTemperature {
        /**
         * Temperature reading in degrees Celsius.
         */
        celsius: number;
        /**
         * Temperature reading in degrees Fahrenheit.
         */
        fahrenheit: number;
    }

    export interface GetSensorReadingsLatestItemReadingTvoc {
        /**
         * TVOC reading in micrograms per cubic meter.
         */
        concentration: number;
    }

    export interface GetSensorReadingsLatestItemReadingVoltage {
        /**
         * Voltage reading in volts.
         */
        level: number;
    }

    export interface GetSensorReadingsLatestItemReadingWater {
        /**
         * True if water is detected.
         */
        present: boolean;
    }

    export interface GetSmAdminsRolesItem {
        /**
         * The name of the limited access role
         */
        name: string;
        /**
         * The Id of the limited access role
         */
        roleId: string;
        /**
         * The scope of the limited access role
         */
        scope: string;
        /**
         * The tags of the limited access role
         */
        tags: string[];
    }

    export interface GetSmApnsCertItem {
        /**
         * Organization APNS Certificate used by devices to communication with Apple
         */
        certificate: string;
    }

    export interface GetSmSentryPoliciesAssignmentsByNetworkItem {
        /**
         * Sentry Group Policies for the Organization keyed by the Network or Locale Id the Policy belongs to
         */
        items: outputs.organizations.GetSmSentryPoliciesAssignmentsByNetworkItemItem[];
        /**
         * Metadata relevant to the paginated dataset
         */
        meta: outputs.organizations.GetSmSentryPoliciesAssignmentsByNetworkItemMeta;
    }

    export interface GetSmSentryPoliciesAssignmentsByNetworkItemItem {
        /**
         * The Id of the Network
         */
        networkId: string;
        /**
         * Array of Sentry Group Policies for the Network
         */
        policies: outputs.organizations.GetSmSentryPoliciesAssignmentsByNetworkItemItemPolicy[];
    }

    export interface GetSmSentryPoliciesAssignmentsByNetworkItemItemPolicy {
        /**
         * The creation time of the Sentry Policy
         */
        createdAt: string;
        /**
         * The number of the Group Policy
         */
        groupNumber: string;
        /**
         * The Id of the Group Policy. This is associated with the network specified by the networkId.
         */
        groupPolicyId: string;
        /**
         * The last update time of the Sentry Policy
         */
        lastUpdatedAt: string;
        /**
         * The Id of the Network the Sentry Policy is associated with. In a locale, this should be the Wireless Group if present, otherwise the Wired Group.
         */
        networkId: string;
        /**
         * The Id of the Sentry Policy
         */
        policyId: string;
        /**
         * The priority of the Sentry Policy
         */
        priority: string;
        /**
         * The scope of the Sentry Policy
         */
        scope: string;
        /**
         * The Id of the Systems Manager Network the Sentry Policy is assigned to
         */
        smNetworkId: string;
        /**
         * The tags of the Sentry Policy
         */
        tags: string[];
    }

    export interface GetSmSentryPoliciesAssignmentsByNetworkItemMeta {
        /**
         * Counts relating to the paginated dataset
         */
        counts: outputs.organizations.GetSmSentryPoliciesAssignmentsByNetworkItemMetaCounts;
    }

    export interface GetSmSentryPoliciesAssignmentsByNetworkItemMetaCounts {
        /**
         * Counts relating to the paginated items
         */
        items: outputs.organizations.GetSmSentryPoliciesAssignmentsByNetworkItemMetaCountsItems;
    }

    export interface GetSmSentryPoliciesAssignmentsByNetworkItemMetaCountsItems {
        /**
         * The number of items in the dataset that are available on subsequent pages
         */
        remaining: number;
        /**
         * The total number of items in the dataset
         */
        total: number;
    }

    export interface GetSmVppAccountsItem {
        /**
         * The allowed admins for the VPP account
         */
        allowedAdmins: string;
        /**
         * The network IDs of the assignable networks for the VPP account
         */
        assignableNetworkIds: string[];
        /**
         * The assignable networks for the VPP account
         */
        assignableNetworks: string;
        /**
         * The VPP service token
         */
        contentToken: string;
        /**
         * The email address associated with the VPP account
         */
        email: string;
        /**
         * The id of the VPP Account
         */
        id: string;
        /**
         * The last time the VPP account was force synced
         */
        lastForceSyncedAt: string;
        /**
         * The last time the VPP account was synced
         */
        lastSyncedAt: string;
        /**
         * The name of the VPP account
         */
        name: string;
        /**
         * The network IDs of the admins for the VPP account
         */
        networkIdAdmins: string;
        /**
         * The parsed VPP service token
         */
        parsedToken: outputs.organizations.GetSmVppAccountsItemParsedToken;
        /**
         * The id of the VPP Account
         */
        vppAccountId: string;
        /**
         * The VPP location ID
         */
        vppLocationId: string;
        /**
         * The VPP location name
         */
        vppLocationName: string;
        /**
         * The VPP Account's Service Token
         */
        vppServiceToken: string;
    }

    export interface GetSmVppAccountsItemParsedToken {
        /**
         * The expiration time of the token
         */
        expiresAt: string;
        /**
         * The hashed token
         */
        hashedToken: string;
        /**
         * The organization name
         */
        orgName: string;
    }

    export interface GetSnmpItem {
        /**
         * The hostname of the SNMP server.
         */
        hostname: string;
        /**
         * The list of IPv4 addresses that are allowed to access the SNMP server.
         */
        peerIps: string[];
        /**
         * The port of the SNMP server.
         */
        port: number;
        /**
         * The community string for SNMP version 2c, if enabled.
         */
        v2CommunityString: string;
        /**
         * Boolean indicating whether SNMP version 2c is enabled for the organization.
         */
        v2cEnabled: boolean;
        /**
         * The SNMP version 3 authentication mode. Can be either 'MD5' or 'SHA'.
         */
        v3AuthMode: string;
        /**
         * Boolean indicating whether SNMP version 3 is enabled for the organization.
         */
        v3Enabled: boolean;
        /**
         * The SNMP version 3 privacy mode. Can be either 'DES' or 'AES128'.
         */
        v3PrivMode: string;
        /**
         * The user for SNMP version 3, if enabled.
         */
        v3User: string;
    }

    export interface GetSummaryTopAppliancesByUtilizationItem {
        /**
         * Mac address of the appliance
         */
        mac: string;
        /**
         * Model of the appliance
         */
        model: string;
        /**
         * Name of the appliance
         */
        name: string;
        /**
         * Network info
         */
        network: outputs.organizations.GetSummaryTopAppliancesByUtilizationItemNetwork;
        /**
         * Serial number of the appliance
         */
        serial: string;
        /**
         * Utilization of the appliance
         */
        utilization: outputs.organizations.GetSummaryTopAppliancesByUtilizationItemUtilization;
    }

    export interface GetSummaryTopAppliancesByUtilizationItemNetwork {
        /**
         * Network id
         */
        id: string;
        /**
         * Network name
         */
        name: string;
    }

    export interface GetSummaryTopAppliancesByUtilizationItemUtilization {
        /**
         * Average utilization of the appliance
         */
        average: outputs.organizations.GetSummaryTopAppliancesByUtilizationItemUtilizationAverage;
    }

    export interface GetSummaryTopAppliancesByUtilizationItemUtilizationAverage {
        /**
         * Average percentage utilization of the appliance
         */
        percentage: number;
    }

    export interface GetSummaryTopClientsByUsageItem {
        /**
         * ID of client
         */
        id: string;
        /**
         * MAC address of client
         */
        mac: string;
        /**
         * Name of client
         */
        name: string;
        network: outputs.organizations.GetSummaryTopClientsByUsageItemNetwork;
        /**
         * Data usage information
         */
        usage: outputs.organizations.GetSummaryTopClientsByUsageItemUsage;
    }

    export interface GetSummaryTopClientsByUsageItemNetwork {
        /**
         * ID of network
         */
        id: string;
        /**
         * Name of network
         */
        name: string;
    }

    export interface GetSummaryTopClientsByUsageItemUsage {
        /**
         * Downstream data usage by client
         */
        downstream: number;
        /**
         * Percentage of total data usage by client
         */
        percentage: number;
        /**
         * Total data usage by client
         */
        total: number;
        /**
         * Upstream data usage by client
         */
        upstream: number;
    }

    export interface GetSummaryTopClientsManufacturersByUsageItem {
        /**
         * Clients info
         */
        clients: outputs.organizations.GetSummaryTopClientsManufacturersByUsageItemClients;
        /**
         * Name of the manufacturer
         */
        name: string;
        /**
         * Clients usage
         */
        usage: outputs.organizations.GetSummaryTopClientsManufacturersByUsageItemUsage;
    }

    export interface GetSummaryTopClientsManufacturersByUsageItemClients {
        /**
         * Counts of clients
         */
        counts: outputs.organizations.GetSummaryTopClientsManufacturersByUsageItemClientsCounts;
    }

    export interface GetSummaryTopClientsManufacturersByUsageItemClientsCounts {
        /**
         * Total counts of clients
         */
        total: number;
    }

    export interface GetSummaryTopClientsManufacturersByUsageItemUsage {
        /**
         * Downstream data usage by client
         */
        downstream: number;
        /**
         * Total data usage by client
         */
        total: number;
        /**
         * Upstream data usage by client
         */
        upstream: number;
    }

    export interface GetSummaryTopDevicesByUsageItem {
        /**
         * Clients
         */
        clients: outputs.organizations.GetSummaryTopDevicesByUsageItemClients;
        /**
         * Mac address of the device
         */
        mac: string;
        /**
         * Model of the device
         */
        model: string;
        /**
         * Name of the device
         */
        name: string;
        /**
         * Network info
         */
        network: outputs.organizations.GetSummaryTopDevicesByUsageItemNetwork;
        /**
         * Product type of the device
         */
        productType: string;
        /**
         * Serial number of the device
         */
        serial: string;
        /**
         * Data usage of the device
         */
        usage: outputs.organizations.GetSummaryTopDevicesByUsageItemUsage;
    }

    export interface GetSummaryTopDevicesByUsageItemClients {
        /**
         * Counts of clients
         */
        counts: outputs.organizations.GetSummaryTopDevicesByUsageItemClientsCounts;
    }

    export interface GetSummaryTopDevicesByUsageItemClientsCounts {
        /**
         * Total counts of clients
         */
        total: number;
    }

    export interface GetSummaryTopDevicesByUsageItemNetwork {
        /**
         * Network id
         */
        id: string;
        /**
         * Network name
         */
        name: string;
    }

    export interface GetSummaryTopDevicesByUsageItemUsage {
        /**
         * Data usage of the device by percentage
         */
        percentage: number;
        /**
         * Total data usage of the device
         */
        total: number;
    }

    export interface GetSummaryTopDevicesModelsByUsageItem {
        /**
         * Total number of devices per model
         */
        count: number;
        /**
         * The device model
         */
        model: string;
        /**
         * Usage info in megabytes
         */
        usage: outputs.organizations.GetSummaryTopDevicesModelsByUsageItemUsage;
    }

    export interface GetSummaryTopDevicesModelsByUsageItemUsage {
        /**
         * Average usage in megabytes
         */
        average: number;
        /**
         * Total usage in megabytes
         */
        total: number;
    }

    export interface GetSummaryTopNetworksByStatusItem {
        /**
         * Network clients data
         */
        clients: outputs.organizations.GetSummaryTopNetworksByStatusItemClients;
        /**
         * Network device information
         */
        devices: outputs.organizations.GetSummaryTopNetworksByStatusItemDevices;
        /**
         * Network name
         */
        name: string;
        /**
         * Network identifier
         */
        networkId: string;
        /**
         * Product types in network
         */
        productTypes: string[];
        /**
         * Network device statuses
         */
        statuses: outputs.organizations.GetSummaryTopNetworksByStatusItemStatuses;
        /**
         * Network tags
         */
        tags: string[];
        /**
         * Network clients list URL
         */
        url: string;
    }

    export interface GetSummaryTopNetworksByStatusItemClients {
        /**
         * Network client counts
         */
        counts: outputs.organizations.GetSummaryTopNetworksByStatusItemClientsCounts;
        /**
         * Network client usage data
         */
        usage: outputs.organizations.GetSummaryTopNetworksByStatusItemClientsUsage;
    }

    export interface GetSummaryTopNetworksByStatusItemClientsCounts {
        /**
         * Total count of clients in network
         */
        total: number;
    }

    export interface GetSummaryTopNetworksByStatusItemClientsUsage {
        /**
         * Total downstream usage in network, in KB
         */
        downstream: number;
        /**
         * Total upstream usage in network, in KB
         */
        upstream: number;
    }

    export interface GetSummaryTopNetworksByStatusItemDevices {
        /**
         * URLs by product type
         */
        byProductTypes: outputs.organizations.GetSummaryTopNetworksByStatusItemDevicesByProductType[];
    }

    export interface GetSummaryTopNetworksByStatusItemDevicesByProductType {
        /**
         * Product type
         */
        productType: string;
        /**
         * URL to clients list for the relevant product type
         */
        url: string;
    }

    export interface GetSummaryTopNetworksByStatusItemStatuses {
        /**
         * List of status counts by product type
         */
        byProductTypes: outputs.organizations.GetSummaryTopNetworksByStatusItemStatusesByProductType[];
        /**
         * Overall status of network
         */
        overall: string;
    }

    export interface GetSummaryTopNetworksByStatusItemStatusesByProductType {
        /**
         * Counts of devices by status
         */
        counts: outputs.organizations.GetSummaryTopNetworksByStatusItemStatusesByProductTypeCounts;
        /**
         * Product type
         */
        productType: string;
    }

    export interface GetSummaryTopNetworksByStatusItemStatusesByProductTypeCounts {
        /**
         * Count of alerting devices
         */
        alerting: number;
        /**
         * Count of dormant devices
         */
        dormant: number;
        /**
         * Count of offline devices
         */
        offline: number;
        /**
         * Count of online devices
         */
        online: number;
    }

    export interface GetSummaryTopSsidsByUsageItem {
        /**
         * Clients info of the SSID
         */
        clients: outputs.organizations.GetSummaryTopSsidsByUsageItemClients;
        /**
         * Name of the SSID
         */
        name: string;
        /**
         * Date usage of the SSID, in megabytes
         */
        usage: outputs.organizations.GetSummaryTopSsidsByUsageItemUsage;
    }

    export interface GetSummaryTopSsidsByUsageItemClients {
        /**
         * Counts of the clients
         */
        counts: outputs.organizations.GetSummaryTopSsidsByUsageItemClientsCounts;
    }

    export interface GetSummaryTopSsidsByUsageItemClientsCounts {
        /**
         * Total counts of the clients
         */
        total: number;
    }

    export interface GetSummaryTopSsidsByUsageItemUsage {
        /**
         * Downstream usage of the SSID
         */
        downstream: number;
        /**
         * Percentage usage of the SSID
         */
        percentage: number;
        /**
         * Total usage of the SSID
         */
        total: number;
        /**
         * Upstream usage of the SSID
         */
        upstream: number;
    }

    export interface GetSummaryTopSwitchesByEnergyUsageItem {
        /**
         * Mac address of the switch
         */
        mac: string;
        /**
         * Model of the switch
         */
        model: string;
        /**
         * Name of the switch
         */
        name: string;
        /**
         * Network info
         */
        network: outputs.organizations.GetSummaryTopSwitchesByEnergyUsageItemNetwork;
        /**
         * Energy usage of the switch
         */
        usage: outputs.organizations.GetSummaryTopSwitchesByEnergyUsageItemUsage;
    }

    export interface GetSummaryTopSwitchesByEnergyUsageItemNetwork {
        /**
         * Network id
         */
        id: string;
        /**
         * Network name
         */
        name: string;
    }

    export interface GetSummaryTopSwitchesByEnergyUsageItemUsage {
        /**
         * Total energy usage of the switch
         */
        total: number;
    }

    export interface GetSwitchPortsBySwitchItem {
        /**
         * The MAC address of the switch.
         */
        mac: string;
        /**
         * The model of the switch.
         */
        model: string;
        /**
         * The name of the switch.
         */
        name: string;
        /**
         * Identifying information of the switch's network.
         */
        network: outputs.organizations.GetSwitchPortsBySwitchItemNetwork;
        /**
         * Ports belonging to the switch
         */
        ports: outputs.organizations.GetSwitchPortsBySwitchItemPort[];
        /**
         * The serial number of the switch.
         */
        serial: string;
    }

    export interface GetSwitchPortsBySwitchItemNetwork {
        /**
         * The ID of the network.
         */
        id: string;
        /**
         * The name of the network.
         */
        name: string;
    }

    export interface GetSwitchPortsBySwitchItemPort {
        /**
         * The type of the access policy of the switch port. Only applicable to access ports. Can be one of 'Open', 'Custom access policy', 'MAC allow list' or 'Sticky MAC allow list'.
         */
        accessPolicyType: string;
        /**
         * The VLANs allowed on the switch port. Only applicable to trunk ports.
         */
        allowedVlans: string;
        /**
         * The status of the switch port.
         */
        enabled: boolean;
        /**
         * The link speed for the switch port.
         */
        linkNegotiation: string;
        /**
         * The name of the switch port.
         */
        name: string;
        /**
         * The PoE status of the switch port.
         */
        poeEnabled: boolean;
        /**
         * The identifier of the switch port.
         */
        portId: string;
        /**
         * The rapid spanning tree protocol status.
         */
        rstpEnabled: boolean;
        /**
         * The maximum number of MAC addresses for sticky MAC allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
         */
        stickyMacAllowListLimit: number;
        /**
         * The initial list of MAC addresses for sticky Mac allow list. Only applicable when 'accessPolicyType' is 'Sticky MAC allow list'.
         */
        stickyMacAllowLists: string[];
        /**
         * The state of the STP guard ('disabled', 'root guard', 'bpdu guard' or 'loop guard').
         */
        stpGuard: string;
        /**
         * The list of tags of the switch port.
         */
        tags: string[];
        /**
         * The type of the switch port ('trunk' or 'access').
         */
        type: string;
        /**
         * The VLAN of the switch port. For a trunk port, this is the native VLAN. A null value will clear the value set for trunk ports.
         */
        vlan: number;
        /**
         * The voice VLAN of the switch port. Only applicable to access ports.
         */
        voiceVlan: number;
    }

    export interface GetUplinksStatusesItem {
        /**
         * Device High Availability Capabilities
         */
        highAvailability: outputs.organizations.GetUplinksStatusesItemHighAvailability;
        /**
         * Last reported time for the device
         */
        lastReportedAt: string;
        /**
         * The uplink model
         */
        model: string;
        /**
         * Network identifier
         */
        networkId: string;
        /**
         * The uplink serial
         */
        serial: string;
        /**
         * Uplinks
         */
        uplinks: outputs.organizations.GetUplinksStatusesItemUplink[];
    }

    export interface GetUplinksStatusesItemHighAvailability {
        /**
         * Indicates whether High Availability is enabled for the device. For devices that do not support HA, this will be 'false'
         */
        enabled: boolean;
        /**
         * The HA role of the device on the network. For devices that do not support HA, this will be 'primary'
         */
        role: string;
    }

    export interface GetUplinksStatusesItemUplink {
        /**
         * Access Point Name
         */
        apn: string;
        /**
         * Connection Type
         */
        connectionType: string;
        /**
         * Primary DNS IP
         */
        dns1: string;
        /**
         * Secondary DNS IP
         */
        dns2: string;
        /**
         * Gateway IP
         */
        gateway: string;
        /**
         * Integrated Circuit Card Identification Number
         */
        iccid: string;
        /**
         * Uplink interface
         */
        interface: string;
        /**
         * Uplink IP
         */
        ip: string;
        /**
         * The way in which the IP is assigned
         */
        ipAssignedBy: string;
        /**
         * Primary DNS IP
         */
        primaryDns: string;
        /**
         * Network Provider
         */
        provider: string;
        /**
         * Public IP
         */
        publicIp: string;
        /**
         * Secondary DNS IP
         */
        secondaryDns: string;
        /**
         * Tower Signal Status
         */
        signalStat: outputs.organizations.GetUplinksStatusesItemUplinkSignalStat;
        /**
         * Signal Type
         */
        signalType: string;
        /**
         * Uplink status
         */
        status: string;
    }

    export interface GetUplinksStatusesItemUplinkSignalStat {
        /**
         * Reference Signal Received Power
         */
        rsrp: string;
        /**
         * Reference Signal Received Quality
         */
        rsrq: string;
    }

    export interface GetWebhooksCallbacksStatusesItem {
        /**
         * The ID of the callback
         */
        callbackId: string;
        /**
         * Information around who initiated the callback
         */
        createdBy: outputs.organizations.GetWebhooksCallbacksStatusesItemCreatedBy;
        /**
         * The errors returned by the callback
         */
        errors: string[];
        /**
         * The status of the callback
         */
        status: string;
        /**
         * The webhook receiver used by the callback to send results
         */
        webhook: outputs.organizations.GetWebhooksCallbacksStatusesItemWebhook;
    }

    export interface GetWebhooksCallbacksStatusesItemCreatedBy {
        /**
         * The ID of the user who initiated the callback
         */
        adminId: string;
    }

    export interface GetWebhooksCallbacksStatusesItemWebhook {
        /**
         * The webhook receiver used for the callback webhook
         */
        httpServer: outputs.organizations.GetWebhooksCallbacksStatusesItemWebhookHttpServer;
        /**
         * The payload template of the webhook used for the callback
         */
        payloadTemplate: outputs.organizations.GetWebhooksCallbacksStatusesItemWebhookPayloadTemplate;
        /**
         * The timestamp the callback was sent to the webhook receiver
         */
        sentAt: string;
        /**
         * The webhook receiver URL where the callback will be sent
         */
        url: string;
    }

    export interface GetWebhooksCallbacksStatusesItemWebhookHttpServer {
        /**
         * The webhook receiver ID that will receive information
         */
        id: string;
    }

    export interface GetWebhooksCallbacksStatusesItemWebhookPayloadTemplate {
        /**
         * The ID of the payload template
         */
        id: string;
    }

    export interface GetWebhooksLogsItem {
        /**
         * Type of alert that the webhook is delivering
         */
        alertType: string;
        /**
         * When the webhook log was created, in ISO8601 format
         */
        loggedAt: string;
        /**
         * Network ID for the webhook log
         */
        networkId: string;
        /**
         * ID for the webhook log's organization
         */
        organizationId: string;
        /**
         * Response code from the webhook
         */
        responseCode: number;
        /**
         * Duration of the response, in milliseconds
         */
        responseDuration: number;
        /**
         * When the webhook was sent, in ISO8601 format
         */
        sentAt: string;
        /**
         * URL where the webhook was sent
         */
        url: string;
    }

    export interface GetWirelessDevicesChannelUtilizationByDeviceItem {
        /**
         * Channel utilization broken down by band.
         */
        byBands: outputs.organizations.GetWirelessDevicesChannelUtilizationByDeviceItemByBand[];
        /**
         * The MAC address of the device.
         */
        mac: string;
        /**
         * Network for the given utilization metrics.
         */
        network: outputs.organizations.GetWirelessDevicesChannelUtilizationByDeviceItemNetwork;
        /**
         * The serial number for the device.
         */
        serial: string;
    }

    export interface GetWirelessDevicesChannelUtilizationByDeviceItemByBand {
        /**
         * The band for the given metrics.
         */
        band: string;
        /**
         * An object containing non-wifi utilization.
         */
        nonWifi: outputs.organizations.GetWirelessDevicesChannelUtilizationByDeviceItemByBandNonWifi;
        /**
         * An object containing total channel utilization.
         */
        total: outputs.organizations.GetWirelessDevicesChannelUtilizationByDeviceItemByBandTotal;
        /**
         * An object containing wifi utilization.
         */
        wifi: outputs.organizations.GetWirelessDevicesChannelUtilizationByDeviceItemByBandWifi;
    }

    export interface GetWirelessDevicesChannelUtilizationByDeviceItemByBandNonWifi {
        /**
         * Percentage of non-wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationByDeviceItemByBandTotal {
        /**
         * Percentage of total channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationByDeviceItemByBandWifi {
        /**
         * Percentage of wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationByDeviceItemNetwork {
        /**
         * Network ID of the given utilization metrics.
         */
        id: string;
    }

    export interface GetWirelessDevicesChannelUtilizationByNetworkItem {
        /**
         * Channel utilization broken down by band.
         */
        byBands: outputs.organizations.GetWirelessDevicesChannelUtilizationByNetworkItemByBand[];
        /**
         * Network for the given utilization metrics.
         */
        network: outputs.organizations.GetWirelessDevicesChannelUtilizationByNetworkItemNetwork;
    }

    export interface GetWirelessDevicesChannelUtilizationByNetworkItemByBand {
        /**
         * The band for the given metrics.
         */
        band: string;
        /**
         * An object containing non-wifi utilization.
         */
        nonWifi: outputs.organizations.GetWirelessDevicesChannelUtilizationByNetworkItemByBandNonWifi;
        /**
         * An object containing total channel utilization.
         */
        total: outputs.organizations.GetWirelessDevicesChannelUtilizationByNetworkItemByBandTotal;
        /**
         * An object containing wifi utilization.
         */
        wifi: outputs.organizations.GetWirelessDevicesChannelUtilizationByNetworkItemByBandWifi;
    }

    export interface GetWirelessDevicesChannelUtilizationByNetworkItemByBandNonWifi {
        /**
         * Percentage of non-wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationByNetworkItemByBandTotal {
        /**
         * Percentage of total channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationByNetworkItemByBandWifi {
        /**
         * Percentage of wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationByNetworkItemNetwork {
        /**
         * Network ID of the given utilization metrics.
         */
        id: string;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItem {
        /**
         * Channel utilization broken down by band.
         */
        byBands: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBand[];
        /**
         * The end time of the channel utilization interval.
         */
        endTs: string;
        /**
         * The MAC address of the device.
         */
        mac: string;
        /**
         * Network for the given utilization metrics.
         */
        network: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemNetwork;
        /**
         * The serial number for the device.
         */
        serial: string;
        /**
         * The start time of the channel utilization interval.
         */
        startTs: string;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBand {
        /**
         * The band for the given metrics.
         */
        band: string;
        /**
         * An object containing non-wifi utilization.
         */
        nonWifi: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBandNonWifi;
        /**
         * An object containing total channel utilization.
         */
        total: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBandTotal;
        /**
         * An object containing wifi utilization.
         */
        wifi: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBandWifi;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBandNonWifi {
        /**
         * Percentage of non-wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBandTotal {
        /**
         * Percentage of total channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemByBandWifi {
        /**
         * Percentage of wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByDeviceByIntervalItemNetwork {
        /**
         * Network ID of the given utilization metrics.
         */
        id: string;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItem {
        /**
         * Channel utilization broken down by band.
         */
        byBands: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBand[];
        /**
         * The end time of the channel utilization interval.
         */
        endTs: string;
        /**
         * Network for the given utilization metrics.
         */
        network: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemNetwork;
        /**
         * The start time of the channel utilization interval.
         */
        startTs: string;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBand {
        /**
         * The band for the given metrics.
         */
        band: string;
        /**
         * An object containing non-wifi utilization.
         */
        nonWifi: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBandNonWifi;
        /**
         * An object containing total channel utilization.
         */
        total: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBandTotal;
        /**
         * An object containing wifi utilization.
         */
        wifi: outputs.organizations.GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBandWifi;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBandNonWifi {
        /**
         * Percentage of non-wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBandTotal {
        /**
         * Percentage of total channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemByBandWifi {
        /**
         * Percentage of wifi channel utiliation for the given band.
         */
        percentage: number;
    }

    export interface GetWirelessDevicesChannelUtilizationHistoryByNetworkByIntervalItemNetwork {
        /**
         * Network ID of the given utilization metrics.
         */
        id: string;
    }

    export interface GetWirelessDevicesEthernetStatusesItem {
        /**
         * Aggregation details object
         */
        aggregation: outputs.organizations.GetWirelessDevicesEthernetStatusesItemAggregation;
        /**
         * The name of the AP
         */
        name: string;
        /**
         * Network details object
         */
        network: outputs.organizations.GetWirelessDevicesEthernetStatusesItemNetwork;
        /**
         * List of port details
         */
        ports: outputs.organizations.GetWirelessDevicesEthernetStatusesItemPort[];
        /**
         * Power details object
         */
        power: outputs.organizations.GetWirelessDevicesEthernetStatusesItemPower;
        /**
         * The serial number of the AP
         */
        serial: string;
    }

    export interface GetWirelessDevicesEthernetStatusesItemAggregation {
        /**
         * Link Aggregation enabled flag
         */
        enabled: boolean;
        /**
         * Link Aggregation speed
         */
        speed: number;
    }

    export interface GetWirelessDevicesEthernetStatusesItemNetwork {
        /**
         * The network ID the AP is associated to
         */
        id: string;
    }

    export interface GetWirelessDevicesEthernetStatusesItemPort {
        /**
         * Link negotiation details object for the port
         */
        linkNegotiation: outputs.organizations.GetWirelessDevicesEthernetStatusesItemPortLinkNegotiation;
        /**
         * Label of the port
         */
        name: string;
        /**
         * PoE details object for the port
         */
        poe: outputs.organizations.GetWirelessDevicesEthernetStatusesItemPortPoe;
    }

    export interface GetWirelessDevicesEthernetStatusesItemPortLinkNegotiation {
        /**
         * The duplex mode of the port. Can be 'full' or 'half'
         */
        duplex: string;
        /**
         * The speed of the port
         */
        speed: number;
    }

    export interface GetWirelessDevicesEthernetStatusesItemPortPoe {
        /**
         * The PoE Standard for the port. Can be '802.3at', '802.3af', '802.3bt', or null
         */
        standard: string;
    }

    export interface GetWirelessDevicesEthernetStatusesItemPower {
        /**
         * AC power details object
         */
        ac: outputs.organizations.GetWirelessDevicesEthernetStatusesItemPowerAc;
        /**
         * The PoE power mode for the AP. Can be 'full' or 'low'
         */
        mode: string;
        /**
         * PoE power details object
         */
        poe: outputs.organizations.GetWirelessDevicesEthernetStatusesItemPowerPoe;
    }

    export interface GetWirelessDevicesEthernetStatusesItemPowerAc {
        /**
         * AC power connected
         */
        isConnected: boolean;
    }

    export interface GetWirelessDevicesEthernetStatusesItemPowerPoe {
        /**
         * PoE power connected
         */
        isConnected: boolean;
    }

    export interface GetWirelessDevicesPacketLossByClientItem {
        /**
         * Client.
         */
        client: outputs.organizations.GetWirelessDevicesPacketLossByClientItemClient;
        /**
         * Packets sent from an AP to a client.
         */
        downstream: outputs.organizations.GetWirelessDevicesPacketLossByClientItemDownstream;
        /**
         * Network.
         */
        network: outputs.organizations.GetWirelessDevicesPacketLossByClientItemNetwork;
        /**
         * Packets sent from a client to an AP.
         */
        upstream: outputs.organizations.GetWirelessDevicesPacketLossByClientItemUpstream;
    }

    export interface GetWirelessDevicesPacketLossByClientItemClient {
        /**
         * Client ID.
         */
        id: string;
        /**
         * MAC address.
         */
        mac: string;
    }

    export interface GetWirelessDevicesPacketLossByClientItemDownstream {
        /**
         * Percentage of lost packets.
         */
        lossPercentage: number;
        /**
         * Total packets sent by an AP that did not reach the client.
         */
        lost: number;
        /**
         * Total packets received by a client.
         */
        total: number;
    }

    export interface GetWirelessDevicesPacketLossByClientItemNetwork {
        /**
         * Network ID.
         */
        id: string;
        /**
         * Name of the network.
         */
        name: string;
    }

    export interface GetWirelessDevicesPacketLossByClientItemUpstream {
        /**
         * Percentage of lost packets.
         */
        lossPercentage: number;
        /**
         * Total packets sent by a client and did not reach the AP.
         */
        lost: number;
        /**
         * Total packets sent by a client to an AP.
         */
        total: number;
    }

    export interface GetWirelessDevicesPacketLossByDeviceItem {
        /**
         * Device.
         */
        device: outputs.organizations.GetWirelessDevicesPacketLossByDeviceItemDevice;
        /**
         * Packets sent from an AP to a client.
         */
        downstream: outputs.organizations.GetWirelessDevicesPacketLossByDeviceItemDownstream;
        /**
         * Network.
         */
        network: outputs.organizations.GetWirelessDevicesPacketLossByDeviceItemNetwork;
        /**
         * Packets sent from a client to an AP.
         */
        upstream: outputs.organizations.GetWirelessDevicesPacketLossByDeviceItemUpstream;
    }

    export interface GetWirelessDevicesPacketLossByDeviceItemDevice {
        /**
         * MAC address
         */
        mac: string;
        /**
         * Name
         */
        name: string;
        /**
         * Serial Number
         */
        serial: string;
    }

    export interface GetWirelessDevicesPacketLossByDeviceItemDownstream {
        /**
         * Percentage of lost packets.
         */
        lossPercentage: number;
        /**
         * Total packets sent by an AP that did not reach the client.
         */
        lost: number;
        /**
         * Total packets received by a client.
         */
        total: number;
    }

    export interface GetWirelessDevicesPacketLossByDeviceItemNetwork {
        /**
         * Network ID.
         */
        id: string;
        /**
         * Name of the network.
         */
        name: string;
    }

    export interface GetWirelessDevicesPacketLossByDeviceItemUpstream {
        /**
         * Percentage of lost packets.
         */
        lossPercentage: number;
        /**
         * Total packets sent by a client and did not reach the AP.
         */
        lost: number;
        /**
         * Total packets sent by a client to an AP.
         */
        total: number;
    }

    export interface GetWirelessDevicesPacketLossByNetworkItem {
        /**
         * Packets sent from an AP to a client.
         */
        downstream: outputs.organizations.GetWirelessDevicesPacketLossByNetworkItemDownstream;
        /**
         * Network.
         */
        network: outputs.organizations.GetWirelessDevicesPacketLossByNetworkItemNetwork;
        /**
         * Packets sent from a client to an AP.
         */
        upstream: outputs.organizations.GetWirelessDevicesPacketLossByNetworkItemUpstream;
    }

    export interface GetWirelessDevicesPacketLossByNetworkItemDownstream {
        /**
         * Percentage of lost packets.
         */
        lossPercentage: number;
        /**
         * Total packets sent by an AP that did not reach the client.
         */
        lost: number;
        /**
         * Total packets received by a client.
         */
        total: number;
    }

    export interface GetWirelessDevicesPacketLossByNetworkItemNetwork {
        /**
         * Network ID.
         */
        id: string;
        /**
         * Name of the network.
         */
        name: string;
    }

    export interface GetWirelessDevicesPacketLossByNetworkItemUpstream {
        /**
         * Percentage of lost packets.
         */
        lossPercentage: number;
        /**
         * Total packets sent by a client and did not reach the AP.
         */
        lost: number;
        /**
         * Total packets sent by a client to an AP.
         */
        total: number;
    }

    export interface InventoryClaimItem {
        /**
         * The licenses claimed
         */
        licenses: outputs.organizations.InventoryClaimItemLicense[];
        /**
         * The numbers of the orders claimed
         */
        orders: string[];
        /**
         * The serials of the devices claimed
         */
        serials: string[];
    }

    export interface InventoryClaimItemLicense {
        /**
         * The key of the license
         */
        key: string;
        /**
         * The mode of the license
         */
        mode: string;
    }

    export interface InventoryClaimParameters {
        /**
         * The licenses that should be claimed
         */
        licenses: outputs.organizations.InventoryClaimParametersLicense[];
        /**
         * The numbers of the orders that should be claimed
         */
        orders: string[];
        /**
         * The serials of the devices that should be claimed
         */
        serials: string[];
    }

    export interface InventoryClaimParametersLicense {
        /**
         * The key of the license
         */
        key: string;
        /**
         * Co-term licensing only: either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. Does not apply to organizations using per-device licensing model.
         */
        mode: string;
    }

    export interface InventoryOnboardingCloudMonitoringExportEventsParameters {
        /**
         * The type of log event this is recording, e.g. download or opening a banner
         */
        logEvent: string;
        /**
         * Used to describe if this event was the result of a redirect. E.g. a query param if an info banner is being used
         */
        request: string;
        /**
         * The name of the onboarding distro being downloaded
         */
        targetOs: string;
        /**
         * A JavaScript UTC datetime stamp for when the even occurred
         */
        timestamp: number;
    }

    export interface InventoryOnboardingCloudMonitoringImportsParameters {
        /**
         * A set of device imports to commit
         */
        devices: outputs.organizations.InventoryOnboardingCloudMonitoringImportsParametersDevice[];
        items: outputs.organizations.InventoryOnboardingCloudMonitoringImportsParametersItem[];
    }

    export interface InventoryOnboardingCloudMonitoringImportsParametersDevice {
        /**
         * Import ID from the Import operation
         */
        deviceId: string;
        /**
         * Network Id
         */
        networkId: string;
        /**
         * Device UDI certificate
         */
        udi: string;
    }

    export interface InventoryOnboardingCloudMonitoringImportsParametersItem {
        /**
         * Array of ResponseOrganizationsCreateOrganizationInventoryOnboardingCloudMonitoringImport
         */
        items: outputs.organizations.InventoryOnboardingCloudMonitoringImportsParametersItemItem[];
    }

    export interface InventoryOnboardingCloudMonitoringImportsParametersItemItem {
        /**
         * Unique id associated with the import of the device
         */
        importId: string;
        /**
         * Response method
         */
        message: string;
        /**
         * Cloud monitor import status
         */
        status: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItem {
        /**
         * Params used in order to connect to the device
         */
        configParams: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParams;
        /**
         * Import ID from the Import operation
         */
        deviceId: string;
        /**
         * Message related to whether or not the device was found and can be imported.
         */
        message: string;
        /**
         * The import status of the device
         */
        status: string;
        /**
         * Device UDI certificate
         */
        udi: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParams {
        /**
         * Static IP Address used to connect to the device
         */
        cloudStaticIp: string;
        /**
         * Configuration options used to connect to the device
         */
        tunnel: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnel;
        /**
         * User credentials used to connect to the device
         */
        user: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUser;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnel {
        /**
         * SSH tunnel URL used to connect to the device
         */
        host: string;
        mode: string;
        /**
         * The name of the tunnel we are attempting to connect to
         */
        name: string;
        /**
         * The port used for the ssh tunnel.
         */
        port: string;
        /**
         * Root certificate information
         */
        rootCertificate: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificate;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsTunnelRootCertificate {
        /**
         * Public certificate value
         */
        content: string;
        /**
         * The name of the server protected by the certificate
         */
        name: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUser {
        /**
         * The public key for the registered user
         */
        publicKey: string;
        /**
         * Stores the user secret hash
         */
        secret: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecret;
        /**
         * The username added to Catalyst device
         */
        username: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareItemConfigParamsUserSecret {
        /**
         * The hashed secret
         */
        hash: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParameters {
        /**
         * A set of devices to import (or update)
         */
        devices: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDevice[];
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDevice {
        /**
         * Device SUDI certificate
         */
        sudi: string;
        /**
         * TLS Related Parameters
         */
        tunnel: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnel;
        /**
         * User parameters
         */
        user: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceUser;
        /**
         * VTY Related Parameters
         */
        vty: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVty;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceTunnel {
        /**
         * Name of the configured TLS certificate
         */
        certificateName: string;
        /**
         * Number of the vlan expected to be used to connect to the cloud
         */
        localInterface: number;
        /**
         * Number of the configured Loopback Interface used for TLS overlay
         */
        loopbackNumber: number;
        /**
         * Name of the configured TLS tunnel
         */
        name: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceUser {
        /**
         * The name of the device user for Meraki monitoring
         */
        username: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVty {
        /**
         * AccessList details
         */
        accessList: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessList;
        /**
         * VTY AAA authentication
         */
        authentication: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthentication;
        /**
         * VTY AAA authorization
         */
        authorization: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorization;
        /**
         * Ending line VTY number
         */
        endLineNumber: number;
        /**
         * SSH rotary number
         */
        rotaryNumber: number;
        /**
         * Starting line VTY number
         */
        startLineNumber: number;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessList {
        /**
         * VTY in ACL
         */
        vtyIn: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyIn;
        /**
         * VTY out ACL
         */
        vtyOut: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOut;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyIn {
        /**
         * Name
         */
        name: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAccessListVtyOut {
        /**
         * Name
         */
        name: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthentication {
        /**
         * Group Details
         */
        group: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroup;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthenticationGroup {
        /**
         * Group Name
         */
        name: string;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorization {
        /**
         * Group Details
         */
        group: outputs.organizations.InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroup;
    }

    export interface InventoryOnboardingCloudMonitoringPrepareParametersDeviceVtyAuthorizationGroup {
        /**
         * Group Name
         */
        name: string;
    }

    export interface InventoryReleaseItem {
        /**
         * Serials of the devices that were released
         */
        serials: string[];
    }

    export interface InventoryReleaseParameters {
        /**
         * Serials of the devices that should be released
         */
        serials: string[];
    }

    export interface LicensesAssignSeatsItem {
        /**
         * Resulting licenses from the move
         */
        resultingLicenses: outputs.organizations.LicensesAssignSeatsItemResultingLicense[];
    }

    export interface LicensesAssignSeatsItemResultingLicense {
        /**
         * The date the license started burning
         */
        activationDate: string;
        /**
         * The date the license was claimed into the organization
         */
        claimDate: string;
        /**
         * Serial number of the device the license is assigned to
         */
        deviceSerial: string;
        /**
         * The duration of the individual license
         */
        durationInDays: number;
        /**
         * The date the license will expire
         */
        expirationDate: string;
        /**
         * The id of the head license this license is queued behind. If there is no head license, it returns nil.
         */
        headLicenseId: string;
        /**
         * License ID
         */
        id: string;
        /**
         * License key
         */
        licenseKey: string;
        /**
         * License type
         */
        licenseType: string;
        /**
         * ID of the network the license is assigned to
         */
        networkId: string;
        /**
         * Order number
         */
        orderNumber: string;
        /**
         * DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
         */
        permanentlyQueuedLicenses: outputs.organizations.LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicense[];
        /**
         * The number of seats of the license. Only applicable to SM licenses.
         */
        seatCount: number;
        /**
         * The state of the license. All queued licenses have a status of *recentlyQueued*.
         */
        state: string;
        /**
         * The duration of the license plus all permanently queued licenses associated with it
         */
        totalDurationInDays: number;
    }

    export interface LicensesAssignSeatsItemResultingLicensePermanentlyQueuedLicense {
        /**
         * The duration of the individual license
         */
        durationInDays: number;
        /**
         * Permanently queued license ID
         */
        id: string;
        /**
         * License key
         */
        licenseKey: string;
        /**
         * License type
         */
        licenseType: string;
        /**
         * Order number
         */
        orderNumber: string;
    }

    export interface LicensesAssignSeatsParameters {
        /**
         * The ID of the SM license to assign seats from
         */
        licenseId: string;
        /**
         * The ID of the SM network to assign the seats to
         */
        networkId: string;
        /**
         * The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license
         */
        seatCount: number;
    }

    export interface LicensesMoveItem {
        /**
         * The ID of the organization to move the licenses to
         */
        destOrganizationId: string;
        /**
         * A list of IDs of licenses to move to the new organization
         */
        licenseIds: string[];
    }

    export interface LicensesMoveParameters {
        /**
         * The ID of the organization to move the licenses to
         */
        destOrganizationId: string;
        /**
         * A list of IDs of licenses to move to the new organization
         */
        licenseIds: string[];
    }

    export interface LicensesMoveSeatsItem {
        /**
         * The ID of the organization to move the SM seats to
         */
        destOrganizationId: string;
        /**
         * The ID of the SM license to move the seats from
         */
        licenseId: string;
        /**
         * The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
         */
        seatCount: number;
    }

    export interface LicensesMoveSeatsParameters {
        /**
         * The ID of the organization to move the SM seats to
         */
        destOrganizationId: string;
        /**
         * The ID of the SM license to move the seats from
         */
        licenseId: string;
        /**
         * The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license
         */
        seatCount: number;
    }

    export interface LicensesPermanentlyQueuedLicense {
        /**
         * The duration of the individual license
         */
        durationInDays: number;
        /**
         * Permanently queued license ID
         */
        id: string;
        /**
         * License key
         */
        licenseKey: string;
        /**
         * License type
         */
        licenseType: string;
        /**
         * Order number
         */
        orderNumber: string;
    }

    export interface LicensesRenewSeatsItem {
        /**
         * Resulting licenses from the move
         */
        resultingLicenses: outputs.organizations.LicensesRenewSeatsItemResultingLicense[];
    }

    export interface LicensesRenewSeatsItemResultingLicense {
        /**
         * The date the license started burning
         */
        activationDate: string;
        /**
         * The date the license was claimed into the organization
         */
        claimDate: string;
        /**
         * Serial number of the device the license is assigned to
         */
        deviceSerial: string;
        /**
         * The duration of the individual license
         */
        durationInDays: number;
        /**
         * The date the license will expire
         */
        expirationDate: string;
        /**
         * The id of the head license this license is queued behind. If there is no head license, it returns nil.
         */
        headLicenseId: string;
        /**
         * License ID
         */
        id: string;
        /**
         * License key
         */
        licenseKey: string;
        /**
         * License type
         */
        licenseType: string;
        /**
         * ID of the network the license is assigned to
         */
        networkId: string;
        /**
         * Order number
         */
        orderNumber: string;
        /**
         * DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
         */
        permanentlyQueuedLicenses: outputs.organizations.LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicense[];
        /**
         * The number of seats of the license. Only applicable to SM licenses.
         */
        seatCount: number;
        /**
         * The state of the license. All queued licenses have a status of *recentlyQueued*.
         */
        state: string;
        /**
         * The duration of the license plus all permanently queued licenses associated with it
         */
        totalDurationInDays: number;
    }

    export interface LicensesRenewSeatsItemResultingLicensePermanentlyQueuedLicense {
        /**
         * The duration of the individual license
         */
        durationInDays: number;
        /**
         * Permanently queued license ID
         */
        id: string;
        /**
         * License key
         */
        licenseKey: string;
        /**
         * License type
         */
        licenseType: string;
        /**
         * Order number
         */
        orderNumber: string;
    }

    export interface LicensesRenewSeatsParameters {
        /**
         * The ID of the SM license to renew. This license must already be assigned to an SM network
         */
        licenseIdToRenew: string;
        /**
         * The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'
         */
        unusedLicenseId: string;
    }

    export interface LicensingCotermLicensesMoveItem {
        /**
         * Newly moved licenses created in the destination organization of the license move operation
         */
        movedLicenses: outputs.organizations.LicensingCotermLicensesMoveItemMovedLicense[];
        /**
         * Remainder licenses created in the source organization as a result of moving a subset of the counts of a license
         */
        remainderLicenses: outputs.organizations.LicensingCotermLicensesMoveItemRemainderLicense[];
    }

    export interface LicensingCotermLicensesMoveItemMovedLicense {
        /**
         * When the license was claimed into the organization
         */
        claimedAt: string;
        /**
         * The counts of the license by model type
         */
        counts: outputs.organizations.LicensingCotermLicensesMoveItemMovedLicenseCount[];
        /**
         * The duration (term length) of the license, measured in days
         */
        duration: number;
        /**
         * The editions of the license for each relevant product type
         */
        editions: outputs.organizations.LicensingCotermLicensesMoveItemMovedLicenseEdition[];
        /**
         * Flag to indicate if the license is expired
         */
        expired: boolean;
        /**
         * Flag to indicated that the license is invalidated
         */
        invalidated: boolean;
        /**
         * When the license was invalidated. Will be null for active licenses
         */
        invalidatedAt: string;
        /**
         * The key of the license
         */
        key: string;
        /**
         * The operation mode of the license when it was claimed
         */
        mode: string;
        /**
         * The ID of the organization that the license is claimed in
         */
        organizationId: string;
        /**
         * When the license's term began (approximately the date when the license was created)
         */
        startedAt: string;
    }

    export interface LicensingCotermLicensesMoveItemMovedLicenseCount {
        /**
         * The number of counts the license contains of this model
         */
        count: number;
        /**
         * The license model type
         */
        model: string;
    }

    export interface LicensingCotermLicensesMoveItemMovedLicenseEdition {
        /**
         * The name of the license edition
         */
        edition: string;
        /**
         * The product type of the license edition
         */
        productType: string;
    }

    export interface LicensingCotermLicensesMoveItemRemainderLicense {
        /**
         * When the license was claimed into the organization
         */
        claimedAt: string;
        /**
         * The counts of the license by model type
         */
        counts: outputs.organizations.LicensingCotermLicensesMoveItemRemainderLicenseCount[];
        /**
         * The duration (term length) of the license, measured in days
         */
        duration: number;
        /**
         * The editions of the license for each relevant product type
         */
        editions: outputs.organizations.LicensingCotermLicensesMoveItemRemainderLicenseEdition[];
        /**
         * Flag to indicate if the license is expired
         */
        expired: boolean;
        /**
         * Flag to indicated that the license is invalidated
         */
        invalidated: boolean;
        /**
         * When the license was invalidated. Will be null for active licenses
         */
        invalidatedAt: string;
        /**
         * The key of the license
         */
        key: string;
        /**
         * The operation mode of the license when it was claimed
         */
        mode: string;
        /**
         * The ID of the organization that the license is claimed in
         */
        organizationId: string;
        /**
         * When the license's term began (approximately the date when the license was created)
         */
        startedAt: string;
    }

    export interface LicensingCotermLicensesMoveItemRemainderLicenseCount {
        /**
         * The number of counts the license contains of this model
         */
        count: number;
        /**
         * The license model type
         */
        model: string;
    }

    export interface LicensingCotermLicensesMoveItemRemainderLicenseEdition {
        /**
         * The name of the license edition
         */
        edition: string;
        /**
         * The product type of the license edition
         */
        productType: string;
    }

    export interface LicensingCotermLicensesMoveParameters {
        /**
         * Destination data for the license move
         */
        destination: outputs.organizations.LicensingCotermLicensesMoveParametersDestination;
        /**
         * The list of licenses to move
         */
        licenses: outputs.organizations.LicensingCotermLicensesMoveParametersLicense[];
    }

    export interface LicensingCotermLicensesMoveParametersDestination {
        /**
         * The claim mode of the moved license
         */
        mode: string;
        /**
         * The organization to move the license to
         */
        organizationId: string;
    }

    export interface LicensingCotermLicensesMoveParametersLicense {
        /**
         * The counts to move from the license by model type
         */
        counts: outputs.organizations.LicensingCotermLicensesMoveParametersLicenseCount[];
        /**
         * The license key to move counts from
         */
        key: string;
    }

    export interface LicensingCotermLicensesMoveParametersLicenseCount {
        /**
         * The number of counts to move
         */
        count: number;
        /**
         * The license model type to move counts of
         */
        model: string;
    }

    export interface LoginSecurityApiAuthentication {
        /**
         * Details for API-only IP restrictions.
         */
        ipRestrictionsForKeys: outputs.organizations.LoginSecurityApiAuthenticationIpRestrictionsForKeys;
    }

    export interface LoginSecurityApiAuthenticationIpRestrictionsForKeys {
        /**
         * Boolean indicating whether the organization will restrict API key (not Dashboard GUI) usage to a specific list of IP addresses or CIDR ranges.
         */
        enabled: boolean;
        /**
         * List of acceptable IP ranges. Entries can be single IP addresses, IP address ranges, and CIDR subnets.
         */
        ranges: string[];
    }

    export interface NetworksCombineItem {
        /**
         * Network after the combination
         */
        resultingNetwork: outputs.organizations.NetworksCombineItemResultingNetwork;
    }

    export interface NetworksCombineItemResultingNetwork {
        /**
         * Enrollment string for the network
         */
        enrollmentString: string;
        /**
         * Network ID
         */
        id: string;
        /**
         * If the network is bound to a config template
         */
        isBoundToConfigTemplate: boolean;
        /**
         * Network name
         */
        name: string;
        /**
         * Notes for the network
         */
        notes: string;
        /**
         * Organization ID
         */
        organizationId: string;
        /**
         * List of the product types that the network supports
         */
        productTypes: string[];
        /**
         * Network tags
         */
        tags: string[];
        /**
         * Timezone of the network
         */
        timeZone: string;
        /**
         * URL to the network Dashboard UI
         */
        url: string;
    }

    export interface NetworksCombineParameters {
        /**
         * A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.
         */
        enrollmentString: string;
        /**
         * The name of the combined network
         */
        name: string;
        /**
         * A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network
         */
        networkIds: string[];
    }

    export interface SamlRolesCamera {
        /**
         * Camera access ability
         */
        access: string;
        /**
         * Whether or not SAML administrator has org-wide access
         */
        orgWide: boolean;
    }

    export interface SamlRolesNetwork {
        /**
         * The privilege of the SAML administrator on the network
         */
        access: string;
        /**
         * The network ID
         */
        id: string;
    }

    export interface SamlRolesTag {
        /**
         * The privilege of the SAML administrator on the tag
         */
        access: string;
        /**
         * The name of the tag
         */
        tag: string;
    }

    export interface SmSentryPoliciesAssignmentsItem {
        /**
         * Sentry Group Policies for the Organization keyed by Network Id
         */
        items: outputs.organizations.SmSentryPoliciesAssignmentsItemItem[];
    }

    export interface SmSentryPoliciesAssignmentsItemItem {
        /**
         * The Id of the Network
         */
        networkId: string;
        /**
         * Array of Sentry Group Policies for the Network
         */
        policies: outputs.organizations.SmSentryPoliciesAssignmentsItemItemPolicy[];
    }

    export interface SmSentryPoliciesAssignmentsItemItemPolicy {
        /**
         * The creation time of the Sentry Policy
         */
        createdAt: string;
        /**
         * The number of the Group Policy
         */
        groupNumber: string;
        /**
         * The Id of the Group Policy. This is associated with the network specified by the networkId.
         */
        groupPolicyId: string;
        /**
         * The last update time of the Sentry Policy
         */
        lastUpdatedAt: string;
        /**
         * The Id of the Network the Sentry Policy is associated with. In a locale, this should be the Wireless Group if present, otherwise the Wired Group.
         */
        networkId: string;
        /**
         * The Id of the Sentry Policy
         */
        policyId: string;
        /**
         * The priority of the Sentry Policy
         */
        priority: string;
        /**
         * The scope of the Sentry Policy
         */
        scope: string;
        /**
         * The Id of the Systems Manager Network the Sentry Policy is assigned to
         */
        smNetworkId: string;
        /**
         * The tags of the Sentry Policy
         */
        tags: string[];
    }

    export interface SmSentryPoliciesAssignmentsParameters {
        /**
         * Sentry Group Policies for the Organization keyed by Network Id
         */
        items: outputs.organizations.SmSentryPoliciesAssignmentsParametersItem[];
    }

    export interface SmSentryPoliciesAssignmentsParametersItem {
        /**
         * The Id of the Network
         */
        networkId: string;
        /**
         * Array of Sentry Group Policies for the Network
         */
        policies: outputs.organizations.SmSentryPoliciesAssignmentsParametersItemPolicy[];
    }

    export interface SmSentryPoliciesAssignmentsParametersItemPolicy {
        /**
         * The Group Policy Id
         */
        groupPolicyId: string;
        /**
         * The Sentry Policy Id, if updating an existing Sentry Policy
         */
        policyId: string;
        /**
         * The scope of the Sentry Policy
         */
        scope: string;
        /**
         * The Id of the Systems Manager Network
         */
        smNetworkId: string;
        /**
         * The tags for the Sentry Policy
         */
        tags: string[];
    }

    export interface SwitchDevicesCloneParameters {
        /**
         * Serial number of the source switch (must be on a network not bound to a template)
         */
        sourceSerial: string;
        /**
         * Array of serial numbers of one or more target switches (must be on a network not bound to a template)
         */
        targetSerials: string[];
    }

}
