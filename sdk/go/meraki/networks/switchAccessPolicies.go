// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-meraki/sdk/go/meraki/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-meraki/sdk/go/meraki/networks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := networks.NewSwitchAccessPolicies(ctx, "example", &networks.SwitchAccessPoliciesArgs{
//				AccessPolicyType: pulumi.String("Hybrid authentication"),
//				Dot1x: &networks.SwitchAccessPoliciesDot1xArgs{
//					ControlDirection: pulumi.String("inbound"),
//				},
//				GuestPortBouncing:   pulumi.Bool(false),
//				GuestVlanId:         pulumi.Int(100),
//				HostMode:            pulumi.String("Single-Host"),
//				IncreaseAccessSpeed: pulumi.Bool(false),
//				Name:                pulumi.String("Access policy #1"),
//				NetworkId:           pulumi.String("string"),
//				Radius: &networks.SwitchAccessPoliciesRadiusArgs{
//					CriticalAuth: &networks.SwitchAccessPoliciesRadiusCriticalAuthArgs{
//						DataVlanId:        pulumi.Int(100),
//						SuspendPortBounce: pulumi.Bool(true),
//						VoiceVlanId:       pulumi.Int(100),
//					},
//					FailedAuthVlanId:         pulumi.Int(100),
//					ReAuthenticationInterval: pulumi.Int(120),
//				},
//				RadiusAccountingEnabled: pulumi.Bool(true),
//				RadiusAccountingServers: networks.SwitchAccessPoliciesRadiusAccountingServerArray{
//					&networks.SwitchAccessPoliciesRadiusAccountingServerArgs{
//						Host:   pulumi.String("1.2.3.4"),
//						Port:   pulumi.Int(22),
//						Secret: pulumi.String("secret"),
//					},
//				},
//				RadiusCoaSupportEnabled: pulumi.Bool(false),
//				RadiusGroupAttribute:    pulumi.String("11"),
//				RadiusServers: networks.SwitchAccessPoliciesRadiusServerArray{
//					&networks.SwitchAccessPoliciesRadiusServerArgs{
//						Host:   pulumi.String("1.2.3.4"),
//						Port:   pulumi.Int(22),
//						Secret: pulumi.String("secret"),
//					},
//				},
//				RadiusTestingEnabled:           pulumi.Bool(false),
//				UrlRedirectWalledGardenEnabled: pulumi.Bool(true),
//				UrlRedirectWalledGardenRanges: pulumi.StringArray{
//					pulumi.String("192.168.1.0/24"),
//				},
//				VoiceVlanClients: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("merakiNetworksSwitchAccessPoliciesExample", example)
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import meraki:networks/switchAccessPolicies:SwitchAccessPolicies example "access_policy_number,network_id"
// ```
type SwitchAccessPolicies struct {
	pulumi.CustomResourceState

	// accessPolicyNumber path parameter. Access policy number
	AccessPolicyNumber pulumi.StringOutput `pulumi:"accessPolicyNumber"`
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType pulumi.StringOutput `pulumi:"accessPolicyType"`
	// Counts associated with the access policy
	Counts SwitchAccessPoliciesCountsOutput `pulumi:"counts"`
	// 802.1x Settings
	Dot1x SwitchAccessPoliciesDot1xOutput `pulumi:"dot1x"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing pulumi.BoolOutput `pulumi:"guestPortBouncing"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanId pulumi.IntPtrOutput `pulumi:"guestVlanId"`
	// Choose the Host Mode for the access policy.
	HostMode pulumi.StringOutput `pulumi:"hostMode"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed pulumi.BoolOutput `pulumi:"increaseAccessSpeed"`
	// Name of the access policy
	Name pulumi.StringOutput `pulumi:"name"`
	// networkId path parameter. Network ID
	NetworkId pulumi.StringOutput `pulumi:"networkId"`
	// Object for RADIUS Settings
	Radius SwitchAccessPoliciesRadiusOutput `pulumi:"radius"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled pulumi.BoolOutput `pulumi:"radiusAccountingEnabled"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers SwitchAccessPoliciesRadiusAccountingServerArrayOutput `pulumi:"radiusAccountingServers"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServersResponses SwitchAccessPoliciesRadiusAccountingServersResponseArrayOutput `pulumi:"radiusAccountingServersResponses"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled pulumi.BoolOutput `pulumi:"radiusCoaSupportEnabled"`
	// Acceptable values are *""* for None, or *"11"* for Group Policies ACL
	RadiusGroupAttribute pulumi.StringOutput `pulumi:"radiusGroupAttribute"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers SwitchAccessPoliciesRadiusServerArrayOutput `pulumi:"radiusServers"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServersResponses SwitchAccessPoliciesRadiusServersResponseArrayOutput `pulumi:"radiusServersResponses"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled pulumi.BoolOutput `pulumi:"radiusTestingEnabled"`
	// Enable to restrict access for clients to a responseObjectific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenEnabled pulumi.BoolOutput `pulumi:"urlRedirectWalledGardenEnabled"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenRanges pulumi.StringArrayOutput `pulumi:"urlRedirectWalledGardenRanges"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients pulumi.BoolOutput `pulumi:"voiceVlanClients"`
}

// NewSwitchAccessPolicies registers a new resource with the given unique name, arguments, and options.
func NewSwitchAccessPolicies(ctx *pulumi.Context,
	name string, args *SwitchAccessPoliciesArgs, opts ...pulumi.ResourceOption) (*SwitchAccessPolicies, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.NetworkId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SwitchAccessPolicies
	err := ctx.RegisterResource("meraki:networks/switchAccessPolicies:SwitchAccessPolicies", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSwitchAccessPolicies gets an existing SwitchAccessPolicies resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSwitchAccessPolicies(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SwitchAccessPoliciesState, opts ...pulumi.ResourceOption) (*SwitchAccessPolicies, error) {
	var resource SwitchAccessPolicies
	err := ctx.ReadResource("meraki:networks/switchAccessPolicies:SwitchAccessPolicies", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SwitchAccessPolicies resources.
type switchAccessPoliciesState struct {
	// accessPolicyNumber path parameter. Access policy number
	AccessPolicyNumber *string `pulumi:"accessPolicyNumber"`
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *string `pulumi:"accessPolicyType"`
	// Counts associated with the access policy
	Counts *SwitchAccessPoliciesCounts `pulumi:"counts"`
	// 802.1x Settings
	Dot1x *SwitchAccessPoliciesDot1x `pulumi:"dot1x"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing *bool `pulumi:"guestPortBouncing"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanId *int `pulumi:"guestVlanId"`
	// Choose the Host Mode for the access policy.
	HostMode *string `pulumi:"hostMode"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `pulumi:"increaseAccessSpeed"`
	// Name of the access policy
	Name *string `pulumi:"name"`
	// networkId path parameter. Network ID
	NetworkId *string `pulumi:"networkId"`
	// Object for RADIUS Settings
	Radius *SwitchAccessPoliciesRadius `pulumi:"radius"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled *bool `pulumi:"radiusAccountingEnabled"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []SwitchAccessPoliciesRadiusAccountingServer `pulumi:"radiusAccountingServers"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServersResponses []SwitchAccessPoliciesRadiusAccountingServersResponse `pulumi:"radiusAccountingServersResponses"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled *bool `pulumi:"radiusCoaSupportEnabled"`
	// Acceptable values are *""* for None, or *"11"* for Group Policies ACL
	RadiusGroupAttribute *string `pulumi:"radiusGroupAttribute"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []SwitchAccessPoliciesRadiusServer `pulumi:"radiusServers"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServersResponses []SwitchAccessPoliciesRadiusServersResponse `pulumi:"radiusServersResponses"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled *bool `pulumi:"radiusTestingEnabled"`
	// Enable to restrict access for clients to a responseObjectific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenEnabled *bool `pulumi:"urlRedirectWalledGardenEnabled"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenRanges []string `pulumi:"urlRedirectWalledGardenRanges"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `pulumi:"voiceVlanClients"`
}

type SwitchAccessPoliciesState struct {
	// accessPolicyNumber path parameter. Access policy number
	AccessPolicyNumber pulumi.StringPtrInput
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType pulumi.StringPtrInput
	// Counts associated with the access policy
	Counts SwitchAccessPoliciesCountsPtrInput
	// 802.1x Settings
	Dot1x SwitchAccessPoliciesDot1xPtrInput
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing pulumi.BoolPtrInput
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanId pulumi.IntPtrInput
	// Choose the Host Mode for the access policy.
	HostMode pulumi.StringPtrInput
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed pulumi.BoolPtrInput
	// Name of the access policy
	Name pulumi.StringPtrInput
	// networkId path parameter. Network ID
	NetworkId pulumi.StringPtrInput
	// Object for RADIUS Settings
	Radius SwitchAccessPoliciesRadiusPtrInput
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled pulumi.BoolPtrInput
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers SwitchAccessPoliciesRadiusAccountingServerArrayInput
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServersResponses SwitchAccessPoliciesRadiusAccountingServersResponseArrayInput
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled pulumi.BoolPtrInput
	// Acceptable values are *""* for None, or *"11"* for Group Policies ACL
	RadiusGroupAttribute pulumi.StringPtrInput
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers SwitchAccessPoliciesRadiusServerArrayInput
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServersResponses SwitchAccessPoliciesRadiusServersResponseArrayInput
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled pulumi.BoolPtrInput
	// Enable to restrict access for clients to a responseObjectific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenEnabled pulumi.BoolPtrInput
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenRanges pulumi.StringArrayInput
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients pulumi.BoolPtrInput
}

func (SwitchAccessPoliciesState) ElementType() reflect.Type {
	return reflect.TypeOf((*switchAccessPoliciesState)(nil)).Elem()
}

type switchAccessPoliciesArgs struct {
	// accessPolicyNumber path parameter. Access policy number
	AccessPolicyNumber *string `pulumi:"accessPolicyNumber"`
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType *string `pulumi:"accessPolicyType"`
	// 802.1x Settings
	Dot1x *SwitchAccessPoliciesDot1x `pulumi:"dot1x"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing *bool `pulumi:"guestPortBouncing"`
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanId *int `pulumi:"guestVlanId"`
	// Choose the Host Mode for the access policy.
	HostMode *string `pulumi:"hostMode"`
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed *bool `pulumi:"increaseAccessSpeed"`
	// Name of the access policy
	Name *string `pulumi:"name"`
	// networkId path parameter. Network ID
	NetworkId string `pulumi:"networkId"`
	// Object for RADIUS Settings
	Radius *SwitchAccessPoliciesRadius `pulumi:"radius"`
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled *bool `pulumi:"radiusAccountingEnabled"`
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers []SwitchAccessPoliciesRadiusAccountingServer `pulumi:"radiusAccountingServers"`
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled *bool `pulumi:"radiusCoaSupportEnabled"`
	// Acceptable values are *""* for None, or *"11"* for Group Policies ACL
	RadiusGroupAttribute *string `pulumi:"radiusGroupAttribute"`
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers []SwitchAccessPoliciesRadiusServer `pulumi:"radiusServers"`
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled *bool `pulumi:"radiusTestingEnabled"`
	// Enable to restrict access for clients to a responseObjectific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenEnabled *bool `pulumi:"urlRedirectWalledGardenEnabled"`
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenRanges []string `pulumi:"urlRedirectWalledGardenRanges"`
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients *bool `pulumi:"voiceVlanClients"`
}

// The set of arguments for constructing a SwitchAccessPolicies resource.
type SwitchAccessPoliciesArgs struct {
	// accessPolicyNumber path parameter. Access policy number
	AccessPolicyNumber pulumi.StringPtrInput
	// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
	AccessPolicyType pulumi.StringPtrInput
	// 802.1x Settings
	Dot1x SwitchAccessPoliciesDot1xPtrInput
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	GuestPortBouncing pulumi.BoolPtrInput
	// ID for the guest VLAN allow unauthorized devices access to limited network resources
	GuestVlanId pulumi.IntPtrInput
	// Choose the Host Mode for the access policy.
	HostMode pulumi.StringPtrInput
	// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
	IncreaseAccessSpeed pulumi.BoolPtrInput
	// Name of the access policy
	Name pulumi.StringPtrInput
	// networkId path parameter. Network ID
	NetworkId pulumi.StringInput
	// Object for RADIUS Settings
	Radius SwitchAccessPoliciesRadiusPtrInput
	// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
	RadiusAccountingEnabled pulumi.BoolPtrInput
	// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
	RadiusAccountingServers SwitchAccessPoliciesRadiusAccountingServerArrayInput
	// Change of authentication for RADIUS re-authentication and disconnection
	RadiusCoaSupportEnabled pulumi.BoolPtrInput
	// Acceptable values are *""* for None, or *"11"* for Group Policies ACL
	RadiusGroupAttribute pulumi.StringPtrInput
	// List of RADIUS servers to require connecting devices to authenticate against before granting network access
	RadiusServers SwitchAccessPoliciesRadiusServerArrayInput
	// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
	RadiusTestingEnabled pulumi.BoolPtrInput
	// Enable to restrict access for clients to a responseObjectific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenEnabled pulumi.BoolPtrInput
	// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
	UrlRedirectWalledGardenRanges pulumi.StringArrayInput
	// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
	VoiceVlanClients pulumi.BoolPtrInput
}

func (SwitchAccessPoliciesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*switchAccessPoliciesArgs)(nil)).Elem()
}

type SwitchAccessPoliciesInput interface {
	pulumi.Input

	ToSwitchAccessPoliciesOutput() SwitchAccessPoliciesOutput
	ToSwitchAccessPoliciesOutputWithContext(ctx context.Context) SwitchAccessPoliciesOutput
}

func (*SwitchAccessPolicies) ElementType() reflect.Type {
	return reflect.TypeOf((**SwitchAccessPolicies)(nil)).Elem()
}

func (i *SwitchAccessPolicies) ToSwitchAccessPoliciesOutput() SwitchAccessPoliciesOutput {
	return i.ToSwitchAccessPoliciesOutputWithContext(context.Background())
}

func (i *SwitchAccessPolicies) ToSwitchAccessPoliciesOutputWithContext(ctx context.Context) SwitchAccessPoliciesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwitchAccessPoliciesOutput)
}

// SwitchAccessPoliciesArrayInput is an input type that accepts SwitchAccessPoliciesArray and SwitchAccessPoliciesArrayOutput values.
// You can construct a concrete instance of `SwitchAccessPoliciesArrayInput` via:
//
//	SwitchAccessPoliciesArray{ SwitchAccessPoliciesArgs{...} }
type SwitchAccessPoliciesArrayInput interface {
	pulumi.Input

	ToSwitchAccessPoliciesArrayOutput() SwitchAccessPoliciesArrayOutput
	ToSwitchAccessPoliciesArrayOutputWithContext(context.Context) SwitchAccessPoliciesArrayOutput
}

type SwitchAccessPoliciesArray []SwitchAccessPoliciesInput

func (SwitchAccessPoliciesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SwitchAccessPolicies)(nil)).Elem()
}

func (i SwitchAccessPoliciesArray) ToSwitchAccessPoliciesArrayOutput() SwitchAccessPoliciesArrayOutput {
	return i.ToSwitchAccessPoliciesArrayOutputWithContext(context.Background())
}

func (i SwitchAccessPoliciesArray) ToSwitchAccessPoliciesArrayOutputWithContext(ctx context.Context) SwitchAccessPoliciesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwitchAccessPoliciesArrayOutput)
}

// SwitchAccessPoliciesMapInput is an input type that accepts SwitchAccessPoliciesMap and SwitchAccessPoliciesMapOutput values.
// You can construct a concrete instance of `SwitchAccessPoliciesMapInput` via:
//
//	SwitchAccessPoliciesMap{ "key": SwitchAccessPoliciesArgs{...} }
type SwitchAccessPoliciesMapInput interface {
	pulumi.Input

	ToSwitchAccessPoliciesMapOutput() SwitchAccessPoliciesMapOutput
	ToSwitchAccessPoliciesMapOutputWithContext(context.Context) SwitchAccessPoliciesMapOutput
}

type SwitchAccessPoliciesMap map[string]SwitchAccessPoliciesInput

func (SwitchAccessPoliciesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SwitchAccessPolicies)(nil)).Elem()
}

func (i SwitchAccessPoliciesMap) ToSwitchAccessPoliciesMapOutput() SwitchAccessPoliciesMapOutput {
	return i.ToSwitchAccessPoliciesMapOutputWithContext(context.Background())
}

func (i SwitchAccessPoliciesMap) ToSwitchAccessPoliciesMapOutputWithContext(ctx context.Context) SwitchAccessPoliciesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SwitchAccessPoliciesMapOutput)
}

type SwitchAccessPoliciesOutput struct{ *pulumi.OutputState }

func (SwitchAccessPoliciesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SwitchAccessPolicies)(nil)).Elem()
}

func (o SwitchAccessPoliciesOutput) ToSwitchAccessPoliciesOutput() SwitchAccessPoliciesOutput {
	return o
}

func (o SwitchAccessPoliciesOutput) ToSwitchAccessPoliciesOutputWithContext(ctx context.Context) SwitchAccessPoliciesOutput {
	return o
}

// accessPolicyNumber path parameter. Access policy number
func (o SwitchAccessPoliciesOutput) AccessPolicyNumber() pulumi.StringOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.StringOutput { return v.AccessPolicyNumber }).(pulumi.StringOutput)
}

// Access Type of the policy. Automatically 'Hybrid authentication' when hostMode is 'Multi-Domain'.
func (o SwitchAccessPoliciesOutput) AccessPolicyType() pulumi.StringOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.StringOutput { return v.AccessPolicyType }).(pulumi.StringOutput)
}

// Counts associated with the access policy
func (o SwitchAccessPoliciesOutput) Counts() SwitchAccessPoliciesCountsOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) SwitchAccessPoliciesCountsOutput { return v.Counts }).(SwitchAccessPoliciesCountsOutput)
}

// 802.1x Settings
func (o SwitchAccessPoliciesOutput) Dot1x() SwitchAccessPoliciesDot1xOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) SwitchAccessPoliciesDot1xOutput { return v.Dot1x }).(SwitchAccessPoliciesDot1xOutput)
}

// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
func (o SwitchAccessPoliciesOutput) GuestPortBouncing() pulumi.BoolOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.BoolOutput { return v.GuestPortBouncing }).(pulumi.BoolOutput)
}

// ID for the guest VLAN allow unauthorized devices access to limited network resources
func (o SwitchAccessPoliciesOutput) GuestVlanId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.IntPtrOutput { return v.GuestVlanId }).(pulumi.IntPtrOutput)
}

// Choose the Host Mode for the access policy.
func (o SwitchAccessPoliciesOutput) HostMode() pulumi.StringOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.StringOutput { return v.HostMode }).(pulumi.StringOutput)
}

// Enabling this option will make switches execute 802.1X and MAC-bypass authentication simultaneously so that clients authenticate faster. Only required when accessPolicyType is 'Hybrid Authentication.
func (o SwitchAccessPoliciesOutput) IncreaseAccessSpeed() pulumi.BoolOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.BoolOutput { return v.IncreaseAccessSpeed }).(pulumi.BoolOutput)
}

// Name of the access policy
func (o SwitchAccessPoliciesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// networkId path parameter. Network ID
func (o SwitchAccessPoliciesOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.StringOutput { return v.NetworkId }).(pulumi.StringOutput)
}

// Object for RADIUS Settings
func (o SwitchAccessPoliciesOutput) Radius() SwitchAccessPoliciesRadiusOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) SwitchAccessPoliciesRadiusOutput { return v.Radius }).(SwitchAccessPoliciesRadiusOutput)
}

// Enable to send start, interim-update and stop messages to a configured RADIUS accounting server for tracking connected clients
func (o SwitchAccessPoliciesOutput) RadiusAccountingEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.BoolOutput { return v.RadiusAccountingEnabled }).(pulumi.BoolOutput)
}

// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
func (o SwitchAccessPoliciesOutput) RadiusAccountingServers() SwitchAccessPoliciesRadiusAccountingServerArrayOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) SwitchAccessPoliciesRadiusAccountingServerArrayOutput {
		return v.RadiusAccountingServers
	}).(SwitchAccessPoliciesRadiusAccountingServerArrayOutput)
}

// List of RADIUS accounting servers to require connecting devices to authenticate against before granting network access
func (o SwitchAccessPoliciesOutput) RadiusAccountingServersResponses() SwitchAccessPoliciesRadiusAccountingServersResponseArrayOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) SwitchAccessPoliciesRadiusAccountingServersResponseArrayOutput {
		return v.RadiusAccountingServersResponses
	}).(SwitchAccessPoliciesRadiusAccountingServersResponseArrayOutput)
}

// Change of authentication for RADIUS re-authentication and disconnection
func (o SwitchAccessPoliciesOutput) RadiusCoaSupportEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.BoolOutput { return v.RadiusCoaSupportEnabled }).(pulumi.BoolOutput)
}

// Acceptable values are *""* for None, or *"11"* for Group Policies ACL
func (o SwitchAccessPoliciesOutput) RadiusGroupAttribute() pulumi.StringOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.StringOutput { return v.RadiusGroupAttribute }).(pulumi.StringOutput)
}

// List of RADIUS servers to require connecting devices to authenticate against before granting network access
func (o SwitchAccessPoliciesOutput) RadiusServers() SwitchAccessPoliciesRadiusServerArrayOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) SwitchAccessPoliciesRadiusServerArrayOutput { return v.RadiusServers }).(SwitchAccessPoliciesRadiusServerArrayOutput)
}

// List of RADIUS servers to require connecting devices to authenticate against before granting network access
func (o SwitchAccessPoliciesOutput) RadiusServersResponses() SwitchAccessPoliciesRadiusServersResponseArrayOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) SwitchAccessPoliciesRadiusServersResponseArrayOutput {
		return v.RadiusServersResponses
	}).(SwitchAccessPoliciesRadiusServersResponseArrayOutput)
}

// If enabled, Meraki devices will periodically send access-request messages to these RADIUS servers
func (o SwitchAccessPoliciesOutput) RadiusTestingEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.BoolOutput { return v.RadiusTestingEnabled }).(pulumi.BoolOutput)
}

// Enable to restrict access for clients to a responseObjectific set of IP addresses or hostnames prior to authentication
func (o SwitchAccessPoliciesOutput) UrlRedirectWalledGardenEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.BoolOutput { return v.UrlRedirectWalledGardenEnabled }).(pulumi.BoolOutput)
}

// IP address ranges, in CIDR notation, to restrict access for clients to a specific set of IP addresses or hostnames prior to authentication
func (o SwitchAccessPoliciesOutput) UrlRedirectWalledGardenRanges() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.StringArrayOutput { return v.UrlRedirectWalledGardenRanges }).(pulumi.StringArrayOutput)
}

// CDP/LLDP capable voice clients will be able to use this VLAN. Automatically true when hostMode is 'Multi-Domain'.
func (o SwitchAccessPoliciesOutput) VoiceVlanClients() pulumi.BoolOutput {
	return o.ApplyT(func(v *SwitchAccessPolicies) pulumi.BoolOutput { return v.VoiceVlanClients }).(pulumi.BoolOutput)
}

type SwitchAccessPoliciesArrayOutput struct{ *pulumi.OutputState }

func (SwitchAccessPoliciesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SwitchAccessPolicies)(nil)).Elem()
}

func (o SwitchAccessPoliciesArrayOutput) ToSwitchAccessPoliciesArrayOutput() SwitchAccessPoliciesArrayOutput {
	return o
}

func (o SwitchAccessPoliciesArrayOutput) ToSwitchAccessPoliciesArrayOutputWithContext(ctx context.Context) SwitchAccessPoliciesArrayOutput {
	return o
}

func (o SwitchAccessPoliciesArrayOutput) Index(i pulumi.IntInput) SwitchAccessPoliciesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SwitchAccessPolicies {
		return vs[0].([]*SwitchAccessPolicies)[vs[1].(int)]
	}).(SwitchAccessPoliciesOutput)
}

type SwitchAccessPoliciesMapOutput struct{ *pulumi.OutputState }

func (SwitchAccessPoliciesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SwitchAccessPolicies)(nil)).Elem()
}

func (o SwitchAccessPoliciesMapOutput) ToSwitchAccessPoliciesMapOutput() SwitchAccessPoliciesMapOutput {
	return o
}

func (o SwitchAccessPoliciesMapOutput) ToSwitchAccessPoliciesMapOutputWithContext(ctx context.Context) SwitchAccessPoliciesMapOutput {
	return o
}

func (o SwitchAccessPoliciesMapOutput) MapIndex(k pulumi.StringInput) SwitchAccessPoliciesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SwitchAccessPolicies {
		return vs[0].(map[string]*SwitchAccessPolicies)[vs[1].(string)]
	}).(SwitchAccessPoliciesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SwitchAccessPoliciesInput)(nil)).Elem(), &SwitchAccessPolicies{})
	pulumi.RegisterInputType(reflect.TypeOf((*SwitchAccessPoliciesArrayInput)(nil)).Elem(), SwitchAccessPoliciesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SwitchAccessPoliciesMapInput)(nil)).Elem(), SwitchAccessPoliciesMap{})
	pulumi.RegisterOutputType(SwitchAccessPoliciesOutput{})
	pulumi.RegisterOutputType(SwitchAccessPoliciesArrayOutput{})
	pulumi.RegisterOutputType(SwitchAccessPoliciesMapOutput{})
}
