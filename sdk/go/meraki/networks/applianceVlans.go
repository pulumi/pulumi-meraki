// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-meraki/sdk/go/meraki/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-meraki/sdk/go/meraki/networks"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := networks.NewApplianceVlans(ctx, "example", &networks.ApplianceVlansArgs{
//				ApplianceIp:   pulumi.String("192.168.1.2"),
//				Cidr:          pulumi.String("192.168.1.0/24"),
//				GroupPolicyId: pulumi.String("101"),
//				VlanId:        pulumi.String("1234"),
//				Ipv6: &networks.ApplianceVlansIpv6Args{
//					Enabled: pulumi.Bool(true),
//					Prefix_assignments: []map[string]interface{}{
//						map[string]interface{}{
//							"autonomous": false,
//							"origin": map[string]interface{}{
//								"interfaces": []string{
//									"wan0",
//								},
//								"type": "internet",
//							},
//							"staticApplianceIp6": "2001:db8:3c4d:15::1",
//							"staticPrefix":       "2001:db8:3c4d:15::/64",
//						},
//					},
//				},
//				MandatoryDhcp: &networks.ApplianceVlansMandatoryDhcpArgs{
//					Enabled: pulumi.Bool(true),
//				},
//				Mask:             pulumi.Int(28),
//				Name:             pulumi.String("My VLAN"),
//				NetworkId:        pulumi.String("string"),
//				Subnet:           pulumi.String("192.168.1.0/24"),
//				TemplateVlanType: pulumi.String("same"),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("merakiNetworksApplianceVlansExample", example)
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import meraki:networks/applianceVlans:ApplianceVlans example "network_id,vlan_id"
// ```
type ApplianceVlans struct {
	pulumi.CustomResourceState

	// The local IP of the appliance on the VLAN
	ApplianceIp pulumi.StringOutput `pulumi:"applianceIp"`
	// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
	Cidr pulumi.StringPtrOutput `pulumi:"cidr"`
	// DHCP boot option for boot filename
	DhcpBootFilename pulumi.StringOutput `pulumi:"dhcpBootFilename"`
	// DHCP boot option to direct boot clients to the server to load the boot file from
	DhcpBootNextServer pulumi.StringOutput `pulumi:"dhcpBootNextServer"`
	// Use DHCP boot options specified in other properties
	DhcpBootOptionsEnabled pulumi.BoolOutput `pulumi:"dhcpBootOptionsEnabled"`
	// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
	DhcpHandling pulumi.StringOutput `pulumi:"dhcpHandling"`
	// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
	DhcpLeaseTime pulumi.StringOutput `pulumi:"dhcpLeaseTime"`
	// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
	DhcpOptions ApplianceVlansDhcpOptionArrayOutput `pulumi:"dhcpOptions"`
	// The IPs of the DHCP servers that DHCP requests should be relayed to
	DhcpRelayServerIps pulumi.StringArrayOutput `pulumi:"dhcpRelayServerIps"`
	// The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
	DnsNameservers pulumi.StringOutput `pulumi:"dnsNameservers"`
	// The id of the desired group policy to apply to the VLAN
	GroupPolicyId pulumi.StringOutput `pulumi:"groupPolicyId"`
	// The interface ID of the VLAN
	InterfaceId pulumi.StringOutput `pulumi:"interfaceId"`
	// IPv6 configuration on the VLAN
	Ipv6 ApplianceVlansIpv6Output `pulumi:"ipv6"`
	// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
	MandatoryDhcp ApplianceVlansMandatoryDhcpOutput `pulumi:"mandatoryDhcp"`
	// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
	Mask pulumi.IntOutput `pulumi:"mask"`
	// The name of the VLAN
	Name pulumi.StringOutput `pulumi:"name"`
	// networkId path parameter. Network ID
	NetworkId pulumi.StringOutput `pulumi:"networkId"`
	// The DHCP reserved IP ranges on the VLAN
	ReservedIpRanges ApplianceVlansReservedIpRangeArrayOutput `pulumi:"reservedIpRanges"`
	// The subnet of the VLAN
	Subnet pulumi.StringOutput `pulumi:"subnet"`
	// Type of subnetting of the VLAN. Applicable only for template network.
	TemplateVlanType pulumi.StringOutput `pulumi:"templateVlanType"`
	// The VLAN ID of the VLAN
	VlanId pulumi.StringOutput `pulumi:"vlanId"`
	// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
	VpnNatSubnet pulumi.StringOutput `pulumi:"vpnNatSubnet"`
}

// NewApplianceVlans registers a new resource with the given unique name, arguments, and options.
func NewApplianceVlans(ctx *pulumi.Context,
	name string, args *ApplianceVlansArgs, opts ...pulumi.ResourceOption) (*ApplianceVlans, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.NetworkId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkId'")
	}
	if args.VlanId == nil {
		return nil, errors.New("invalid value for required argument 'VlanId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ApplianceVlans
	err := ctx.RegisterResource("meraki:networks/applianceVlans:ApplianceVlans", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetApplianceVlans gets an existing ApplianceVlans resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetApplianceVlans(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ApplianceVlansState, opts ...pulumi.ResourceOption) (*ApplianceVlans, error) {
	var resource ApplianceVlans
	err := ctx.ReadResource("meraki:networks/applianceVlans:ApplianceVlans", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ApplianceVlans resources.
type applianceVlansState struct {
	// The local IP of the appliance on the VLAN
	ApplianceIp *string `pulumi:"applianceIp"`
	// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
	Cidr *string `pulumi:"cidr"`
	// DHCP boot option for boot filename
	DhcpBootFilename *string `pulumi:"dhcpBootFilename"`
	// DHCP boot option to direct boot clients to the server to load the boot file from
	DhcpBootNextServer *string `pulumi:"dhcpBootNextServer"`
	// Use DHCP boot options specified in other properties
	DhcpBootOptionsEnabled *bool `pulumi:"dhcpBootOptionsEnabled"`
	// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
	DhcpHandling *string `pulumi:"dhcpHandling"`
	// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
	DhcpLeaseTime *string `pulumi:"dhcpLeaseTime"`
	// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
	DhcpOptions []ApplianceVlansDhcpOption `pulumi:"dhcpOptions"`
	// The IPs of the DHCP servers that DHCP requests should be relayed to
	DhcpRelayServerIps []string `pulumi:"dhcpRelayServerIps"`
	// The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
	DnsNameservers *string `pulumi:"dnsNameservers"`
	// The id of the desired group policy to apply to the VLAN
	GroupPolicyId *string `pulumi:"groupPolicyId"`
	// The interface ID of the VLAN
	InterfaceId *string `pulumi:"interfaceId"`
	// IPv6 configuration on the VLAN
	Ipv6 *ApplianceVlansIpv6 `pulumi:"ipv6"`
	// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
	MandatoryDhcp *ApplianceVlansMandatoryDhcp `pulumi:"mandatoryDhcp"`
	// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
	Mask *int `pulumi:"mask"`
	// The name of the VLAN
	Name *string `pulumi:"name"`
	// networkId path parameter. Network ID
	NetworkId *string `pulumi:"networkId"`
	// The DHCP reserved IP ranges on the VLAN
	ReservedIpRanges []ApplianceVlansReservedIpRange `pulumi:"reservedIpRanges"`
	// The subnet of the VLAN
	Subnet *string `pulumi:"subnet"`
	// Type of subnetting of the VLAN. Applicable only for template network.
	TemplateVlanType *string `pulumi:"templateVlanType"`
	// The VLAN ID of the VLAN
	VlanId *string `pulumi:"vlanId"`
	// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
	VpnNatSubnet *string `pulumi:"vpnNatSubnet"`
}

type ApplianceVlansState struct {
	// The local IP of the appliance on the VLAN
	ApplianceIp pulumi.StringPtrInput
	// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
	Cidr pulumi.StringPtrInput
	// DHCP boot option for boot filename
	DhcpBootFilename pulumi.StringPtrInput
	// DHCP boot option to direct boot clients to the server to load the boot file from
	DhcpBootNextServer pulumi.StringPtrInput
	// Use DHCP boot options specified in other properties
	DhcpBootOptionsEnabled pulumi.BoolPtrInput
	// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
	DhcpHandling pulumi.StringPtrInput
	// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
	DhcpLeaseTime pulumi.StringPtrInput
	// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
	DhcpOptions ApplianceVlansDhcpOptionArrayInput
	// The IPs of the DHCP servers that DHCP requests should be relayed to
	DhcpRelayServerIps pulumi.StringArrayInput
	// The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
	DnsNameservers pulumi.StringPtrInput
	// The id of the desired group policy to apply to the VLAN
	GroupPolicyId pulumi.StringPtrInput
	// The interface ID of the VLAN
	InterfaceId pulumi.StringPtrInput
	// IPv6 configuration on the VLAN
	Ipv6 ApplianceVlansIpv6PtrInput
	// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
	MandatoryDhcp ApplianceVlansMandatoryDhcpPtrInput
	// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
	Mask pulumi.IntPtrInput
	// The name of the VLAN
	Name pulumi.StringPtrInput
	// networkId path parameter. Network ID
	NetworkId pulumi.StringPtrInput
	// The DHCP reserved IP ranges on the VLAN
	ReservedIpRanges ApplianceVlansReservedIpRangeArrayInput
	// The subnet of the VLAN
	Subnet pulumi.StringPtrInput
	// Type of subnetting of the VLAN. Applicable only for template network.
	TemplateVlanType pulumi.StringPtrInput
	// The VLAN ID of the VLAN
	VlanId pulumi.StringPtrInput
	// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
	VpnNatSubnet pulumi.StringPtrInput
}

func (ApplianceVlansState) ElementType() reflect.Type {
	return reflect.TypeOf((*applianceVlansState)(nil)).Elem()
}

type applianceVlansArgs struct {
	// The local IP of the appliance on the VLAN
	ApplianceIp *string `pulumi:"applianceIp"`
	// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
	Cidr *string `pulumi:"cidr"`
	// DHCP boot option for boot filename
	DhcpBootFilename *string `pulumi:"dhcpBootFilename"`
	// DHCP boot option to direct boot clients to the server to load the boot file from
	DhcpBootNextServer *string `pulumi:"dhcpBootNextServer"`
	// Use DHCP boot options specified in other properties
	DhcpBootOptionsEnabled *bool `pulumi:"dhcpBootOptionsEnabled"`
	// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
	DhcpHandling *string `pulumi:"dhcpHandling"`
	// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
	DhcpLeaseTime *string `pulumi:"dhcpLeaseTime"`
	// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
	DhcpOptions []ApplianceVlansDhcpOption `pulumi:"dhcpOptions"`
	// The IPs of the DHCP servers that DHCP requests should be relayed to
	DhcpRelayServerIps []string `pulumi:"dhcpRelayServerIps"`
	// The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
	DnsNameservers *string `pulumi:"dnsNameservers"`
	// The id of the desired group policy to apply to the VLAN
	GroupPolicyId *string `pulumi:"groupPolicyId"`
	// IPv6 configuration on the VLAN
	Ipv6 *ApplianceVlansIpv6 `pulumi:"ipv6"`
	// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
	MandatoryDhcp *ApplianceVlansMandatoryDhcp `pulumi:"mandatoryDhcp"`
	// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
	Mask *int `pulumi:"mask"`
	// The name of the VLAN
	Name *string `pulumi:"name"`
	// networkId path parameter. Network ID
	NetworkId string `pulumi:"networkId"`
	// The DHCP reserved IP ranges on the VLAN
	ReservedIpRanges []ApplianceVlansReservedIpRange `pulumi:"reservedIpRanges"`
	// The subnet of the VLAN
	Subnet *string `pulumi:"subnet"`
	// Type of subnetting of the VLAN. Applicable only for template network.
	TemplateVlanType *string `pulumi:"templateVlanType"`
	// The VLAN ID of the VLAN
	VlanId string `pulumi:"vlanId"`
	// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
	VpnNatSubnet *string `pulumi:"vpnNatSubnet"`
}

// The set of arguments for constructing a ApplianceVlans resource.
type ApplianceVlansArgs struct {
	// The local IP of the appliance on the VLAN
	ApplianceIp pulumi.StringPtrInput
	// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
	Cidr pulumi.StringPtrInput
	// DHCP boot option for boot filename
	DhcpBootFilename pulumi.StringPtrInput
	// DHCP boot option to direct boot clients to the server to load the boot file from
	DhcpBootNextServer pulumi.StringPtrInput
	// Use DHCP boot options specified in other properties
	DhcpBootOptionsEnabled pulumi.BoolPtrInput
	// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
	DhcpHandling pulumi.StringPtrInput
	// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
	DhcpLeaseTime pulumi.StringPtrInput
	// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
	DhcpOptions ApplianceVlansDhcpOptionArrayInput
	// The IPs of the DHCP servers that DHCP requests should be relayed to
	DhcpRelayServerIps pulumi.StringArrayInput
	// The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
	DnsNameservers pulumi.StringPtrInput
	// The id of the desired group policy to apply to the VLAN
	GroupPolicyId pulumi.StringPtrInput
	// IPv6 configuration on the VLAN
	Ipv6 ApplianceVlansIpv6PtrInput
	// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
	MandatoryDhcp ApplianceVlansMandatoryDhcpPtrInput
	// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
	Mask pulumi.IntPtrInput
	// The name of the VLAN
	Name pulumi.StringPtrInput
	// networkId path parameter. Network ID
	NetworkId pulumi.StringInput
	// The DHCP reserved IP ranges on the VLAN
	ReservedIpRanges ApplianceVlansReservedIpRangeArrayInput
	// The subnet of the VLAN
	Subnet pulumi.StringPtrInput
	// Type of subnetting of the VLAN. Applicable only for template network.
	TemplateVlanType pulumi.StringPtrInput
	// The VLAN ID of the VLAN
	VlanId pulumi.StringInput
	// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
	VpnNatSubnet pulumi.StringPtrInput
}

func (ApplianceVlansArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*applianceVlansArgs)(nil)).Elem()
}

type ApplianceVlansInput interface {
	pulumi.Input

	ToApplianceVlansOutput() ApplianceVlansOutput
	ToApplianceVlansOutputWithContext(ctx context.Context) ApplianceVlansOutput
}

func (*ApplianceVlans) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplianceVlans)(nil)).Elem()
}

func (i *ApplianceVlans) ToApplianceVlansOutput() ApplianceVlansOutput {
	return i.ToApplianceVlansOutputWithContext(context.Background())
}

func (i *ApplianceVlans) ToApplianceVlansOutputWithContext(ctx context.Context) ApplianceVlansOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplianceVlansOutput)
}

// ApplianceVlansArrayInput is an input type that accepts ApplianceVlansArray and ApplianceVlansArrayOutput values.
// You can construct a concrete instance of `ApplianceVlansArrayInput` via:
//
//	ApplianceVlansArray{ ApplianceVlansArgs{...} }
type ApplianceVlansArrayInput interface {
	pulumi.Input

	ToApplianceVlansArrayOutput() ApplianceVlansArrayOutput
	ToApplianceVlansArrayOutputWithContext(context.Context) ApplianceVlansArrayOutput
}

type ApplianceVlansArray []ApplianceVlansInput

func (ApplianceVlansArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplianceVlans)(nil)).Elem()
}

func (i ApplianceVlansArray) ToApplianceVlansArrayOutput() ApplianceVlansArrayOutput {
	return i.ToApplianceVlansArrayOutputWithContext(context.Background())
}

func (i ApplianceVlansArray) ToApplianceVlansArrayOutputWithContext(ctx context.Context) ApplianceVlansArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplianceVlansArrayOutput)
}

// ApplianceVlansMapInput is an input type that accepts ApplianceVlansMap and ApplianceVlansMapOutput values.
// You can construct a concrete instance of `ApplianceVlansMapInput` via:
//
//	ApplianceVlansMap{ "key": ApplianceVlansArgs{...} }
type ApplianceVlansMapInput interface {
	pulumi.Input

	ToApplianceVlansMapOutput() ApplianceVlansMapOutput
	ToApplianceVlansMapOutputWithContext(context.Context) ApplianceVlansMapOutput
}

type ApplianceVlansMap map[string]ApplianceVlansInput

func (ApplianceVlansMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplianceVlans)(nil)).Elem()
}

func (i ApplianceVlansMap) ToApplianceVlansMapOutput() ApplianceVlansMapOutput {
	return i.ToApplianceVlansMapOutputWithContext(context.Background())
}

func (i ApplianceVlansMap) ToApplianceVlansMapOutputWithContext(ctx context.Context) ApplianceVlansMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ApplianceVlansMapOutput)
}

type ApplianceVlansOutput struct{ *pulumi.OutputState }

func (ApplianceVlansOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ApplianceVlans)(nil)).Elem()
}

func (o ApplianceVlansOutput) ToApplianceVlansOutput() ApplianceVlansOutput {
	return o
}

func (o ApplianceVlansOutput) ToApplianceVlansOutputWithContext(ctx context.Context) ApplianceVlansOutput {
	return o
}

// The local IP of the appliance on the VLAN
func (o ApplianceVlansOutput) ApplianceIp() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.ApplianceIp }).(pulumi.StringOutput)
}

// CIDR of the pool of subnets. Applicable only for template network. Each network bound to the template will automatically pick a subnet from this pool to build its own VLAN.
func (o ApplianceVlansOutput) Cidr() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringPtrOutput { return v.Cidr }).(pulumi.StringPtrOutput)
}

// DHCP boot option for boot filename
func (o ApplianceVlansOutput) DhcpBootFilename() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.DhcpBootFilename }).(pulumi.StringOutput)
}

// DHCP boot option to direct boot clients to the server to load the boot file from
func (o ApplianceVlansOutput) DhcpBootNextServer() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.DhcpBootNextServer }).(pulumi.StringOutput)
}

// Use DHCP boot options specified in other properties
func (o ApplianceVlansOutput) DhcpBootOptionsEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.BoolOutput { return v.DhcpBootOptionsEnabled }).(pulumi.BoolOutput)
}

// The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
func (o ApplianceVlansOutput) DhcpHandling() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.DhcpHandling }).(pulumi.StringOutput)
}

// The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
func (o ApplianceVlansOutput) DhcpLeaseTime() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.DhcpLeaseTime }).(pulumi.StringOutput)
}

// The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.
func (o ApplianceVlansOutput) DhcpOptions() ApplianceVlansDhcpOptionArrayOutput {
	return o.ApplyT(func(v *ApplianceVlans) ApplianceVlansDhcpOptionArrayOutput { return v.DhcpOptions }).(ApplianceVlansDhcpOptionArrayOutput)
}

// The IPs of the DHCP servers that DHCP requests should be relayed to
func (o ApplianceVlansOutput) DhcpRelayServerIps() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringArrayOutput { return v.DhcpRelayServerIps }).(pulumi.StringArrayOutput)
}

// The DNS nameservers used for DHCP responses, either "upstream*dns", "google*dns", "opendns", or a newline seperated string of IP addresses or domain names
func (o ApplianceVlansOutput) DnsNameservers() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.DnsNameservers }).(pulumi.StringOutput)
}

// The id of the desired group policy to apply to the VLAN
func (o ApplianceVlansOutput) GroupPolicyId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.GroupPolicyId }).(pulumi.StringOutput)
}

// The interface ID of the VLAN
func (o ApplianceVlansOutput) InterfaceId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.InterfaceId }).(pulumi.StringOutput)
}

// IPv6 configuration on the VLAN
func (o ApplianceVlansOutput) Ipv6() ApplianceVlansIpv6Output {
	return o.ApplyT(func(v *ApplianceVlans) ApplianceVlansIpv6Output { return v.Ipv6 }).(ApplianceVlansIpv6Output)
}

// Mandatory DHCP will enforce that clients connecting to this VLAN must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate. Only available on firmware versions 17.0 and above
func (o ApplianceVlansOutput) MandatoryDhcp() ApplianceVlansMandatoryDhcpOutput {
	return o.ApplyT(func(v *ApplianceVlans) ApplianceVlansMandatoryDhcpOutput { return v.MandatoryDhcp }).(ApplianceVlansMandatoryDhcpOutput)
}

// Mask used for the subnet of all bound to the template networks. Applicable only for template network.
func (o ApplianceVlansOutput) Mask() pulumi.IntOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.IntOutput { return v.Mask }).(pulumi.IntOutput)
}

// The name of the VLAN
func (o ApplianceVlansOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// networkId path parameter. Network ID
func (o ApplianceVlansOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.NetworkId }).(pulumi.StringOutput)
}

// The DHCP reserved IP ranges on the VLAN
func (o ApplianceVlansOutput) ReservedIpRanges() ApplianceVlansReservedIpRangeArrayOutput {
	return o.ApplyT(func(v *ApplianceVlans) ApplianceVlansReservedIpRangeArrayOutput { return v.ReservedIpRanges }).(ApplianceVlansReservedIpRangeArrayOutput)
}

// The subnet of the VLAN
func (o ApplianceVlansOutput) Subnet() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.Subnet }).(pulumi.StringOutput)
}

// Type of subnetting of the VLAN. Applicable only for template network.
func (o ApplianceVlansOutput) TemplateVlanType() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.TemplateVlanType }).(pulumi.StringOutput)
}

// The VLAN ID of the VLAN
func (o ApplianceVlansOutput) VlanId() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.VlanId }).(pulumi.StringOutput)
}

// The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
func (o ApplianceVlansOutput) VpnNatSubnet() pulumi.StringOutput {
	return o.ApplyT(func(v *ApplianceVlans) pulumi.StringOutput { return v.VpnNatSubnet }).(pulumi.StringOutput)
}

type ApplianceVlansArrayOutput struct{ *pulumi.OutputState }

func (ApplianceVlansArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ApplianceVlans)(nil)).Elem()
}

func (o ApplianceVlansArrayOutput) ToApplianceVlansArrayOutput() ApplianceVlansArrayOutput {
	return o
}

func (o ApplianceVlansArrayOutput) ToApplianceVlansArrayOutputWithContext(ctx context.Context) ApplianceVlansArrayOutput {
	return o
}

func (o ApplianceVlansArrayOutput) Index(i pulumi.IntInput) ApplianceVlansOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ApplianceVlans {
		return vs[0].([]*ApplianceVlans)[vs[1].(int)]
	}).(ApplianceVlansOutput)
}

type ApplianceVlansMapOutput struct{ *pulumi.OutputState }

func (ApplianceVlansMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ApplianceVlans)(nil)).Elem()
}

func (o ApplianceVlansMapOutput) ToApplianceVlansMapOutput() ApplianceVlansMapOutput {
	return o
}

func (o ApplianceVlansMapOutput) ToApplianceVlansMapOutputWithContext(ctx context.Context) ApplianceVlansMapOutput {
	return o
}

func (o ApplianceVlansMapOutput) MapIndex(k pulumi.StringInput) ApplianceVlansOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ApplianceVlans {
		return vs[0].(map[string]*ApplianceVlans)[vs[1].(string)]
	}).(ApplianceVlansOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ApplianceVlansInput)(nil)).Elem(), &ApplianceVlans{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplianceVlansArrayInput)(nil)).Elem(), ApplianceVlansArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ApplianceVlansMapInput)(nil)).Elem(), ApplianceVlansMap{})
	pulumi.RegisterOutputType(ApplianceVlansOutput{})
	pulumi.RegisterOutputType(ApplianceVlansArrayOutput{})
	pulumi.RegisterOutputType(ApplianceVlansMapOutput{})
}
