// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package networks

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-meraki/sdk/go/meraki/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ~>Warning: This resource does not represent a real-world entity in Meraki Dashboard, therefore changing or deleting this resource on its own has no immediate effect. Instead, it is a task part of a Meraki Dashboard workflow. It is executed in Meraki without any additional verification. It does not check if it was executed before or if a similar configuration or action
// already existed previously.
type Unbind struct {
	pulumi.CustomResourceState

	Item UnbindItemOutput `pulumi:"item"`
	// networkId path parameter. Network ID
	NetworkId  pulumi.StringOutput    `pulumi:"networkId"`
	Parameters UnbindParametersOutput `pulumi:"parameters"`
}

// NewUnbind registers a new resource with the given unique name, arguments, and options.
func NewUnbind(ctx *pulumi.Context,
	name string, args *UnbindArgs, opts ...pulumi.ResourceOption) (*Unbind, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.NetworkId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkId'")
	}
	if args.Parameters == nil {
		return nil, errors.New("invalid value for required argument 'Parameters'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Unbind
	err := ctx.RegisterResource("meraki:networks/unbind:Unbind", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUnbind gets an existing Unbind resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUnbind(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UnbindState, opts ...pulumi.ResourceOption) (*Unbind, error) {
	var resource Unbind
	err := ctx.ReadResource("meraki:networks/unbind:Unbind", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Unbind resources.
type unbindState struct {
	Item *UnbindItem `pulumi:"item"`
	// networkId path parameter. Network ID
	NetworkId  *string           `pulumi:"networkId"`
	Parameters *UnbindParameters `pulumi:"parameters"`
}

type UnbindState struct {
	Item UnbindItemPtrInput
	// networkId path parameter. Network ID
	NetworkId  pulumi.StringPtrInput
	Parameters UnbindParametersPtrInput
}

func (UnbindState) ElementType() reflect.Type {
	return reflect.TypeOf((*unbindState)(nil)).Elem()
}

type unbindArgs struct {
	// networkId path parameter. Network ID
	NetworkId  string           `pulumi:"networkId"`
	Parameters UnbindParameters `pulumi:"parameters"`
}

// The set of arguments for constructing a Unbind resource.
type UnbindArgs struct {
	// networkId path parameter. Network ID
	NetworkId  pulumi.StringInput
	Parameters UnbindParametersInput
}

func (UnbindArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*unbindArgs)(nil)).Elem()
}

type UnbindInput interface {
	pulumi.Input

	ToUnbindOutput() UnbindOutput
	ToUnbindOutputWithContext(ctx context.Context) UnbindOutput
}

func (*Unbind) ElementType() reflect.Type {
	return reflect.TypeOf((**Unbind)(nil)).Elem()
}

func (i *Unbind) ToUnbindOutput() UnbindOutput {
	return i.ToUnbindOutputWithContext(context.Background())
}

func (i *Unbind) ToUnbindOutputWithContext(ctx context.Context) UnbindOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UnbindOutput)
}

// UnbindArrayInput is an input type that accepts UnbindArray and UnbindArrayOutput values.
// You can construct a concrete instance of `UnbindArrayInput` via:
//
//	UnbindArray{ UnbindArgs{...} }
type UnbindArrayInput interface {
	pulumi.Input

	ToUnbindArrayOutput() UnbindArrayOutput
	ToUnbindArrayOutputWithContext(context.Context) UnbindArrayOutput
}

type UnbindArray []UnbindInput

func (UnbindArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Unbind)(nil)).Elem()
}

func (i UnbindArray) ToUnbindArrayOutput() UnbindArrayOutput {
	return i.ToUnbindArrayOutputWithContext(context.Background())
}

func (i UnbindArray) ToUnbindArrayOutputWithContext(ctx context.Context) UnbindArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UnbindArrayOutput)
}

// UnbindMapInput is an input type that accepts UnbindMap and UnbindMapOutput values.
// You can construct a concrete instance of `UnbindMapInput` via:
//
//	UnbindMap{ "key": UnbindArgs{...} }
type UnbindMapInput interface {
	pulumi.Input

	ToUnbindMapOutput() UnbindMapOutput
	ToUnbindMapOutputWithContext(context.Context) UnbindMapOutput
}

type UnbindMap map[string]UnbindInput

func (UnbindMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Unbind)(nil)).Elem()
}

func (i UnbindMap) ToUnbindMapOutput() UnbindMapOutput {
	return i.ToUnbindMapOutputWithContext(context.Background())
}

func (i UnbindMap) ToUnbindMapOutputWithContext(ctx context.Context) UnbindMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UnbindMapOutput)
}

type UnbindOutput struct{ *pulumi.OutputState }

func (UnbindOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Unbind)(nil)).Elem()
}

func (o UnbindOutput) ToUnbindOutput() UnbindOutput {
	return o
}

func (o UnbindOutput) ToUnbindOutputWithContext(ctx context.Context) UnbindOutput {
	return o
}

func (o UnbindOutput) Item() UnbindItemOutput {
	return o.ApplyT(func(v *Unbind) UnbindItemOutput { return v.Item }).(UnbindItemOutput)
}

// networkId path parameter. Network ID
func (o UnbindOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *Unbind) pulumi.StringOutput { return v.NetworkId }).(pulumi.StringOutput)
}

func (o UnbindOutput) Parameters() UnbindParametersOutput {
	return o.ApplyT(func(v *Unbind) UnbindParametersOutput { return v.Parameters }).(UnbindParametersOutput)
}

type UnbindArrayOutput struct{ *pulumi.OutputState }

func (UnbindArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Unbind)(nil)).Elem()
}

func (o UnbindArrayOutput) ToUnbindArrayOutput() UnbindArrayOutput {
	return o
}

func (o UnbindArrayOutput) ToUnbindArrayOutputWithContext(ctx context.Context) UnbindArrayOutput {
	return o
}

func (o UnbindArrayOutput) Index(i pulumi.IntInput) UnbindOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Unbind {
		return vs[0].([]*Unbind)[vs[1].(int)]
	}).(UnbindOutput)
}

type UnbindMapOutput struct{ *pulumi.OutputState }

func (UnbindMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Unbind)(nil)).Elem()
}

func (o UnbindMapOutput) ToUnbindMapOutput() UnbindMapOutput {
	return o
}

func (o UnbindMapOutput) ToUnbindMapOutputWithContext(ctx context.Context) UnbindMapOutput {
	return o
}

func (o UnbindMapOutput) MapIndex(k pulumi.StringInput) UnbindOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Unbind {
		return vs[0].(map[string]*Unbind)[vs[1].(string)]
	}).(UnbindOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UnbindInput)(nil)).Elem(), &Unbind{})
	pulumi.RegisterInputType(reflect.TypeOf((*UnbindArrayInput)(nil)).Elem(), UnbindArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UnbindMapInput)(nil)).Elem(), UnbindMap{})
	pulumi.RegisterOutputType(UnbindOutput{})
	pulumi.RegisterOutputType(UnbindArrayOutput{})
	pulumi.RegisterOutputType(UnbindMapOutput{})
}
