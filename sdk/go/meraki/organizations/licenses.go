// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package organizations

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-meraki/sdk/go/meraki/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-meraki/sdk/go/meraki/organizations"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := organizations.NewLicenses(ctx, "example", &organizations.LicensesArgs{
//				DeviceSerial:   pulumi.String("Q234-ABCD-5678"),
//				LicenseId:      pulumi.String("string"),
//				OrganizationId: pulumi.String("string"),
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("merakiOrganizationsLicensesExample", example)
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import meraki:organizations/licenses:Licenses example "license_id,organization_id"
// ```
type Licenses struct {
	pulumi.CustomResourceState

	// The date the license started burning
	ActivationDate pulumi.StringOutput `pulumi:"activationDate"`
	// The date the license was claimed into the organization
	ClaimDate pulumi.StringOutput `pulumi:"claimDate"`
	// Serial number of the device the license is assigned to
	DeviceSerial pulumi.StringOutput `pulumi:"deviceSerial"`
	// The duration of the individual license
	DurationInDays pulumi.IntOutput `pulumi:"durationInDays"`
	// The date the license will expire
	ExpirationDate pulumi.StringOutput `pulumi:"expirationDate"`
	// The id of the head license this license is queued behind. If there is no head license, it returns nil.
	HeadLicenseId pulumi.StringOutput `pulumi:"headLicenseId"`
	// licenseId path parameter. License ID
	LicenseId pulumi.StringOutput `pulumi:"licenseId"`
	// License key
	LicenseKey pulumi.StringOutput `pulumi:"licenseKey"`
	// License type
	LicenseType pulumi.StringOutput `pulumi:"licenseType"`
	// ID of the network the license is assigned to
	NetworkId pulumi.StringOutput `pulumi:"networkId"`
	// Order number
	OrderNumber pulumi.StringOutput `pulumi:"orderNumber"`
	// organizationId path parameter. Organization ID
	OrganizationId pulumi.StringOutput `pulumi:"organizationId"`
	// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
	PermanentlyQueuedLicenses LicensesPermanentlyQueuedLicenseArrayOutput `pulumi:"permanentlyQueuedLicenses"`
	// The number of seats of the license. Only applicable to SM licenses.
	SeatCount pulumi.IntOutput `pulumi:"seatCount"`
	// The state of the license. All queued licenses have a status of *recentlyQueued*.
	State pulumi.StringOutput `pulumi:"state"`
	// The duration of the license plus all permanently queued licenses associated with it
	TotalDurationInDays pulumi.IntOutput `pulumi:"totalDurationInDays"`
}

// NewLicenses registers a new resource with the given unique name, arguments, and options.
func NewLicenses(ctx *pulumi.Context,
	name string, args *LicensesArgs, opts ...pulumi.ResourceOption) (*Licenses, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.LicenseId == nil {
		return nil, errors.New("invalid value for required argument 'LicenseId'")
	}
	if args.OrganizationId == nil {
		return nil, errors.New("invalid value for required argument 'OrganizationId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Licenses
	err := ctx.RegisterResource("meraki:organizations/licenses:Licenses", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLicenses gets an existing Licenses resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLicenses(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LicensesState, opts ...pulumi.ResourceOption) (*Licenses, error) {
	var resource Licenses
	err := ctx.ReadResource("meraki:organizations/licenses:Licenses", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Licenses resources.
type licensesState struct {
	// The date the license started burning
	ActivationDate *string `pulumi:"activationDate"`
	// The date the license was claimed into the organization
	ClaimDate *string `pulumi:"claimDate"`
	// Serial number of the device the license is assigned to
	DeviceSerial *string `pulumi:"deviceSerial"`
	// The duration of the individual license
	DurationInDays *int `pulumi:"durationInDays"`
	// The date the license will expire
	ExpirationDate *string `pulumi:"expirationDate"`
	// The id of the head license this license is queued behind. If there is no head license, it returns nil.
	HeadLicenseId *string `pulumi:"headLicenseId"`
	// licenseId path parameter. License ID
	LicenseId *string `pulumi:"licenseId"`
	// License key
	LicenseKey *string `pulumi:"licenseKey"`
	// License type
	LicenseType *string `pulumi:"licenseType"`
	// ID of the network the license is assigned to
	NetworkId *string `pulumi:"networkId"`
	// Order number
	OrderNumber *string `pulumi:"orderNumber"`
	// organizationId path parameter. Organization ID
	OrganizationId *string `pulumi:"organizationId"`
	// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
	PermanentlyQueuedLicenses []LicensesPermanentlyQueuedLicense `pulumi:"permanentlyQueuedLicenses"`
	// The number of seats of the license. Only applicable to SM licenses.
	SeatCount *int `pulumi:"seatCount"`
	// The state of the license. All queued licenses have a status of *recentlyQueued*.
	State *string `pulumi:"state"`
	// The duration of the license plus all permanently queued licenses associated with it
	TotalDurationInDays *int `pulumi:"totalDurationInDays"`
}

type LicensesState struct {
	// The date the license started burning
	ActivationDate pulumi.StringPtrInput
	// The date the license was claimed into the organization
	ClaimDate pulumi.StringPtrInput
	// Serial number of the device the license is assigned to
	DeviceSerial pulumi.StringPtrInput
	// The duration of the individual license
	DurationInDays pulumi.IntPtrInput
	// The date the license will expire
	ExpirationDate pulumi.StringPtrInput
	// The id of the head license this license is queued behind. If there is no head license, it returns nil.
	HeadLicenseId pulumi.StringPtrInput
	// licenseId path parameter. License ID
	LicenseId pulumi.StringPtrInput
	// License key
	LicenseKey pulumi.StringPtrInput
	// License type
	LicenseType pulumi.StringPtrInput
	// ID of the network the license is assigned to
	NetworkId pulumi.StringPtrInput
	// Order number
	OrderNumber pulumi.StringPtrInput
	// organizationId path parameter. Organization ID
	OrganizationId pulumi.StringPtrInput
	// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
	PermanentlyQueuedLicenses LicensesPermanentlyQueuedLicenseArrayInput
	// The number of seats of the license. Only applicable to SM licenses.
	SeatCount pulumi.IntPtrInput
	// The state of the license. All queued licenses have a status of *recentlyQueued*.
	State pulumi.StringPtrInput
	// The duration of the license plus all permanently queued licenses associated with it
	TotalDurationInDays pulumi.IntPtrInput
}

func (LicensesState) ElementType() reflect.Type {
	return reflect.TypeOf((*licensesState)(nil)).Elem()
}

type licensesArgs struct {
	// Serial number of the device the license is assigned to
	DeviceSerial *string `pulumi:"deviceSerial"`
	// licenseId path parameter. License ID
	LicenseId string `pulumi:"licenseId"`
	// organizationId path parameter. Organization ID
	OrganizationId string `pulumi:"organizationId"`
}

// The set of arguments for constructing a Licenses resource.
type LicensesArgs struct {
	// Serial number of the device the license is assigned to
	DeviceSerial pulumi.StringPtrInput
	// licenseId path parameter. License ID
	LicenseId pulumi.StringInput
	// organizationId path parameter. Organization ID
	OrganizationId pulumi.StringInput
}

func (LicensesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*licensesArgs)(nil)).Elem()
}

type LicensesInput interface {
	pulumi.Input

	ToLicensesOutput() LicensesOutput
	ToLicensesOutputWithContext(ctx context.Context) LicensesOutput
}

func (*Licenses) ElementType() reflect.Type {
	return reflect.TypeOf((**Licenses)(nil)).Elem()
}

func (i *Licenses) ToLicensesOutput() LicensesOutput {
	return i.ToLicensesOutputWithContext(context.Background())
}

func (i *Licenses) ToLicensesOutputWithContext(ctx context.Context) LicensesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LicensesOutput)
}

// LicensesArrayInput is an input type that accepts LicensesArray and LicensesArrayOutput values.
// You can construct a concrete instance of `LicensesArrayInput` via:
//
//	LicensesArray{ LicensesArgs{...} }
type LicensesArrayInput interface {
	pulumi.Input

	ToLicensesArrayOutput() LicensesArrayOutput
	ToLicensesArrayOutputWithContext(context.Context) LicensesArrayOutput
}

type LicensesArray []LicensesInput

func (LicensesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Licenses)(nil)).Elem()
}

func (i LicensesArray) ToLicensesArrayOutput() LicensesArrayOutput {
	return i.ToLicensesArrayOutputWithContext(context.Background())
}

func (i LicensesArray) ToLicensesArrayOutputWithContext(ctx context.Context) LicensesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LicensesArrayOutput)
}

// LicensesMapInput is an input type that accepts LicensesMap and LicensesMapOutput values.
// You can construct a concrete instance of `LicensesMapInput` via:
//
//	LicensesMap{ "key": LicensesArgs{...} }
type LicensesMapInput interface {
	pulumi.Input

	ToLicensesMapOutput() LicensesMapOutput
	ToLicensesMapOutputWithContext(context.Context) LicensesMapOutput
}

type LicensesMap map[string]LicensesInput

func (LicensesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Licenses)(nil)).Elem()
}

func (i LicensesMap) ToLicensesMapOutput() LicensesMapOutput {
	return i.ToLicensesMapOutputWithContext(context.Background())
}

func (i LicensesMap) ToLicensesMapOutputWithContext(ctx context.Context) LicensesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LicensesMapOutput)
}

type LicensesOutput struct{ *pulumi.OutputState }

func (LicensesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Licenses)(nil)).Elem()
}

func (o LicensesOutput) ToLicensesOutput() LicensesOutput {
	return o
}

func (o LicensesOutput) ToLicensesOutputWithContext(ctx context.Context) LicensesOutput {
	return o
}

// The date the license started burning
func (o LicensesOutput) ActivationDate() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.ActivationDate }).(pulumi.StringOutput)
}

// The date the license was claimed into the organization
func (o LicensesOutput) ClaimDate() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.ClaimDate }).(pulumi.StringOutput)
}

// Serial number of the device the license is assigned to
func (o LicensesOutput) DeviceSerial() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.DeviceSerial }).(pulumi.StringOutput)
}

// The duration of the individual license
func (o LicensesOutput) DurationInDays() pulumi.IntOutput {
	return o.ApplyT(func(v *Licenses) pulumi.IntOutput { return v.DurationInDays }).(pulumi.IntOutput)
}

// The date the license will expire
func (o LicensesOutput) ExpirationDate() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.ExpirationDate }).(pulumi.StringOutput)
}

// The id of the head license this license is queued behind. If there is no head license, it returns nil.
func (o LicensesOutput) HeadLicenseId() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.HeadLicenseId }).(pulumi.StringOutput)
}

// licenseId path parameter. License ID
func (o LicensesOutput) LicenseId() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.LicenseId }).(pulumi.StringOutput)
}

// License key
func (o LicensesOutput) LicenseKey() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.LicenseKey }).(pulumi.StringOutput)
}

// License type
func (o LicensesOutput) LicenseType() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.LicenseType }).(pulumi.StringOutput)
}

// ID of the network the license is assigned to
func (o LicensesOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.NetworkId }).(pulumi.StringOutput)
}

// Order number
func (o LicensesOutput) OrderNumber() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.OrderNumber }).(pulumi.StringOutput)
}

// organizationId path parameter. Organization ID
func (o LicensesOutput) OrganizationId() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.OrganizationId }).(pulumi.StringOutput)
}

// DEPRECATED List of permanently queued licenses attached to the license. Instead, use /organizations/{organizationId}/licenses?deviceSerial= to retrieved queued licenses for a given device.
func (o LicensesOutput) PermanentlyQueuedLicenses() LicensesPermanentlyQueuedLicenseArrayOutput {
	return o.ApplyT(func(v *Licenses) LicensesPermanentlyQueuedLicenseArrayOutput { return v.PermanentlyQueuedLicenses }).(LicensesPermanentlyQueuedLicenseArrayOutput)
}

// The number of seats of the license. Only applicable to SM licenses.
func (o LicensesOutput) SeatCount() pulumi.IntOutput {
	return o.ApplyT(func(v *Licenses) pulumi.IntOutput { return v.SeatCount }).(pulumi.IntOutput)
}

// The state of the license. All queued licenses have a status of *recentlyQueued*.
func (o LicensesOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Licenses) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// The duration of the license plus all permanently queued licenses associated with it
func (o LicensesOutput) TotalDurationInDays() pulumi.IntOutput {
	return o.ApplyT(func(v *Licenses) pulumi.IntOutput { return v.TotalDurationInDays }).(pulumi.IntOutput)
}

type LicensesArrayOutput struct{ *pulumi.OutputState }

func (LicensesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Licenses)(nil)).Elem()
}

func (o LicensesArrayOutput) ToLicensesArrayOutput() LicensesArrayOutput {
	return o
}

func (o LicensesArrayOutput) ToLicensesArrayOutputWithContext(ctx context.Context) LicensesArrayOutput {
	return o
}

func (o LicensesArrayOutput) Index(i pulumi.IntInput) LicensesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Licenses {
		return vs[0].([]*Licenses)[vs[1].(int)]
	}).(LicensesOutput)
}

type LicensesMapOutput struct{ *pulumi.OutputState }

func (LicensesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Licenses)(nil)).Elem()
}

func (o LicensesMapOutput) ToLicensesMapOutput() LicensesMapOutput {
	return o
}

func (o LicensesMapOutput) ToLicensesMapOutputWithContext(ctx context.Context) LicensesMapOutput {
	return o
}

func (o LicensesMapOutput) MapIndex(k pulumi.StringInput) LicensesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Licenses {
		return vs[0].(map[string]*Licenses)[vs[1].(string)]
	}).(LicensesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LicensesInput)(nil)).Elem(), &Licenses{})
	pulumi.RegisterInputType(reflect.TypeOf((*LicensesArrayInput)(nil)).Elem(), LicensesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LicensesMapInput)(nil)).Elem(), LicensesMap{})
	pulumi.RegisterOutputType(LicensesOutput{})
	pulumi.RegisterOutputType(LicensesArrayOutput{})
	pulumi.RegisterOutputType(LicensesMapOutput{})
}
